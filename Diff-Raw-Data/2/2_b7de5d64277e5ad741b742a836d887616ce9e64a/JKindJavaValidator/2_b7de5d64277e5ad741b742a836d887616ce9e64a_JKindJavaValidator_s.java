 /*
  * generated by Xtext
  */
 package jkind.xtext.validation;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 import jkind.xtext.jkind.Assertion;
 import jkind.xtext.jkind.BinaryExpr;
 import jkind.xtext.jkind.Constant;
 import jkind.xtext.jkind.Equation;
 import jkind.xtext.jkind.Expr;
 import jkind.xtext.jkind.Field;
 import jkind.xtext.jkind.File;
 import jkind.xtext.jkind.IdExpr;
 import jkind.xtext.jkind.JkindPackage;
 import jkind.xtext.jkind.Node;
 import jkind.xtext.jkind.Property;
 import jkind.xtext.jkind.RecordExpr;
 import jkind.xtext.jkind.SubrangeType;
 import jkind.xtext.jkind.UnaryExpr;
 import jkind.xtext.jkind.Variable;
 import jkind.xtext.jkind.VariableGroup;
 import jkind.xtext.typing.TypeChecker;
 import jkind.xtext.util.Util;
 
 import org.eclipse.emf.ecore.EObject;
 import org.eclipse.xtext.EcoreUtil2;
 import org.eclipse.xtext.validation.Check;
 import org.eclipse.xtext.validation.ComposedChecks;
 
 @ComposedChecks(validators = { NodesAcyclicValidator.class, EquationsAcyclicValidator.class })
 public class JKindJavaValidator extends AbstractJKindJavaValidator {
 	@Check
 	public void checkEquationType(Equation equation) {
 		new TypeChecker(getMessageAcceptor()).check(equation);
 	}
 
 	@Check
 	public void checkAssertionType(Assertion assertion) {
 		new TypeChecker(getMessageAcceptor()).check(assertion);
 	}
 
 	@Check
 	public void checkPropertyType(Property property) {
 		new TypeChecker(getMessageAcceptor()).check(property);
 	}
 
 	@Check
 	public void checkConstantType(Constant constant) {
 		new TypeChecker(getMessageAcceptor()).check(constant);
 	}
 
 	@Check
 	public void checkSubrangeNonempty(SubrangeType subrangeType) {
 		if (subrangeType.getLow().compareTo(subrangeType.getHigh()) > 0) {
 			error("Subrange must be non-empty");
 		}
 	}
 
 	@Check
 	public void checkConstantHasConstantValue(Constant constant) {
 		if (!isConstant(constant.getExpr())) {
 			error(constant.getName() + " does not have constant value");
 		}
 	}
 
 	private Boolean isConstant(Expr expr) {
 		return new ConstantAnalyzer().doSwitch(expr);
 	}
 
 	@Check
 	public void checkRecordExprFieldsUnique(RecordExpr record) {
 		Set<Field> seen = new HashSet<>();
 		Set<Field> marked = new HashSet<>();
 		for (Field field : record.getFields()) {
 			if (seen.contains(field) && !marked.contains(field)) {
 				marked.add(field);
 				errorDuplicateField(record, field);
 			}
 			seen.add(field);
 		}
 	}
 
 	private void errorDuplicateField(RecordExpr record, Field field) {
 		for (int i = 0; i < record.getFields().size(); i++) {
 			if (record.getFields().get(i).equals(field)) {
 				error("Duplicate field " + field.getName(), record,
 						JkindPackage.Literals.RECORD_EXPR__FIELDS, i);
 			}
 		}
 	}
 
 	@Check
 	public void checkNodeVariableAssignments(Node node) {
 		List<Variable> assigned = new ArrayList<>();
 		List<Variable> toAssign = new ArrayList<>();
 		for (VariableGroup group : node.getOutputs()) {
 			toAssign.addAll(group.getVariables());
 		}
 		for (VariableGroup group : node.getLocals()) {
 			toAssign.addAll(group.getVariables());
 		}
 
 		for (Equation eq : node.getEquations()) {
 			for (int i = 0; i < eq.getLhs().size(); i++) {
 				Variable var = eq.getLhs().get(i);
 				if (assigned.contains(var)) {
 					error("Variable " + var.getName() + " already assigned", eq,
 							JkindPackage.Literals.EQUATION__LHS, i);
 				} else if (!toAssign.contains(var)) {
 					error("Input variable " + var.getName() + " cannot be assigned", eq,
 							JkindPackage.Literals.EQUATION__LHS, i);
 				}
 				assigned.add(var);
 				toAssign.remove(var);
 			}
 		}
 
 		for (Variable var : toAssign) {
 			error("Variable " + var.getName() + " is not assigned", var);
 		}
 	}
 
 	@Check
 	public void checkNodeVariableUse(Node node) {
 		List<Variable> toUse = new ArrayList<>();
 		for (VariableGroup group : node.getInputs()) {
 			toUse.addAll(group.getVariables());
 		}
 		for (VariableGroup group : node.getLocals()) {
 			toUse.addAll(group.getVariables());
 		}
 
 		for (IdExpr idExpr : EcoreUtil2.getAllContentsOfType(node, IdExpr.class)) {
 			toUse.remove(idExpr.getId());
 		}
 		for (Property property : node.getProperties()) {
 			toUse.remove(property.getRef());
 		}
 
 		for (Variable var : toUse) {
 			warning("Variable " + var.getName() + " is not used", var);
 		}
 	}
 
 	@Check
 	public void checkPropertiesUnique(Node node) {
 		Set<Variable> seen = new HashSet<>();
 		for (Property property : node.getProperties()) {
 			Variable variable = property.getRef();
 			if (seen.contains(variable)) {
 				error(variable.getName() + " already declared as property", property);
 			}
 			seen.add(variable);
 		}
 	}
 
 	@Check
 	public void checkLinear(BinaryExpr e) {
 		switch (e.getOp()) {
 		case "*":
 			if (!isConstant(e.getLeft()) && !isConstant(e.getRight())) {
 				error("Nonlinear multiplication not supported");
 			}
 			break;
 
 		case "/":
 		case "div":
 			if (!isConstant(e.getRight())) {
 				error("Non-constant division not supported");
 			}
 			break;
 		}
 	}
 
 	@Check
 	public void checkDivideByZero(BinaryExpr e) {
 		if (e.getOp().equals("/") || e.getOp().equals("div")) {
 			if (isZero(e.getRight())) {
 				error("Division by zero");
 			}
 		}
 	}
 
 	// TODO: Implement constant evaluation
 	private boolean isZero(Expr expr) {
 		return false;
 	}
 
 	@Check
 	public void checkUnusedAssertion(Assertion e) {
 		Node node = EcoreUtil2.getContainerOfType(e, Node.class);
 		if (!isMainNode(node)) {
 			warning("Assertion in non-main node is ignored");
 		}
 	}
 
 	@Check
 	public void checkMainAnnotation(Node node) {
 		if (!node.getMain().isEmpty() && !isMainNode(node)) {
 			warning("Node " + node.getName() + " marked as main, but is not treated as main node",
 					node, JkindPackage.Literals.NODE__MAIN);
 		}
 	}
 
 	private boolean isMainNode(Node node) {
 		File file = EcoreUtil2.getContainerOfType(node, File.class);
 		return node.equals(Util.getMainNode(file));
 	}
 	
 	@Check
 	public void checkUnguardedPre(UnaryExpr e) {
 		if (e.getOp().equals("pre")) {
 			Expr curr = e;
 			while (curr.eContainer() instanceof Expr) {
 				Expr parent = (Expr) curr.eContainer();
 				if (parent instanceof BinaryExpr) {
 					BinaryExpr be = (BinaryExpr) parent;
 					if (be.getOp().equals("->") && be.getRight().equals(curr)) {
 						// Guarded
 						return;
 					}
 				} else if (parent instanceof UnaryExpr) {
 					UnaryExpr ue = (UnaryExpr) parent;
 					if (ue.getOp().equals("pre")) {
 						// Unguarded
 						break;
 					}
 				}
 				curr = parent;
 			}
			warning("Unguarded pre expression");
 		}
 	}
 
 	private void error(String message) {
 		error(message, null);
 	}
 
 	private void error(String message, EObject source) {
 		error(message, source, null);
 	}
 
 	private void warning(String message) {
 		warning(message, null);
 	}
 
 	private void warning(String message, EObject source) {
 		warning(message, source, null);
 	}
 }
