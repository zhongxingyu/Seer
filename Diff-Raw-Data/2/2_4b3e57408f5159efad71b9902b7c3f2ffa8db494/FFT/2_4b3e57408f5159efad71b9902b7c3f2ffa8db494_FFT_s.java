 package plugins.praveen.fft;
 
 import edu.emory.mathcs.jtransforms.fft.DoubleFFT_2D;
 import icy.image.IcyBufferedImage;
 import icy.sequence.Sequence;
 import icy.type.DataType;
 import icy.type.collection.array.Array1DUtil;
 import plugins.adufour.ezplug.EzPlug;
 import plugins.adufour.ezplug.EzVarSequence;
 import plugins.adufour.ezplug.EzVarText;
 import icy.gui.dialog.MessageDialog;
 
 public class FFT extends EzPlug {
 
 	EzVarSequence input = new EzVarSequence("Input");
 	EzVarText	type_2D = new EzVarText("Type", new String[] { "2D", "3D" }, 0, false);
 	EzVarText	display = new EzVarText("Display as", new String[] {  "Magnitude/Phase Pair", "Real/Imaginary Pair" }, 0, false);
 	EzVarText	swap = new EzVarText("Swap Quadrants?", new String[] { "Yes", "No" }, 1, false);
 
 	@Override
 	protected void initialize() {
 		// TODO Auto-generated by Icy4Eclipse
 		super.addEzComponent(input);
 		super.addEzComponent(type_2D);
 		super.addEzComponent(swap);
 		super.addEzComponent(display);		
 		super.setTimeDisplay(true);
 	}
 
 	@Override
 	protected void execute() {
 		// TODO Auto-generated by Icy4Eclipse
 
 		Sequence sequence = input.getValue();
 
 		if(type_2D.getValue()=="2D")		
 			FFT_2D(sequence, swap.getValue(), display.getValue());	
 		else
 			MessageDialog.showDialog("FFT3D not implemented yet !");	
 	}
 
 
 
 	private Sequence FFT_2D(Sequence sequence, String swap, String display) 
 	{
 		Sequence fImage = new Sequence();
 		fImage.setName("Fourier Transform");
 		// TODO Auto-generated method stub
 		//sequence = sequence.convertToType(DataType.DOUBLE, true);
 		int _w = sequence.getSizeX();
 		int _h = sequence.getSizeY();
 		int _z = sequence.getSizeZ();
 		int wc = (int) Math.ceil(_w/2);
 		int hc = (int) Math.ceil(_h/2);
 
 		final DoubleFFT_2D fft = new DoubleFFT_2D(_w, _h);
 		if(swap == "No")
 		{ //No Quadrant swapping
 
 			for(int k = 0; k < _z; k++)
 			{
 				IcyBufferedImage resultArray = new IcyBufferedImage(_w, _h, 2, DataType.DOUBLE);
 
 				resultArray.setDataXY(0, Array1DUtil.arrayToDoubleArray(sequence.getDataXY(0, k, 0), sequence.isSignedDataType()));
 				double[] fArray = resultArray.getDataCopyCXYAsDouble();
 				fft.complexForward(fArray);//Does only on half the data. To get the full transform use realForwardFull
 				resultArray.beginUpdate();
 				try
 				{
 					if(display=="Magnitude/Phase Pair")
 						for(int x = 0; x < _w; x++)
 						{
 							for(int y = 0; y < _h; y++)
 							{
 								resultArray.setDataAsDouble(x, y, 0, Math.sqrt(Math.pow(fArray[(x + y * _h)*2 + 0], 2) + Math.pow(fArray[(x + y * _h)*2 + 1], 2)));
								resultArray.setDataAsDouble(x, y, 0, Math.sqrt(Math.pow(fArray[(x + y * _h)*2 + 0], 2) + Math.pow(fArray[(x + y * _h)*2 + 1], 2)));
 							}
 						}
 					else // Real/Imaginary Pair
 						for(int x = 0; x < _w; x++)
 						{
 							for(int y = 0; y < _h; y++)
 							{
 								resultArray.setDataAsDouble(x, y, 0, fArray[(x + y * _h)*2 + 0]);
 								resultArray.setDataAsDouble(x, y, 1, fArray[(x + y * _h)*2 + 1]);
 							}
 						}					
 
 				}finally{
 					resultArray.endUpdate();
 				}
 
 				fImage.setImage(0, k, resultArray);
 			}
 		}
 		else
 		{
 			for(int k = 0; k < _z; k++)
 			{
 				IcyBufferedImage resultArray = new IcyBufferedImage(_w, _h, 2, DataType.DOUBLE);
 
 				resultArray.setDataXY(0, Array1DUtil.arrayToDoubleArray(sequence.getDataXY(0, k, 0), sequence.isSignedDataType()));
 				double[] fArray = resultArray.getDataCopyCXYAsDouble();
 				fft.complexForward(fArray);//Does only on half the data. To get the full transform use realForwardFull
 				resultArray.beginUpdate();
 				try
 				{
 					if(display=="Magnitude/Phase Pair")
 					{
 						for(int x = 0; x < (wc+1); x++)
 						{
 							for(int y = 0; y < (hc+1); y++)
 							{
 								resultArray.setDataAsDouble(x, y, 0, Math.sqrt(Math.pow(fArray[((wc-x) + (hc-y) * _h)*2 + 0], 2)+Math.pow(fArray[((wc-x) + (hc-y) * _h)*2 + 1], 2)));
 								resultArray.setDataAsDouble(x, y, 1, Math.atan2(fArray[((wc-x) + (hc-y) * _h)*2 + 1], fArray[((wc-x) + (hc-y) * _h)*2 + 0]));
 							}
 							for(int y = hc+1; y < _h; y++)
 							{
 								resultArray.setDataAsDouble(x, y, 0, Math.sqrt(Math.pow(fArray[((wc-x) + (y-hc) * _h)*2 + 0], 2)+Math.pow(fArray[((wc-x) + (y-hc) * _h)*2 + 1], 2)));
 								resultArray.setDataAsDouble(x, y, 1, Math.atan2(fArray[((wc-x) + (y-hc) * _h)*2 + 1], fArray[((wc-x) + (y-hc) * _h)*2 + 0]));
 							}
 
 						}
 						for(int x = (wc+1); x < _w; x++)
 						{
 							for(int y = 0; y < (hc+1); y++)
 							{
 								resultArray.setDataAsDouble(x, y, 0, Math.sqrt(Math.pow(fArray[((x-wc) + (hc-y) * _h)*2 + 0], 2)+Math.pow(fArray[((x-wc) + (hc-y) * _h)*2 + 1], 2)));
 								resultArray.setDataAsDouble(x, y, 1, Math.atan2(fArray[((x-wc) + (hc-y) * _h)*2 + 1], fArray[((x-wc) + (hc-y) * _h)*2 + 0]));
 							}
 							for(int y = hc+1; y < _h; y++)
 							{
 								resultArray.setDataAsDouble(x, y, 0, Math.sqrt(Math.pow(fArray[((x-wc) + (y-hc) * _h)*2 + 0], 2)+Math.pow(fArray[((x-wc) + (y-hc) * _h)*2 + 1], 2)));
 								resultArray.setDataAsDouble(x, y, 1, Math.atan2(fArray[((x-wc) + (y-hc) * _h)*2 + 1], fArray[((x-wc) + (y-hc) * _h)*2 + 0]));
 							}
 						}
 					}					
 					else //Real/Imaginary Pair
 					{
 						for(int x = 0; x < (wc+1); x++)
 						{
 							for(int y = 0; y < (hc+1); y++)
 							{
 								resultArray.setDataAsDouble(x, y, 0, fArray[((wc-x) + (hc-y) * _h)*2 + 0]);
 								resultArray.setDataAsDouble(x, y, 1, fArray[((wc-x) + (hc-y) * _h)*2 + 1]);
 							}
 							for(int y = hc+1; y < _h; y++)
 							{
 								resultArray.setDataAsDouble(x, y, 0, fArray[((wc-x) + (y-hc) * _h)*2 + 0]);
 								resultArray.setDataAsDouble(x, y, 1, fArray[((wc-x) + (y-hc) * _h)*2 + 1]);
 							}
 
 						}
 						for(int x = (wc+1); x < _w; x++)
 						{
 							for(int y = 0; y < (hc+1); y++)
 							{
 								resultArray.setDataAsDouble(x, y, 0, fArray[((x-wc) + (hc-y) * _h)*2 + 0]);
 								resultArray.setDataAsDouble(x, y, 1, fArray[((x-wc) + (hc-y) * _h)*2 + 1]);
 							}
 							for(int y = hc+1; y < _h; y++)
 							{
 								resultArray.setDataAsDouble(x, y, 0, fArray[((x-wc) + (y-hc) * _h)*2 + 0]);
 								resultArray.setDataAsDouble(x, y, 1, fArray[((x-wc) + (y-hc) * _h)*2 + 1]);
 							}
 						}						
 						
 					}
 
 				}finally{
 					resultArray.endUpdate();
 				}
 
 				fImage.setImage(0, k, resultArray);
 			}
 		}
 
 
 		addSequence(fImage);
 
 		return fImage;
 	}
 
 	@Override
 	public void clean() {
 		// TODO Auto-generated by Icy4Eclipse
 	}
 }
