 /*
  *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
  *  http://www.geo-solutions.it
  *
  *  GPLv3 + Classpath exception
  *
  *  This program is free software: you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
  *  the Free Software Foundation, either version 3 of the License, or
  *  (at your option) any later version.
  *
  *  This program is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *  GNU General Public License for more details.
  *
  *  You should have received a copy of the GNU General Public License
  *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 package it.geosolutions.geobatch.destination.vulnerability;
 
 import it.geosolutions.destination.utils.BufferUtils;
 import it.geosolutions.geobatch.destination.vulnerability.TargetManager.TargetInfo;
 
 import java.awt.Rectangle;
 import java.awt.geom.Rectangle2D;
 import java.awt.image.RenderedImage;
 import java.awt.image.renderable.ParameterBlock;
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 
 import javax.imageio.ImageIO;
 import javax.imageio.stream.ImageInputStream;
 import javax.media.jai.JAI;
 import javax.media.jai.ParameterBlockJAI;
 import javax.media.jai.ROI;
 import javax.media.jai.RenderedOp;
 
 import org.geotools.data.DataUtilities;
 import org.geotools.data.simple.SimpleFeatureCollection;
 import org.geotools.data.simple.SimpleFeatureIterator;
 import org.geotools.gce.geotiff.GeoTiffReader;
 import org.geotools.geometry.jts.JTS;
 import org.geotools.image.jai.Registry;
 import org.jaitools.imageutils.ROIGeometry;
 import org.jaitools.media.jai.zonalstats.Result;
 import org.jaitools.media.jai.zonalstats.ZonalStats;
 import org.jaitools.media.jai.zonalstats.ZonalStatsDescriptor;
 import org.jaitools.media.jai.zonalstats.ZonalStatsRIF;
 import org.jaitools.numeric.Range;
 import org.jaitools.numeric.Statistic;
 import org.opengis.feature.simple.SimpleFeature;
 import org.opengis.referencing.datum.PixelInCell;
 import org.opengis.referencing.operation.MathTransform;
 import org.opengis.referencing.operation.NoninvertibleTransformException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.sun.media.jai.operator.ImageReadDescriptor;
 import com.vividsolutions.jts.geom.Envelope;
 import com.vividsolutions.jts.geom.Geometry;
 
 /**
  * @author DamianoG
  * @author Daniele Romagnoli, GeoSolutions SAS
  *
  */
 public class VulnerabilityUtils {
 
     private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityUtils.class);
     
     static {
         try {
        	ImageIO.scanForPlugins();
             Registry.registerRIF(JAI.getDefaultInstance(), new ZonalStatsDescriptor(),
                     new ZonalStatsRIF(), Registry.JAI_TOOLS_PRODUCT);
 
         } catch (Throwable e) {
             // swallow exception in case the op has already been registered.
         }
     }
     
     public static Map<Double, Geometry> computeBuffers(SimpleFeature arc, DistancesPair distances){
                 
         Double[] distanceValues = distances.getRight();
         Geometry geometry = (Geometry)arc.getDefaultGeometry();
         Map<Double, Geometry> bufferMap = new HashMap<Double, Geometry>();
         double previousDistance = 0.0;
         for(int count = 0; count  < distanceValues.length; count++) {        	
         	double distanceValue = distanceValues[count];
         	
         	geometry = BufferUtils.iterativeBuffer(geometry, distanceValue - previousDistance, 200);
         	previousDistance = distanceValue;
         	
         	bufferMap.put(distanceValue, geometry);
         }
         
         return bufferMap;
     }
     
     
     /**
      * Convert originGeom into the raster space using the provided w2g
      * 
      * @param originGeom the origin geometry to convert
      * @param gtr
      * @return 
      * @throws Exception
      * @throws Exception
      */
     public static Geometry toRasterSpace(Geometry originGeom, MathTransform w2g) throws Exception,
             Exception {
 
         if (originGeom == null)
             LOGGER.info("--> " + originGeom);
         return JTS.transform(originGeom, w2g);
     }
 
     public static Double getNoDataValue(GeoTiffReader gtr) {
 
         if (!gtr.getMetadata().hasNoData()) {
             return null;
         }
         return gtr.getMetadata().getNoData();
     }
     
     public static RenderedImage cropImage(RenderedImage image, Geometry roi){
         
         ParameterBlock pb = new ParameterBlock();
         pb.addSource(image);
         Envelope bbox = roi.getEnvelopeInternal();
         try {
 	        Envelope imageBbox = new Envelope(image.getMinX(), image.getWidth(), image.getMinY(), image.getHeight());
 	        Envelope finalBBox = imageBbox.intersection(bbox);
 	        if(finalBBox == null || finalBBox.isNull()){
 	            return null;
 	        }
 	        setCropParam(pb, finalBBox, image);
 	        //Creates the cropped area
 	        image = JAI.create("Crop", pb);
         } catch(Throwable t) {
         	t.printStackTrace();
         }
         
         return image;
     }
     
     /**
      * Set the crop parameters. Make sure the resulting crop is fully contained within the image bbox.
      * Also do some small refinements in case the rounded values are outside the edges.
      * @param pb
      * @param finalBBox
      * @param image
      */
     private static void setCropParam(ParameterBlock pb, Envelope finalBBox, RenderedImage image) {
         double finalX = finalBBox.getMinX();
         double finalY = finalBBox.getMinY();
         double finalWidth = finalBBox.getWidth();
         double finalHeight = finalBBox.getHeight();
 
         // Get the original image properties
         final int imageMinX = image.getMinX();
         final int imageMinY = image.getMinY();
         final int imageMaxX = imageMinX + image.getWidth();
         final int imageMaxY = imageMinY + image.getHeight();
 
         // Setup the same requested rectangle which is computed by the crop operation
         final Rectangle rect_req =
                 (new Rectangle2D.Float((float)finalX, (float)finalY, (float)finalWidth, (float)finalHeight)).getBounds();
         final int requestedMinX = (int)rect_req.getMinX();
         final int requestedMinY = (int)rect_req.getMinY();
         final int requestedMaxX = (int)rect_req.getMaxX();
         final int requestedMaxY = (int)rect_req.getMaxY();
 
         // Refine the edge to solve some issues on corner cases
         if (requestedMinX < imageMinX) {
             finalX = imageMinX;
         }
         if (requestedMaxX > imageMaxX) {
             finalWidth -= 1;//0.5;
         }
         if (requestedMinY < imageMinY) {
             finalY = imageMinY;
         }
         if (requestedMaxY > imageMaxY) {
             finalHeight -= 1;//0.5;
         }
         
         if(finalWidth <= 0) {
         	finalWidth = 1;
         }
         
         if(finalHeight <= 0) {
         	finalHeight = 1;
         }
 
         // Set the cropping parameters
         pb.add((float)finalX);
         pb.add((float)finalY);
         pb.add((float)finalWidth);
         pb.add((float)finalHeight);
     }
 
 
     /**
      * Perform the sum of the pixels of the provided raster inside the ROI and on the selected band.
      * @param roiGeom
      * @param image
      * @param noData
      * @param band
      * @param valuesToCount if NULL the sum is performed on all values not equals to NODATA, otherwise the sum is performed on each group of Integer.
      *                          Basically this parameter means that the clients want to count the pixels with certain value using getNumOffered() method of Result class  
      * 
      * @return the result as JaiTools Result object
      */
 	public static List<Result> sumCellsInsideBuffer(Geometry roiGeom,
 			RenderedImage image, Double noData, int band,
 			Map<Integer, String> valuesToCount) {
         
         if(LOGGER.isDebugEnabled()){
             image.getHeight();
             LOGGER.debug("roiGeom: " + ((roiGeom!=null)?roiGeom.getArea():"null") +
                             " - image: " + image + 
                             " - noData:" + noData +
                             " - band:" + band +
                             " - valuesToCount:" + valuesToCount + " size: " + ((valuesToCount!=null)?valuesToCount.size():"null") 
                             );
         }
         ROI roi = new ROIGeometry(roiGeom);
         ParameterBlockJAI pb = new ParameterBlockJAI("ZonalStats");
         pb.setSource("dataImage", image);
         // pb.setSource("zoneImage", myZones);
         pb.setParameter("roi", roi);
 
         Statistic[] stats = { Statistic.SUM, };
 
         pb.setParameter("stats", stats);
         pb.setParameter("bands", new Integer[] { band });
         
         if(valuesToCount!= null && !valuesToCount.isEmpty()){
             List<Range> ranges = new ArrayList<Range>();
             for(Integer el : valuesToCount.keySet()){
                 ranges.add(new Range(el, true, el, true));
             }
             pb.setParameter("ranges", ranges);
             pb.setParameter("rangesType",Range.Type.INCLUDE);
             pb.setParameter("rangeLocalStats",Boolean.TRUE);
         }
         
         List<Range> dataNDR = null;
         if (noData != null) {
             Range nodata = new Range(noData, true, noData, true);
             dataNDR = new ArrayList<Range>();
             dataNDR.add(nodata);
             pb.setParameter("noDataRanges", dataNDR);
         }
         
         RenderedOp op = JAI.create("ZonalStats", pb);
 
         ZonalStats res = (ZonalStats) op.getProperty(ZonalStatsDescriptor.ZONAL_STATS_PROPERTY);
 
         return res.results();
     }
     
     /**
      * Loads a {@link RenderedImage} from the specified file with the specified mode.
      * 
      * @param mode, {@link ComputationMode} can be {@link ComputationMode#DEFERRED} or {@link ComputationMode#IMMEDIATE} as per the JAI meaning.
      * @param tiffFile the input {@link File} where to read from.
      * 
      * @return
      * @throws IOException in case the creation of the {@link ImageInputStream} or the Immediate read with Imageio fails.
      */
     public static RenderedImage loadImage(boolean deferred, File tiffFile) throws IOException {
         // checks
         if (!tiffFile.isFile() || !tiffFile.exists() || !tiffFile.canRead()) {
             throw new IllegalArgumentException("Unable to load image from file: "
                     + tiffFile.getAbsolutePath() + "\n" + "isFile=" + tiffFile.isFile() + "\n"
                     + "exists=" + tiffFile.exists() + "\n" + "canRead=" + tiffFile.canRead());
         }
 
         if (deferred) {
             final ImageInputStream inStream = ImageIO.createImageInputStream(tiffFile);
             if (inStream == null) {
                 throw new IllegalArgumentException("Unable to create input stream from file: "
                         + tiffFile.getAbsolutePath() + "\n" + "isFile=" + tiffFile.isFile() + "\n"
                         + "exists=" + tiffFile.exists() + "\n" + "canRead=" + tiffFile.canRead());
             }
             return ImageReadDescriptor.create(inStream, Integer.valueOf(0), false, false, false,
                     null, null, null, null, null);
         } else {
             return ImageIO.read(tiffFile);
         }
     }
     
     /**
      * Setup {@link TargetInfo} objects on top of the specified targetURIs
      * @param targetURIs
      * @return
      * @throws IOException
      * @throws NoninvertibleTransformException
      */
 	public static Map<String, TargetInfo> loadTargets(String basePath,
 			Map vulnerabilityCfg, int pixelArea) throws IOException {
         Map<String,TargetInfo> targetInfo = new HashMap<String,TargetInfo>();  
         
         Iterator iter = vulnerabilityCfg.keySet().iterator();
         while(iter.hasNext()){
             int key = (Integer)iter.next();
             Map targetCfg = (Map)vulnerabilityCfg.get(key);
             if(targetCfg.containsKey("FILENAME") && !targetCfg.containsKey("ISGROUP")) {
 	            String imgPath = (String)targetCfg.get("FILENAME");
 				TargetType type =  targetCfg.containsKey("HUMANS") && (Boolean)targetCfg.get("HUMANS") ? TargetType.COMPUTEPIXEL
 						: TargetType.COMPUTEAREA;
 	            File inputImage = new File(basePath + File.separator + imgPath);
 	            if(!inputImage.exists()) {
 	            	if(targetCfg.containsKey("GROUP")) {
 	            		int group = (Integer)targetCfg.get("GROUP");
 	            		Map groupCfg = (Map)vulnerabilityCfg.get(group);
 	            		if(groupCfg != null) {
 	            			imgPath = (String)groupCfg.get("FILENAME");
 	            			inputImage = new File(basePath + File.separator + imgPath);
 	            			if(inputImage.exists()) {
 	            				type = TargetType.GROUPED;
 	            			}
 	            		}
 	            	}
 	            }
 	            if(inputImage.exists()) {
 		            RenderedImage image = VulnerabilityUtils.loadImage(true, inputImage);
 		            GeoTiffReader gtr = null;
 		            try {
 		                gtr = new GeoTiffReader(inputImage);
 		                MathTransform w2g = getWorld2Grid(gtr); 
 		                Double noData = getNoDataValue(gtr);
 		                TargetInfo info = new TargetInfo("" + key, w2g,
 								noData, image, type, vulnerabilityCfg, pixelArea);
 		                boolean hasBeenMerged = false;
 		                for(String existingKey : targetInfo.keySet()) {
 		                	TargetInfo merged = targetInfo.get(existingKey).mergeWith(info);
 		                	if(merged != null) {
 		                		hasBeenMerged = true;
 		                	}
 		                	
 		                }
 		                if(!hasBeenMerged) {
 		                	targetInfo.put("" + key, info);
 		                }
 						
 		
 		            } finally {
 		                if (gtr != null){
 		                    try {
 		                        gtr.dispose();
 		                    } catch (Throwable t) {
 		                        
 		                    }
 		                }
 		            }
 	            } else {
 	            	// check for group
 	            	
 	            }
             }
         }
         return targetInfo;
     }
     
 	public static Map<String, Double[]> loadDistances(Map vulnerabilityCfg){
         
         Map<String, Double[]> map = new HashMap<String, Double[]>();
         
         Iterator iter = vulnerabilityCfg.keySet().iterator();
         while(iter.hasNext()){
             int key = (Integer)iter.next();
             Map cfg = (Map)vulnerabilityCfg.get(key);
             if(cfg.containsKey("DISTANCES")) {
             	String el = (String)cfg.get("DISTANCES");
             	Double[] distances = createDistancesArray(el);
                 map.put(""+key, distances);
             }
             
             
         }
         return map;
     }
 	
 	public static Double[] createDistancesArray(String csvDistances){
         
         String[] distances = csvDistances.split(";");
         Double[] distancesInt = new Double[distances.length];
         for(int j=0; j<distancesInt.length; j++){
             distancesInt[j] = Double.parseDouble(distances[j]);
         }
         return distancesInt;
     }
 	
     public static MathTransform getWorld2Grid(GeoTiffReader gtr) throws IOException {
         // get the world to grid matrix
         MathTransform g2w = gtr.getOriginalGridToWorld(PixelInCell.CELL_CORNER);
         try {
             return g2w.inverse();
         } catch (NoninvertibleTransformException e) {
             throw new IOException(
                     "exception occurred while computing target transformation",
                     e.getCause());
         }
     }
 
 
     public static Map<String,GeoTiffReader> loadGTIFFReaders(Properties targetURIs) throws IOException{
         Map<String,GeoTiffReader> targetReaders = new HashMap<String,GeoTiffReader>();
         Iterator iter = targetURIs.keySet().iterator();
         while(iter.hasNext()){
             String el2 = (String)iter.next();
             String imgAbsolutePath = targetURIs.getProperty(el2);
             GeoTiffReader gtr = new GeoTiffReader(new File(imgAbsolutePath));
             targetReaders.put(el2, gtr);
         }
         return targetReaders;
     }
     
     public static void disposeGTIFFReaders(Map<String,GeoTiffReader> readersMap) throws IOException{
         for(String el : readersMap.keySet()){
             GeoTiffReader gtr = readersMap.get(el);
             if (gtr != null){
                 gtr.dispose();
             }
         }
     }
 
 
 	/**
 	 * @param i
 	 * @return
 	 */
 	public static List<Integer> loadGroupValues(int group, Map vulnerabilityCfg) {
 		List<Integer> result = new ArrayList<Integer>();
         
         Iterator iter = vulnerabilityCfg.keySet().iterator();
         while(iter.hasNext()){
             int key = (Integer)iter.next();
             Map cfg = (Map)vulnerabilityCfg.get(key);
             if(cfg.containsKey("GROUP") && cfg.containsKey("GROUPVALUE")) {
             	int groupId = (Integer)cfg.get("GROUP");
             	if(groupId == group) {
             		int groupValue = (Integer)cfg.get("GROUPVALUE");
             		result.add(groupValue);
             	}            	
             }
             
             
         }
         return result;
 	}
 }
