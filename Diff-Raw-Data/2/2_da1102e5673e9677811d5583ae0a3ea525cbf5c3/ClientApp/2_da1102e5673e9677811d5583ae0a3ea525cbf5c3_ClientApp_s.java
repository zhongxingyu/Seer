 // ClientApp.java
 // Copyright (c) 2012 Andrew Downing
 // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 // The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 
 /**
 @mainpage German Whist card game
 
 @section cardimg Note About Card Images
 
 Extract Mr. Crowley's card images to the folder card_img/.
 
 @section networknote Note About Networking Errors
 
 If the server and the client are run on the same computer, the networking usually works fine. However, if they are run on different computers, then messages may fairly frequently (but at unpredictable times) not be received correctly, causing dropped messages or disconnects. Prof. Crowley said I won't be penalized for this, so I didn't take the time to implement packet numbering and re-requesting.
 
 @section overview Overview
 
 This Java program implements the card game German Whist as described at https://en.wikipedia.org/wiki/German_Whist , using a client-server model and including an AI client. See compile.txt for compiling and usage instructions.
 
 @section serverreqs Server Requirements
 
 - Save player data when it changes and load it at startup.
 - Send data to the clients when they request it or when otherwise appropriate.
 - Allow clients to start and stop a game, request player stats, sign in, create a player, and play the game (1 client per player).
 
 @section clientreqs Client Requirements
 - Implement German Whist as described at https://en.wikipedia.org/wiki/German_Whist .
 - The client represents a single player, and must interface with a server to play a game and do other activities.
 - Use menus for starting and stopping a game, exiting, creating players, and listing all players.
 - Have a panel each for creating players, displaying player stats, signing in to a player, and playing the game (1 client per player).
 - The program must use a GUI for all input and output. (Note that I occasionally outputted unrecoverable errors in the terminal.)
 - Include a separate AI client program that uses an AI to choose cards to play.
 
 @section classes Classes
 
 See the "Classes" tab at the top of the page.
 
 @section globals Global Data/Functions
 
 Java requires that all variables and functions are in a class, so there are no global variables or functions. (Am I misinterpreting this section?)
 
 @section arch High-level Architecture
 
Instead of using a separate thread for each client connection, I decided to instead poll for new messages with a short timeout in case there are no new messages, influencing my architecture. In the loop() method, the ServerApp class polls for new messages every 100 milliseconds and responds to them if it receives new ones. The ClientApp class sends messages throughout the code, but only receives messages in the method pollServer() which is called every 100 milliseconds using a timer. They network using the PlayerSocket class, which is a wrapper around Java's networking API that represents a single player. Classes that can be used as messages end with Msg, and since I would have written them as structures in C++, I made all variables in these classes publicly accessible. To synchronize games between clients, I decided that since the client needed to know many of the game rules anyway (such as whether a given card is a valid one to play and whether it's a valid time to play it), I might as well implement all of the game rules on the client and only use the server to broadcast messages that each client sends. (I only needed one message type containing a single int saying which card was played. I think this decision reduced the total amount and complexity of the code overall.) To make sure clients start out with the same game, they all use the same random number seed randomly generated by one of the clients to generate the game. The AI is implemented in a subclass of GamePanel called GameAIPanel. Since the AI client benefits from much of the GUI code anyway to sign in and pick a game to join, the main() method that starts the AI client simply creates a ClientApp panel with a different constructor argument. The sole effect on the ClientApp panel is to change the window title and to create a GameAIPanel instead of a GamePanel in the constructor. (Since I used inheritance, the ClientApp code other than the constructor can treat the GameAIPanel in exactly the same way.)
 
 @section ui User Interface
 
 There are 2 menus: Player and Game. The Player menu lets the user sign in, create a new player (which must be done the first time you play), change the password, delete the account, view the leaderboard, and exit. The Game menu lets the user join a game or view the status of the upcoming game, continue the game if the user has switched to a different panel, or abruptly stop the game for all users. The sign in/new player panel requests the server address, player name, and password, with a submit button at the bottom and a label to display messages or errors. Changing the password simply involves entering a new password and pressing the Change Password button, and deleting the account requires password confirmation. In terms of the GUI, the game lobby is the biggest difference from homework 2. If the user hasn't joined a game, the user will be presented with a list of games to join and an additional button to host a new game. If the user has joined a game, the players in the upcoming game will be displayed, with buttons to leave or start the game. In-game, the talon deck is at the upper right, the player's hand is spread out along the bottom, and a status display is at top center. When it is the user's turn, the user plays a card by clicking it, moving the card to the upper left. When all players have played a card, the winner of the trick is determined and each player receives 1 card from the talon. When the game has ended, the winner is displayed with instructions to start a new game. (See https://en.wikipedia.org/wiki/German_Whist for more detailed game rules.)
 
 @section testing Test Cases
 
 In addition to those from homework 2, cases to test for include networking errors (which are mostly handled in the PlayerSocket class), making sure the server can handle multiple simultaneous synchronized game sessions since I decided to implement that, making sure the server saves the players file at the right times, ignoring messages sent at the wrong time, and handling off-nominal disconnections. Nominal test cases include adding and deleting (valid) players, viewing player stats, and starting a game. The PlayerSocket class handles the off-nominal case of a StreamCorruptedException being thrown by disconnecting from the network. Changing this to something more intelligent might be a good idea if I were to improve upon the game in the future, considering the frequency at which this error is thrown when the clients and server are on different computers. (If the server and the client are run on the same computer, the networking usually works fine.)
 */
 
 import java.util.*;
 import java.awt.*;
 import java.awt.event.*;
 import javax.swing.*;
 import javax.swing.event.*;
 import java.io.*;
 import java.net.*;
 
 /** client application window containing menus and top-level panels/panes */
 public class ClientApp extends JFrame implements ActionListener, MenuListener {
   private static final Color BackColor = new Color(255, 192, 128); /**< background color of panels */
   private static final Insets StdInsets = new Insets(10, 10, 10, 10); /**< standard padding around laid out components */
   private static final String SettingsPath = "save/players_old.dat"; /**< file path of player data file */
 
   // menus
   private JMenuBar menuBar; /**< menu bar displayed at top of window */
   private JMenu menuPlayer; /**< menu for player-related menu items */
   private JMenuItem menuSignIn; /**< menu to sign in to existing player */
   private JMenuItem menuNewPlayer; /**< menu to create and sign in to new player */
   private JMenuItem menuChangePassword; /**< menu to show change password panel */
   private JMenuItem menuDeleteAccount; /**< menu to delete player account (requires confirmation) */
   private JMenuItem menuLeaderboard; /**< menu to display leaderboard panel */
   private JMenuItem menuExit; /**< menu to exit program */
   private JMenu menuGame; /**< menu for game-related menu items */
   private JMenuItem menuLobby; /**< menu to show available games or status of upcoming game session */
   private JMenuItem menuContinueGame; /**< menu to continue game that has been started */
   private JMenuItem menuStopGame; /**< menu to end game in its current state */
 
   /** layout of the window, containing the different application panels */
   private CardLayout layout;
   /** name of the current panel or pane being displayed */
   private String currentPanel;
 
   // panels
   private SignInPanel panelSignIn; /**< panel to sign in to (and possibly create new account on) server */
   private TextInputPanel panelChangePassword; /**< panel to change password */
   private TextInputPanel panelDeleteAccount; /**< panel to confirm account deletion */
   private LobbyPanel panelLobby; /**< panel to wait for players to join game */
   private SelectInputPane paneJoinGame; /**< scroll pane to select game to join */
   private PlayerStatsPane panePlayerStats; /**< scroll pane to display player statistics */
   private GamePanel panelGame; /**< panel to play German Whist */
 
   /** connection to server */
   private PlayerSocket socket;
   /** ArrayList describing available game sessions (sent from server) */
   private ArrayList<GameSession> games;
   /** description of game session this client is currently in */
   private GameSession currentGame;
 
   /** constructor for game window */
   public ClientApp(boolean isAIClient) {
     int i, j;
     // set up window
     if (isAIClient) {
       setTitle("German Whist (AI)");
     }
     else {
       setTitle("German Whist");
     }
     setSize(640, 500);
     setLocationRelativeTo(null); // center window on screen
     setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // exit program when window is closed
     addWindowListener(new AppCloseListener());
     // instantiate menus
     menuBar = new JMenuBar();
     menuPlayer = new JMenu("Player");
     menuSignIn = new JMenuItem("Sign In");
     menuNewPlayer = new JMenuItem("New Player");
     menuChangePassword = new JMenuItem("Change Password");
     menuDeleteAccount = new JMenuItem("Delete Account");
     menuLeaderboard = new JMenuItem("Leaderboard");
     menuExit = new JMenuItem("Exit");
     menuGame = new JMenu("Game");
     menuLobby = new JMenuItem("Game Lobby");
     menuContinueGame = new JMenuItem("Continue Game");
     menuStopGame = new JMenuItem("Stop Game");
     // add menus
     menuPlayer.add(menuSignIn);
     menuPlayer.add(menuNewPlayer);
     menuPlayer.addSeparator();
     menuPlayer.add(menuChangePassword);
     menuPlayer.add(menuDeleteAccount);
     menuPlayer.addSeparator();
     menuPlayer.add(menuLeaderboard);
     menuPlayer.addSeparator();
     menuPlayer.add(menuExit);
     menuGame.add(menuLobby);
     menuGame.addSeparator();
     menuGame.add(menuContinueGame);
     menuGame.add(menuStopGame);
     menuBar.add(menuPlayer);
     menuBar.add(menuGame);
     setJMenuBar(menuBar);
     // register menu item listeners
     for (i = 0; i < menuBar.getMenuCount(); i++) {
       menuBar.getMenu(i).addMenuListener(this); // to update whether items are enabled when menu is clicked
       for (j = 0; j < menuBar.getMenu(i).getItemCount(); j++) {
         if (menuBar.getMenu(i).getItem(j) instanceof JMenuItem) { // skip separators
           menuBar.getMenu(i).getItem(j).addActionListener(this);
         }
       }
     }
     // set up card layout
     layout = new CardLayout();
     setLayout(layout);
     // instantiate panels and panes
     panelSignIn = new SignInPanel(this, BackColor, StdInsets);
     panelChangePassword = new TextInputPanel("Enter new password", "Change Password", true, this, BackColor, StdInsets);
     panelDeleteAccount = new TextInputPanel("Enter password to confirm account deletion", "Delete Account", true, this, BackColor, StdInsets);
     panelLobby = new LobbyPanel(this, BackColor, StdInsets);
     paneJoinGame = new SelectInputPane(this, BackColor, StdInsets);
     paneJoinGame.update("Waiting for available games list...", new ArrayList<String>()); // fall back gracefully if pane isn't ready yet
     panePlayerStats = new PlayerStatsPane(BackColor, StdInsets);
     if (isAIClient) {
       panelGame = new GameAIPanel(BackColor);
     }
     else {
       panelGame = new GamePanel(BackColor);
     }
     // add panels
     add(panelSignIn, "sign in");
     add(panelChangePassword, "change password");
     add(panelDeleteAccount, "delete account");
     add(panelLobby, "lobby");
     add(paneJoinGame, "join game");
     add(panePlayerStats, "player stats");
     add(panelGame, "game");
     // start networking timer
     new javax.swing.Timer(ServerApp.UpdateInterval, this).start();
     // show sign in panel
     setVisible(true); // display window
     panelSignIn.initSignIn();
     showPanel("sign in");
   }
 
   public static void main(String[] args) {
     ClientApp app = new ClientApp(false);
   }
 
   /** handle menu or button click */
   public void actionPerformed(ActionEvent ae) {
     Object src = ae.getSource();
     int i;
     // player menu
     if (src == menuSignIn) { // show panel to sign in to server
       panelSignIn.initSignIn();
       showPanel("sign in");
     }
     else if (src == menuNewPlayer) { // show panel to create new player then sign in to that player
       panelSignIn.initNewPlayer();
       showPanel("sign in");
     }
     else if (src == menuChangePassword) { // show panel to change password
       showPanel("change password");
     }
     else if (src == menuDeleteAccount) { // confirm account deletion
       showPanel("delete account");
     }
     else if (src == menuLeaderboard) { // show leaderboard panel
       showPanel("player stats");
     }
     else if (src == menuExit) { // exit program
       // call window closing events of window listeners
       WindowListener[] windowListeners = getWindowListeners();
       for (i = 0; i < windowListeners.length; i++) {
         windowListeners[i].windowClosing(new WindowEvent(this, WindowEvent.WINDOW_CLOSING));
       }
       // exit program
       System.exit(0);
     }
     // game menu
     else if (src == menuLobby) { // show available games or status of upcoming game session
       if (!signedIn()) {
         panelSignIn.initSignIn();
         panelSignIn.setActionMsg("Sign in to enter game lobby");
         showPanel("sign in");
       }
       else if (currentGame != null) {
         showPanel("lobby");
       }
       else if (games != null) {
         showPanel("join game");
       }
     }
     else if (src == menuContinueGame) { // continue game that has been started
       if (!panelGame.getGameOver()) {
         showPanel("game");
       }
     }
     else if (src == menuStopGame) { // end game in its current state
       panelGame.stopGame();
       if (currentPanel.equals("game")) {
         showPanel("join game"); // game panel should not be displayed when a game is not being played
       }
     }
     // sign in panel
     else if (src == panelSignIn) {
       try {
         if (socket != null) {
           // disconnect from existing connection
           socket.close();
           socket = null;
           Thread.sleep(ServerApp.UpdateInterval); // wait for server to receive message
         }
         socket = new PlayerSocket(new Socket(panelSignIn.getServerAddress(), ServerApp.Port));
         Thread.sleep(ServerApp.UpdateInterval); // wait for server to receive message
         socket.write(panelSignIn.getPacket());
       }
       catch (Exception ex) {
         socket = null;
         panelSignIn.setActionError("Could not connect to server; check that it was entered correctly");
       }
     }
     // change password panel
     else if (src == panelChangePassword) {
       String password = ae.getActionCommand();
       if (password.isEmpty()) {
         panelChangePassword.setActionError("Please enter a new password");
       }
       else {
         panelChangePassword.setActionMsg("Changing password...");
         socket.write(new StringMsg(StringMsg.MsgType.ChangePassword, password));
       }
     }
     // delete account panel
     else if (src == panelDeleteAccount) {
       String password = ae.getActionCommand();
       if (password.isEmpty()) {
         panelChangePassword.setActionError("Please enter your password");
       }
       else {
         panelChangePassword.setActionMsg("Deleting account...");
         socket.write(new StringMsg(StringMsg.MsgType.DeleteAccount, password));
       }
     }
     // lobby panel
     else if (src == panelLobby) {
       if (ae.getActionCommand().equals("leave")) {
         socket.write(new GameSessionMsg(new GameSession())); // new GameSession() defaults to playing = false, which is what we want
       }
       else if (ae.getActionCommand().equals("start")) {
         socket.write(new StartGameMsg());
       }
     }
     // join game pane
     else if (src == paneJoinGame) {
       String session = ae.getActionCommand();
       GameSession msg = new GameSession();
       msg.playing = true;
       if (session.equals("Host New Game")) {
         socket.write(new GameSessionMsg(msg));
       }
       else {
         msg.players = games.get(Integer.parseInt(session.substring(0, session.indexOf('.'))) - 1).players;
         socket.write(new GameSessionMsg(msg));
       }
     }
     // networking timer
     else if (src instanceof javax.swing.Timer) {
       pollServer();
     }
     // unhandled
     else {
       System.out.println("TODO: handle actionPerformed of " + src.toString());
     }
   }
 
   /** update whether certain menu items are enabled when menu is clicked */
   public void menuSelected(MenuEvent e) {
     boolean enable;
     if (e.getSource() == menuPlayer) {
       enable = signedIn();
       menuChangePassword.setEnabled(enable);
       menuDeleteAccount.setEnabled(enable);
       menuLeaderboard.setEnabled(enable);
     }
     else if (e.getSource() == menuGame) {
       menuLobby.setEnabled(panelGame.getGameOver());
       menuContinueGame.setEnabled(signedIn() && !panelGame.getGameOver());
       menuStopGame.setEnabled(signedIn() && !panelGame.getGameOver());
     }
   }
 
   public void menuDeselected(MenuEvent e) {
   }
 
   public void menuCanceled(MenuEvent e) {
   }
 
   /** show panel (or pane) of specified name */
   private void showPanel(String panelName) {
     int i, j;
     if (panelName.equals("sign in")) {
       // panel can be shown as is (caller should have initialized it manually)
     }
     else if (panelName.equals("change password")) {
       panelChangePassword.reset();
     }
     else if (panelName.equals("delete account")) {
       panelDeleteAccount.reset();
     }
     else if (panelName.equals("lobby")) {
       // panel automatically synced with server
     }
     else if (panelName.equals("join game")) {
       // pane automatically synced with server
     }
     else if (panelName.equals("player stats")) {
       if (signedIn()) {
         socket.write(new PlayerStatsMsg()); // request updated player stats from server
       }
     }
     else if (panelName.equals("game")) {
       if (panelGame.getGameOver()) {
         throw new IllegalStateException("A game has not been started");
       }
     }
     else {
       throw new IllegalArgumentException("There is no panel or pane called \"" + panelName + "\"");
     }
     layout.show(this.getContentPane(), panelName);
     currentPanel = panelName;
   }
 
   /** check for and handle messages from server */
   private void pollServer() {
     Object msgObj = null;
     int i, j;
     if (socket == null) {
       return;
     }
     do {
       msgObj = socket.read();
       if (msgObj != null) {
         // received a message, handle it
         //System.out.println("Received message from server: " + msgObj);
         if (msgObj instanceof CloseConnectionMsg) {
           // close connection with server
           signOut("Unexpectedly disconnected from server");
           msgObj = null;
         }
         else if (msgObj instanceof PlayerStatsMsg) {
           // update leaderboard
           panePlayerStats.update(((PlayerStatsMsg)msgObj).players);
         }
         else if (msgObj instanceof GameSessionListMsg) {
           // update available game sessions
           ArrayList<String> choices = new ArrayList<String>();
           games = ((GameSessionListMsg)msgObj).toGameSessionList();
           currentGame = null;
           choices.add("Host New Game");
           for (i = 0; i < games.size(); i++) {
             StringBuilder choice = new StringBuilder();
             choice.append(i + 1);
             choice.append(". ");
             for (j = 0; j < games.get(i).players.size(); j++) {
               choice.append(games.get(i).players.get(j));
               if (j < games.get(i).players.size() - 1) {
                 choice.append(", ");
               }
             }
             choices.add(choice.toString());
           }
           paneJoinGame.update("Select game session to join", choices);
           if (currentPanel.equals("lobby") || (currentPanel.equals("game") && !panelGame.getGameOver())) {
             showPanel("join game");
           }
           if (!panelGame.getGameOver()) {
             panelGame.stopGame(); // receiving this message means we are no longer in game session, so stop game now
           }
         }
         else if (msgObj instanceof GameSessionMsg) {
           // update current game session
           currentGame = ((GameSessionMsg)msgObj).toGameSession();
           games = null;
           panelLobby.update(currentGame.players);
           if (currentPanel.equals("join game")) {
             showPanel("lobby");
           }
         }
         else if (msgObj instanceof StartGameMsg) {
           // start game
           StartGameMsg msg = (StartGameMsg)msgObj;
           panelGame.newGame(msg.players.toGameSession().players, msg.seed, socket);
           showPanel("game");
         }
         else if (msgObj instanceof GamePlayMsg) {
           // another player played a card
           if (!panelGame.playTrick(((GamePlayMsg)msgObj).card)) {
             System.out.println("Warning: received message to play an invalid card");
           }
         }
         else if (msgObj instanceof StringMsg) {
           StringMsg msg = (StringMsg)msgObj;
           if (msg.type == StringMsg.MsgType.SignInSuccess) {
             // successfully signed in
             games = null;
             currentGame = null;
             socket.setPlayerName(msg.message);
             showPanel("join game");
           }
           else if (msg.type == StringMsg.MsgType.SignInError) {
             // unsuccessfully signed in, display error message
             socket.setPlayerName(null);
             panelSignIn.setActionError(msg.message);
           }
           else if (msg.type == StringMsg.MsgType.ChangePassword) {
             if (msg.message.isEmpty()) {
               // password successfully changed
               panelChangePassword.setActionMsg("Password successfully changed");
             }
             else {
               // password not changed successfully
               panelChangePassword.setActionError(msg.message);
             }
           }
           else if (msg.type == StringMsg.MsgType.DeleteAccount) {
             if (msg.message.isEmpty()) {
               // account successfully deleted
               signOut("Player account successfully deleted");
               msgObj = null;
             }
             else {
               // account not deleted successfully
               panelDeleteAccount.setActionError(msg.message);
             }
           }
           else {
             System.out.println("Warning: received StringMsg of unknown type " + msg.type.toString());
           }
         }
         else {
           System.out.println("Warning: received unknown message " + msgObj);
         }
       }
     } while (msgObj != null);
   }
 
   /** close connection with server */
   private void signOut(String message) {
     socket.close();
     socket = null;
     panelSignIn.initSignIn();
     panelSignIn.setActionMsg(message);
     showPanel("sign in");
   }
 
   /** returns whether currently signed in to server */
   private boolean signedIn() {
     return (socket != null && socket.getPlayerName() != null);
   }
 
   /** class to handle window close event */
   private class AppCloseListener extends WindowAdapter {
     /** handle window close event */
     public void windowClosing(WindowEvent e) {
       if (socket != null) {
         socket.close();
         socket = null;
       }
     }
   }
 }
