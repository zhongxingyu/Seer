 /*
  * first generated by Xtext
  */
 package jp.hishidama.xtext.dmdl_editor.ui.outline;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 import jp.hishidama.xtext.dmdl_editor.dmdl.Attribute;
 import jp.hishidama.xtext.dmdl_editor.dmdl.AttributeList;
 import jp.hishidama.xtext.dmdl_editor.dmdl.DmdlPackage;
 import jp.hishidama.xtext.dmdl_editor.dmdl.Grouping;
 import jp.hishidama.xtext.dmdl_editor.dmdl.JoinExpression;
 import jp.hishidama.xtext.dmdl_editor.dmdl.JoinTerm;
 import jp.hishidama.xtext.dmdl_editor.dmdl.ModelDefinition;
 import jp.hishidama.xtext.dmdl_editor.dmdl.ModelFolding;
 import jp.hishidama.xtext.dmdl_editor.dmdl.ModelMapping;
 import jp.hishidama.xtext.dmdl_editor.dmdl.ModelReference;
 import jp.hishidama.xtext.dmdl_editor.dmdl.ModelUtil;
 import jp.hishidama.xtext.dmdl_editor.dmdl.Property;
 import jp.hishidama.xtext.dmdl_editor.dmdl.PropertyDefinition;
 import jp.hishidama.xtext.dmdl_editor.dmdl.PropertyFolding;
 import jp.hishidama.xtext.dmdl_editor.dmdl.PropertyMapping;
 import jp.hishidama.xtext.dmdl_editor.dmdl.PropertyUtil;
 import jp.hishidama.xtext.dmdl_editor.dmdl.RecordExpression;
 import jp.hishidama.xtext.dmdl_editor.dmdl.RecordTerm;
 import jp.hishidama.xtext.dmdl_editor.dmdl.SummarizeExpression;
 import jp.hishidama.xtext.dmdl_editor.dmdl.SummarizeTerm;
 import jp.hishidama.xtext.dmdl_editor.dmdl.Type;
 import jp.hishidama.xtext.dmdl_editor.ui.labeling.DMDLImages;
 
 import org.eclipse.emf.common.util.EList;
 import org.eclipse.emf.ecore.EObject;
 import org.eclipse.emf.ecore.EStructuralFeature;
 import org.eclipse.jface.viewers.StyledString;
 import org.eclipse.swt.graphics.Image;
 import org.eclipse.xtext.nodemodel.INode;
 import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
 import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
 import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
 import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;
 import org.eclipse.xtext.ui.editor.outline.impl.EStructuralFeatureNode;
 import org.eclipse.xtext.util.TextRegion;
 
 /**
  * Customization of the default outline structure.
  * 
  * see http://www.eclipse.org/Xtext/documentation.html#outline
  */
 public class DMDLOutlineTreeProvider extends DefaultOutlineTreeProvider {
 
 	@Override
 	protected void _createChildren(DocumentRootNode parentNode, EObject modelElement) {
 		for (EObject childElement : modelElement.eContents()) {
 			createNode(parentNode, childElement);
 		}
 	}
 
 	protected void _createChildren(IOutlineNode parentNode, ModelDefinition model) {
 		if (model == null) {
 			return;
 		}
 		AttributeList attributes = model.getAttributes();
 		if (attributes != null) {
 			createNode(parentNode, attributes);
 			// for (Attribute attr : attributes.getAttributes()) {
 			// createNode(parentNode, attr);
 			// }
 		}
 
 		EObject rhs = model.getRhs();
 		if (rhs instanceof RecordExpression) {
 			createRecordModelChildren(parentNode, (RecordExpression) rhs);
 			return;
 		}
 		if (rhs instanceof JoinExpression) {
 			createJoinModelChildren(parentNode, (JoinExpression) rhs);
 			return;
 		}
 		if (rhs instanceof SummarizeExpression) {
 			createSummarizeModelChildren(parentNode, (SummarizeExpression) rhs);
 			return;
 		}
 
 		if (rhs != null) {
 			throw new IllegalStateException("rhs=" + rhs);
 		}
 	}
 
 	private void createRecordModelChildren(IOutlineNode parentNode, RecordExpression rhs) {
 		EList<RecordTerm> terms = rhs.getTerms();
 		for (RecordTerm term : terms) {
 			ModelReference ref = term.getReference();
 			if (ref != null) {
 				if (!ModelUtil.recursiveModel(term.eContainer(), ref.getName())) {
 					createNode(parentNode, ref);
 				}
 			} else {
 				EList<PropertyDefinition> properties = term.getProperties();
 				for (PropertyDefinition p : properties) {
 					createNode(parentNode, p);
 				}
 			}
 		}
 	}
 
 	private void createJoinModelChildren(IOutlineNode parentNode, JoinExpression rhs) {
 		EList<JoinTerm> terms = rhs.getTerms();
 		Set<String> set = new HashSet<String>();
 		List<EObject> list = new ArrayList<EObject>();
 		List<Grouping> glist = new ArrayList<Grouping>();
 		for (JoinTerm term : terms) {
 			ModelMapping mapping = term.getMapping();
 			if (mapping != null) {
 				EList<PropertyMapping> properties = mapping.getMappings();
 				for (PropertyMapping p : properties) {
 					String key = p.getName();
 					if (!set.contains(key)) {
 						set.add(key);
 						list.add(p);
 					}
 				}
 			} else {
 				ModelReference ref = term.getReference();
 				if (ref != null) {
 					if (!ModelUtil.recursiveModel(term.eContainer(), ref.getName())) {
 						list.add(ref);
 					}
 				}
 			}
 			Grouping group = term.getGrouping();
 			if (group != null) {
 				glist.add(group);
 			}
 		}
 		for (EObject p : list) {
 			createNode(parentNode, p);
 		}
 		for (Grouping g : glist) {
 			createNode(parentNode, g);
 		}
 	}
 
 	private void createSummarizeModelChildren(IOutlineNode parentNode, SummarizeExpression rhs) {
 		EList<SummarizeTerm> terms = rhs.getTerms();
 		for (SummarizeTerm term : terms) {
 			ModelFolding folding = term.getFolding();
 			if (folding != null) {
 				EList<PropertyFolding> properties = folding.getFoldings();
 				for (PropertyFolding p : properties) {
 					createNode(parentNode, p);
 				}
 			}
 			Grouping group = term.getGrouping();
 			if (group != null) {
 				createNode(parentNode, group);
 			}
 		}
 	}
 
 	protected void _createChildren(IOutlineNode parentNode, ModelReference ref) {
 		_createChildren(parentNode, ref.getName());
 	}
 
 	protected void _createChildren(IOutlineNode parentNode, Grouping group) {
 		EStructuralFeature feature = DmdlPackage.Literals.GROUPING__NAME;
 		Image image = DMDLImages.getPropertyImage();
 
 		List<INode> list = NodeModelUtils.findNodesForFeature(group, feature);
 		for (INode node : list) {
			EStructuralFeatureNode snode = createEStructuralFeatureNode(parentNode, group, feature, image,
					node.getText(), true);
 			TextRegion region = new TextRegion(node.getOffset(), node.getLength());
 			snode.setTextRegion(region);
 		}
 	}
 
 	/*
 	 * isLeaf
 	 */
 
 	protected boolean _isLeaf(Attribute modelElement) {
 		return true;
 	}
 
 	protected boolean _isLeaf(ModelReference modelElement) {
 		return false;
 	}
 
 	protected boolean _isLeaf(Grouping modelElement) {
 		return false;
 	}
 
 	/*
 	 * text
 	 */
 
 	protected Object _text(ModelReference ref) {
 		return _text(ref.getName());
 	}
 
 	protected Object _text(Property p) {
 		String name = p.getName();
 		Type type = PropertyUtil.getResolvedDataType(p);
 		if (type != null) {
 			StyledString ss = newStyledString(name);
 			ss.append(" : " + type, StyledString.DECORATIONS_STYLER);
 			return ss;
 		}
 		return name;
 	}
 
 	private StyledString newStyledString(String text) {
 		return new StyledString((text != null) ? text : "<undifined>");
 	}
 }
