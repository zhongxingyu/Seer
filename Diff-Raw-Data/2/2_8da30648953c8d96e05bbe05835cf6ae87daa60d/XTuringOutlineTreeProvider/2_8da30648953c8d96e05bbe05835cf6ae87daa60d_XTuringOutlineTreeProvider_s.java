 /*
 * generated by Xtext
 */
 package it.marcotinacci.xturing.ui.outline;
 
 import it.marcotinacci.xturing.xTuring.Machine;
 import it.marcotinacci.xturing.xTuring.ReadWriteSymbol;
 import it.marcotinacci.xturing.xTuring.State;
 import it.marcotinacci.xturing.xTuring.Symbol;
 import it.marcotinacci.xturing.xTuring.Transaction;
 import it.marcotinacci.xturing.xTuring.XTuringPackage;
 
 import org.eclipse.xtext.ui.IImageHelper;
 import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
 import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
 import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;
 import org.eclipse.xtext.ui.editor.outline.impl.EObjectNode;
 
 import com.google.inject.Inject;
 
 /**
  * customization of the default outline structure
  * 
  */
 public class XTuringOutlineTreeProvider extends DefaultOutlineTreeProvider {
 
 	@Inject
 	private IImageHelper imageHelper;
 	
 	protected void _createChildren(DocumentRootNode parentNode, Machine machine) {
 		// symbols section
 		createEStructuralFeatureNode(
 				parentNode, 
 				machine, 
 				XTuringPackage.Literals.MACHINE__SYMBOLS, 
 				null,
 				"Alphabet", 
 				false
 			);
 		
 		// states section
 		createEStructuralFeatureNode(
 				parentNode, 
 				machine, 
 				XTuringPackage.Literals.MACHINE__STATES, 
 				null,
 				"States", 
 				false
 			);
 	}
 	
 	protected void _createNode(IOutlineNode parentNode, State state){
 		EObjectNode node1 = createEObjectNode(parentNode, state, 
 				state.isBeginState() ? imageHelper.getImage("begin_state.gif") : imageHelper.getImage("state.gif"),
 				state.getName(), false);
 		// i: transaction counter
 		int i = 1;
 		// for each transaction of the state
 		for (Transaction transaction : state.getTransactions()) {
 			// create a node for the transaction
 			EObjectNode node2 = createEObjectNode(node1, transaction, null, "transaction "+i, false);
 			
 			if(transaction.isReading()){
 				// for each symbol read
 				for (ReadWriteSymbol sym : transaction.getRead()) {
 					// create a node for the readed symbol
 					createEObjectNode(node2, sym, null, 
 							"read "+(sym.getSymbol()==null ? '~' : sym.getSymbol().getName()), true);					
 				}
 			}else{
 				createEObjectNode(node2, transaction, null, "read *", true);
 			}
 			
 			if(transaction.isWriting()){
 				// for each symbol write
 				for (ReadWriteSymbol sym : transaction.getWrite()) {
 					// create a node for the writed symbol
 					createEObjectNode(node2, sym, null, 
 							"write "+(sym.getSymbol()==null ? '~' : sym.getSymbol().getName()), true);					
 				}
 			}else{
 				createEObjectNode(node2, transaction, null, "do not write", true);
 			}
 			
 			if(transaction.isMoving()){
 				createEObjectNode(node2, transaction, null, 
 						"move "+(transaction.getMove().equals("LEFT") ? "left" : "right"), true);
 			}else{
 				createEObjectNode(node2, transaction, null, "do not move", true);
 			}
 			
 			if(transaction.isNext()){
 				createEObjectNode(node2, transaction.getToState(), null, "next state: "+transaction.getToState().getName(), true);
 				
 			}else if(transaction.isFinal()){
				createEObjectNode(node2, transaction.getToState(), null, "terminate", true);
 			}else{
 				createEObjectNode(node2, state, null, "next state: "+state.getName(), true);
 			}
 			
 			i++;
 		}
 	}
 	
 	protected boolean _isLeaf(Symbol symbol) {
 	    return true;
 	}
 	protected boolean _isLeaf(State state) {
 	    return false;
 	}
 }
