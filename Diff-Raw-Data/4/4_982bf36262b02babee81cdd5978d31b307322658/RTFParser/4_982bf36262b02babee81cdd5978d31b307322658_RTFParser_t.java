 /* Generated By:JavaCC: Do not edit this line. RTFParser.java */
 package com.etranslate.tm.processing.rtf;
 
 import java.io.*;
 import java.util.*;
 
 public class RTFParser implements RTFParserDelegate, RTFParserConstants {
 
   /**
    * This value will be passed to Delegate if there was no value specified with the CONTROL_WORD.
    * This is to allow Delegate to be able to differentiate between commands like \b and \b0.
    */
   public static final int VALUE_NOT_SPECIFIED = Integer.MIN_VALUE + 12;
 
   /* maps windows character sets to java encoding names */
   /* note: sparse array */
   private static final String[] CHARSET_ENCODING_TABLE = new String[257];
   static {
         CHARSET_ENCODING_TABLE[0] = "Cp1252";     // ANSI
         CHARSET_ENCODING_TABLE[1] = "Cp1252";     // Default
         CHARSET_ENCODING_TABLE[2] = "Cp1252";     // Symbol
         CHARSET_ENCODING_TABLE[3] = null;         // Invalid
         CHARSET_ENCODING_TABLE[77] = "MacRoman";  // Mac
         CHARSET_ENCODING_TABLE[128] = "MS932";    // Shift JIS
         CHARSET_ENCODING_TABLE[129] = "MS949";    // Hangul
         CHARSET_ENCODING_TABLE[130] = "Johab";    // Johab
         CHARSET_ENCODING_TABLE[134] = "MS936";    // GB2312
         CHARSET_ENCODING_TABLE[136] = "MS950";    // Big5
         CHARSET_ENCODING_TABLE[161] = "Cp1253";   // Greek
         CHARSET_ENCODING_TABLE[162] = "Cp1254";   // Turkish
         CHARSET_ENCODING_TABLE[163] = "Cp1258";   // Vietnamese
         CHARSET_ENCODING_TABLE[177] = "Cp1255";   // Hebrew
         CHARSET_ENCODING_TABLE[178] = "Cp1256";   // Arabic
         CHARSET_ENCODING_TABLE[179] = "Cp1256";   // Arabic Traditional
         CHARSET_ENCODING_TABLE[180] = "Cp1256";   // Arabic User
         CHARSET_ENCODING_TABLE[181] = "Cp1255";   // Hebrew User
         CHARSET_ENCODING_TABLE[186] = "Cp1257";   // Baltic
         CHARSET_ENCODING_TABLE[204] = "Cp1251";   // Russian
         CHARSET_ENCODING_TABLE[222] = "MS874";    // Thai
         CHARSET_ENCODING_TABLE[238] = "Cp1250";   // East European
         CHARSET_ENCODING_TABLE[254] = "Cp437";    // PC 437
         CHARSET_ENCODING_TABLE[255] = "Cp437";    // OEM, still 437
         CHARSET_ENCODING_TABLE[256] = "Cp1252";    // Custom charset?? Default to the ANSI value
   }
 
   /*
    * These next two tables map windows codepages to java encoding names.
    * The codepage ints are too large to do a sparse array, so we have
    * two parallel arrays and do a binary search to find the common offset.
    */
 
   private static final int[] RTF_CODEPAGE = {
         437, // United States IBM 
 
         /*  Not supported by JDK 1.3.1
         708, // Arabic (ASMO 708) 
         709, // Arabic (ASMO 449+, BCON V4) 
         710, // Arabic (transparent Arabic) 
         711, // Arabic (Nafitha Enhanced) 
         720, // Arabic (transparent ASMO) 
         */
 
         819, // Windows 3.1 (United States and Western Europe) 
         850, // IBM multilingual 
         852, // Eastern European 
         860, // Portuguese 
         862, // Hebrew 
         863, // French Canadian 
         864, // Arabic 
         865, // Norwegian 
         866, // Soviet Union 
         874, // Thai 
         932, // Japanese 
         936, // Simplified Chinese 
         949, // Korean 
         950, // Traditional Chinese 
         1250, // Windows 3.1 (Eastern European) 
         1251, // Windows 3.1 (Cyrillic) 
         1252, // Western European 
         1253, // Greek 
         1254, // Turkish 
         1255, // Hebrew 
         1256, // Arabic 
         1257, // Baltic 
         1258, // Vietnamese 
         1361, // Johab
 
         10000, // Mac Roman
         10004, // Mac Arabic
         10005, // Mac Hebrew
         10006, // Mac Greek
         10007, // Mac Russian
         10021, // Mac Thai
         10081, // Mac Turkish
 
         20127, // US-ASCII (7-bit only, i.e. no values above 127)
 
         65001 // UTF-8
   };
 
   private static final String[] JAVA_ENCODINGS = {
         "Cp437", // United States IBM 
         /*  Not supported by JDK 1.3.1
         "Cp708", // Arabic (ASMO 708) 
         "Cp709", // Arabic (ASMO 449+, BCON V4) 
         "Cp710", // Arabic (transparent Arabic) 
         "Cp711", // Arabic (Nafitha Enhanced) 
         "Cp720", // Arabic (transparent ASMO) 
         */
         "Cp819", // Windows 3.1 (United States and Western Europe) 
         "Cp850", // IBM multilingual 
         "Cp852", // Eastern European 
         "Cp860", // Portuguese 
         "Cp862", // Hebrew 
         "Cp863", // French Canadian 
         "Cp864", // Arabic 
         "Cp865", // Norwegian 
         "Cp866", // Soviet Union 
         "MS874", // Thai 
         "MS932", // Japanese 
         "MS936", // Simplified Chinese 
         "MS949", // Korean 
         "MS950", // Traditional Chinese 
         "Cp1250", // Windows 3.1 (Eastern European) 
         "Cp1251", // Windows 3.1 (Cyrillic) 
         "Cp1252", // Western European 
         "Cp1253", // Greek 
         "Cp1254", // Turkish 
         "Cp1255", // Hebrew 
         "Cp1256", // Arabic 
         "Cp1257", // Baltic 
         "Cp1258", // Vietnamese 
         "Johab",  // Johab
 
         "MacRoman", // Mac Roman
         "MacArabic", // Mac Arabic
         "MacHebrew", // Mac Hebrew
         "MacGreek", // Mac Greek
         "MacCyrillic", // Mac Russian??
         "MacThai", // Mac Thai
         "MacTurkish", // Mac Turkish
 
         "US-ASCII", // US-ASCII (7-bit only, i.e. no values above 127)
 
         "UTF-8"
   };
 
   /**
    * Searches RTF_CODEPAGE table for the offset of rtfCodepage and returns
    * the corresponding encoding name from the JAVA_ENCODINGS table, or
    * null if none is present.
    */
   private static final String getJavaEncoding(int rtfCodepage) {
     int offset = Arrays.binarySearch(RTF_CODEPAGE, rtfCodepage);
     return offset < 0 ? null : JAVA_ENCODINGS[offset];
   }
 
   /* support for skipping bytes after a unicode character.
    * TODO: handle \bin
    */
   // the default number of bytes to skip after a unicode character
   private static final Integer DEFAULT_SKIP_STATE = new Integer(1);
   // the current number of bytes to skip after a unicode character
   private Integer _currentSkipState = DEFAULT_SKIP_STATE;
   // a stack of skip states for bytes following a unicode character
   private final Stack _ucSkipStates = new Stack();
 
   // the default encoding for all RTF documents
   private static final String DEFAULT_ENCODING = "Cp1252";
   // the document encoding for this RTF document
   private String _documentEncoding = DEFAULT_ENCODING;
 
   /* support for parsing the \fonttbl to discover font codes and
    * their assigned encodings
    */
   // this holds the (\deffN) default font number
   private int _defaultFont = 0;
   // this holds the font table key (\fN) while we're waiting for the
   // font name (text) declaration in the font table.
   private int _currentFontValue = 0;
   // this holds the font table charset (\fcharsetN) while we're waiting for the
   // font name (text) declaration in the font table.
   private int _currentCharsetValue = 0;
   // this maps font codes (\fN) to the encodings assigned (\fcharsetN)
   // in the fonttbl
   private final Map _fontEncodingMap = new HashMap();
 
   /** support for encoding changes via references to the font table */
   // the current text encoding
   private String _currentEncoding = DEFAULT_ENCODING;
   // a stack of text encodings across groups
   private final Stack _fontEncodingStack = new Stack();
 
   private int _currentStyleValue = 0;
   private final Map _styleMap = new HashMap();
   private final Stack _styleStack = new Stack();
   private String _currentStyle = NO_STYLE;
 
   private int _where = IN_DOCUMENT;
   private int _rtfDepth = 1;
 
   private int _braceDepth = 0;
   private String _newline = "\n";
 
   // The delegate to which the parser forwards productions.
   // Unless setDelegate is called, this will be the parser
   // itself, which supplies a no-op implementation (see below).
   // this enables us to avoid doing null checks in the delegate
   // calls.
 
   private RTFParserDelegate _delegate = this;
 
   public static void main(String args[]) throws ParseException {
     RTFParser parser = RTFParser.createParser(new InputStreamReader(System.in));
     parser.parse();
   }
 
   public void reinitialize(Reader reader) {
     ReInit(reader);
   }
 
   public static RTFParser createParser(Reader reader) {
     return new RTFParser(reader);
   }
 
   public void parse() throws ParseException {
     try {
       document();
     } catch (UnsupportedEncodingException uee) {
       throw new ParseException("Could not decode bytes in encoding: " +
                                uee.getMessage(), uee);
     }
   }
 
   public void setDelegate(RTFParserDelegate delegate) {
     _delegate = delegate;
   }
 
   public String getNewLine() {
     return _newline;
   }
 
   public void setNewLine(String newline) {
     _newline = newline;
   }
 
   /**
    * Returns a numbered font which supports the encoding.
    * This data is gleaned from the RTF fonttbl, and so
    * is not available until after the fonttbl has been
    * parsed.  No guarantees are made about which font
    * will be returned if multiple fonts support the
    * encoding.
    *
    * @return a font control word value.
    */
   public int getFontForEncoding(String encoding) {
     for (Iterator i = _fontEncodingMap.entrySet().iterator(); i.hasNext();) {
         Map.Entry entry = (Map.Entry)i.next();
         if (entry.getValue().equals(encoding)) {
            return ((Integer)entry.getKey()).intValue();
         }
     }
     return -1;
   }
 
   // no-op implementation of RTFParserDelegate interface, for cases
   // when delegate is not set.
   public void text(String text, String style, int context) {}
 
   public OutputStream getNextOutputStream(int context) {return null;}
 
   public void controlSymbol(String controlSymbol, int context) {}
 
   public void controlWord(String controlWord, long value, int context) {}
 
   public void openGroup(int depth) {}
 
   public void closeGroup(int depth) {}
 
   public void styleList(List styles) {}
 
   public void startDocument() {}
 
   public void endDocument() {}
 
 
   protected String getEncodingForCharsetAndFontName(int charset, String fontName) {
     if (charset >= CHARSET_ENCODING_TABLE.length) {
         String encoding = getJavaEncoding(charset);
         if (encoding == null) {
             return "Cp" + charset;
         }
         else {
             return encoding;
         }
     }
     else {
             return CHARSET_ENCODING_TABLE[charset];
         }
   }
 
   public void setCurrentEncoding(String encoding) {
     if (null == encoding) {
        throw new IllegalArgumentException("current encoding cannot be null");
     }
     _currentEncoding = encoding;
   }
 
   public String getCurrentEncoding() {
     if (_where == IN_DOCUMENT) {
       return _currentEncoding;
     } else {
       return _documentEncoding;
     }
   }
 
   private String getCurrentStyle() {
     return _currentStyle;
   }
 
   private void setCurrentStyle(String style) {
     _currentStyle = style;
   }
 
   private Integer getCurrentSkipState() {
     return _currentSkipState;
   }
 
   private void setCurrentSkipState(Integer skipState) {
     _currentSkipState = skipState;
   }
 
   private void setDocumentEncoding(String encoding) {
     if (null == encoding) {
        throw new IllegalArgumentException("document encoding cannot be null");
     }
     _documentEncoding = encoding;
   }
 
   public String getDocumentEncoding() {
     return _documentEncoding;
   }
 
   /**
    * convenience method which downcasts the chars in str to a byte
    * array without attempting to decode them.
    */
   private byte[] stringToBytes(String str) {
     char[] cbuf = str.toCharArray();
     byte[] buf = new byte[cbuf.length];
     for (int i = 0; i < cbuf.length; i++) {
       buf[i] = (byte)cbuf[i];
     }
     return buf;
   }
 
 // end of CONTROL lexical specification
 
 /**************************************/
 /* grammatical productions begin here */
 /**************************************/
 
 /**
  *  Sends the parser delegate a block of unicode text along with
  *  the name of the style in which it was found and the location
  *  in the document where it occurred.
  *  All text encoding is resolved here so the delegate doesn't need
  *  to concern itself with the various ways in which RTF encodes
  *  non-ASCII strings.
  */
   final public void text() throws ParseException, UnsupportedEncodingException {
   StringBuilder buf = new StringBuilder();
   StringBuilder cbuf = new StringBuilder();
   ByteArrayOutputStream baos = new ByteArrayOutputStream();
   byte b;
   byte[] raw;
     label_1:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case NON_BREAKING_SPACE:
       case OPTIONAL_HYPHEN:
       case NON_BREAKING_HYPHEN:
       case ESCAPED_LBRACE:
       case ESCAPED_RBRACE:
       case ESCAPED_BACKSLASH:
       case U:
       case TAB:
       case ZWJ:
       case ZWNJ:
       case EMDASH:
       case ENDASH:
       case EMSPACE:
       case ENSPACE:
       case QMSPACE:
       case BULLET:
       case LQUOTE:
       case RQUOTE:
       case LTRMARK:
       case RTLMARK:
       case LDBLQUOTE:
       case RDBLQUOTE:
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case U:
           u(cbuf);
           raw = skip_after_unicode();
         if (raw != null) {
           cbuf.append(new String(raw, getCurrentEncoding()));
         }
           break;
         case ESCAPED_LBRACE:
         case ESCAPED_RBRACE:
         case ESCAPED_BACKSLASH:
           escaped(cbuf);
           break;
         case TAB:
         case ZWJ:
         case ZWNJ:
         case EMDASH:
         case ENDASH:
         case EMSPACE:
         case ENSPACE:
         case QMSPACE:
         case BULLET:
         case LQUOTE:
         case RQUOTE:
         case LTRMARK:
         case RTLMARK:
         case LDBLQUOTE:
         case RDBLQUOTE:
           special_character(cbuf);
           break;
         case NON_BREAKING_SPACE:
         case OPTIONAL_HYPHEN:
         case NON_BREAKING_HYPHEN:
           textual_control_symbol(cbuf);
           break;
         default:
           jj_la1[0] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
       if (baos.size() > 0) {
         buf.append(baos.toString(getCurrentEncoding()));
         baos.reset();
       }
       buf.append(cbuf.toString());
       cbuf.setLength(0);
         break;
       case HEX_CHAR:
         b = hex();
                        baos.write(b);
         break;
       case TEXT:
       case TEXT_CONTROL_DELIMITER:
         raw = raw_text();
                        baos.write(raw,0,raw.length);
         break;
       default:
         jj_la1[1] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case NON_BREAKING_SPACE:
       case OPTIONAL_HYPHEN:
       case NON_BREAKING_HYPHEN:
       case ESCAPED_LBRACE:
       case ESCAPED_RBRACE:
       case ESCAPED_BACKSLASH:
       case TEXT:
       case HEX_CHAR:
       case U:
       case TAB:
       case ZWJ:
       case ZWNJ:
       case EMDASH:
       case ENDASH:
       case EMSPACE:
       case ENSPACE:
       case QMSPACE:
       case BULLET:
       case LQUOTE:
       case RQUOTE:
       case LTRMARK:
       case RTLMARK:
       case LDBLQUOTE:
       case RDBLQUOTE:
       case TEXT_CONTROL_DELIMITER:
         ;
         break;
       default:
         jj_la1[2] = jj_gen;
         break label_1;
       }
     }
     if (baos.size() > 0) {
       buf.append(baos.toString(getCurrentEncoding()));
       baos.reset();
     }
     if (_where == IN_STYLESHEET) {
       _styleMap.put(new Integer(_currentStyleValue), buf.toString());
     } else if (_where == IN_FONTTBL) {
       String encoding = getEncodingForCharsetAndFontName(_currentCharsetValue, buf.toString());
       _fontEncodingMap.put(new Integer(_currentFontValue), encoding);
     }
     _delegate.text(buf.toString(), getCurrentStyle(), _where);
   }
 
   final public byte[] raw_text() throws ParseException, UnsupportedEncodingException {
   Token tok;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case TEXT:
       tok = jj_consume_token(TEXT);
       break;
     case TEXT_CONTROL_DELIMITER:
       tok = jj_consume_token(TEXT_CONTROL_DELIMITER);
       break;
     default:
       jj_la1[3] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
     {if (true) return stringToBytes(tok.image);}
     throw new Error("Missing return statement in function");
   }
 
   final public void escaped(StringBuilder buf) throws ParseException {
   Token tok;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case ESCAPED_BACKSLASH:
       tok = jj_consume_token(ESCAPED_BACKSLASH);
       break;
     case ESCAPED_LBRACE:
       tok = jj_consume_token(ESCAPED_LBRACE);
       break;
     case ESCAPED_RBRACE:
       tok = jj_consume_token(ESCAPED_RBRACE);
       break;
     default:
       jj_la1[4] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
     buf.append(tok.image.charAt(0));
   }
 
   final public void textual_control_symbol(StringBuilder buf) throws ParseException {
   Token tok;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case NON_BREAKING_SPACE:
       tok = jj_consume_token(NON_BREAKING_SPACE);
       break;
     case OPTIONAL_HYPHEN:
       tok = jj_consume_token(OPTIONAL_HYPHEN);
       break;
     case NON_BREAKING_HYPHEN:
       tok = jj_consume_token(NON_BREAKING_HYPHEN);
       break;
     default:
       jj_la1[5] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
     buf.append(tok.image);
   }
 
   final public byte hex() throws ParseException {
   Token hex;
     hex = jj_consume_token(HEX_CHAR);
     byte b = (byte)Integer.parseInt(hex.image.substring(2), 16);
     {if (true) return b;}
     throw new Error("Missing return statement in function");
   }
 
   final public void special_character(StringBuilder buf) throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case TAB:
       jj_consume_token(TAB);
                      buf.append('\t');
       break;
     case EMDASH:
       jj_consume_token(EMDASH);
                      buf.append('\u2014');
       break;
     case ENDASH:
       jj_consume_token(ENDASH);
                      buf.append('\u2013');
       break;
     case EMSPACE:
       jj_consume_token(EMSPACE);
                      buf.append('\u2003');
       break;
     case ENSPACE:
       jj_consume_token(ENSPACE);
                      buf.append('\u2002');
       break;
     case QMSPACE:
       jj_consume_token(QMSPACE);
                      buf.append('\u2005');
       break;
     case BULLET:
       jj_consume_token(BULLET);
                      buf.append('\u2022');
       break;
     case LQUOTE:
       jj_consume_token(LQUOTE);
                      buf.append('\u2018');
       break;
     case RQUOTE:
       jj_consume_token(RQUOTE);
                      buf.append('\u2019');
       break;
     case LDBLQUOTE:
       jj_consume_token(LDBLQUOTE);
                      buf.append('\u201c');
       break;
     case RDBLQUOTE:
       jj_consume_token(RDBLQUOTE);
                      buf.append('\u201d');
       break;
     case LTRMARK:
       jj_consume_token(LTRMARK);
                      buf.append('\u200e');
       break;
     case RTLMARK:
       jj_consume_token(RTLMARK);
                      buf.append('\u200f');
       break;
     case ZWJ:
       jj_consume_token(ZWJ);
                      buf.append('\u200d');
       break;
     case ZWNJ:
       jj_consume_token(ZWNJ);
                      buf.append('\u200c');
       break;
     default:
       jj_la1[6] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
   }
 
   final public void line_breaks() throws ParseException {
   Token word = null;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case PAR:
       word = jj_consume_token(PAR);
       break;
     case LINE:
       word = jj_consume_token(LINE);
       break;
     case ESCAPED_NEWLINE:
       word = jj_consume_token(ESCAPED_NEWLINE);
       break;
     case ESCAPED_CARRIAGE_RETURN:
       word = jj_consume_token(ESCAPED_CARRIAGE_RETURN);
       break;
     default:
       jj_la1[7] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
     _delegate.text(getNewLine(), getCurrentStyle(), _where);
     _delegate.controlWord(word.image, VALUE_NOT_SPECIFIED, _where);
   }
 
   final public void lbrace() throws ParseException {
     jj_consume_token(LBRACE);
     _fontEncodingStack.push(getCurrentEncoding());
     _ucSkipStates.push(getCurrentSkipState());
     _styleStack.push(getCurrentStyle());
     _delegate.openGroup(++_braceDepth);
   }
 
   final public void rbrace() throws ParseException {
     jj_consume_token(RBRACE);
     setCurrentSkipState((Integer)_ucSkipStates.pop());
     setCurrentEncoding((String)_fontEncodingStack.pop());
     setCurrentStyle((String)_styleStack.pop());
     _delegate.closeGroup(_braceDepth);

     if (_rtfDepth == --_braceDepth) { // leaving a table
       if (_where == IN_STYLESHEET) {
         _delegate.styleList(new ArrayList(_styleMap.values()));
       }
       _where = IN_DOCUMENT;
    } else if (_where == IN_PNTEXT) {
      _where = IN_DOCUMENT;
     }
   }
 
   final public void table_declaration() throws ParseException {
   Token word = null, val = null;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case INFO:
       word = jj_consume_token(INFO);
                                         _where = IN_INFO;
       break;
     case FONTTBL:
       word = jj_consume_token(FONTTBL);
                                         _where = IN_FONTTBL;
       break;
     case COLORTBL:
       word = jj_consume_token(COLORTBL);
                                         _where = IN_COLORTBL;
       break;
     case STYLESHEET:
       word = jj_consume_token(STYLESHEET);
                                         _where = IN_STYLESHEET;
       break;
     case LISTTABLE:
       word = jj_consume_token(LISTTABLE);
                                         _where = IN_LISTTABLE;
       break;
     case REVTBL:
       word = jj_consume_token(REVTBL);
                                         _where = IN_REVTBL;
       break;
     case PNTEXT:
       word = jj_consume_token(PNTEXT);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case CW_VAL:
         val = jj_consume_token(CW_VAL);
         break;
       default:
         jj_la1[8] = jj_gen;
         ;
       }
                                               _where = IN_PNTEXT;
       break;
     case PNSECLVL:
       word = jj_consume_token(PNSECLVL);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case CW_VAL:
         val = jj_consume_token(CW_VAL);
         break;
       default:
         jj_la1[9] = jj_gen;
         ;
       }
                                               _where = IN_PNTEXT;
       break;
     default:
       jj_la1[10] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
     int v = null == val ? VALUE_NOT_SPECIFIED : Integer.parseInt(val.image);
     _delegate.controlWord(word.image, v, _where);
   }
 
   final public void control_symbol() throws ParseException {
   Token sym = null;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case CONTROL_SYM:
       sym = jj_consume_token(CONTROL_SYM);
       break;
     case FORMULA_CHARACTER:
       sym = jj_consume_token(FORMULA_CHARACTER);
       break;
     case INDEX_SUBENTRY:
       sym = jj_consume_token(INDEX_SUBENTRY);
       break;
     default:
       jj_la1[11] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
     _delegate.controlSymbol(sym.image, _where);
   }
 
   final public void control_word() throws ParseException {
   Token word = null, val = null;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case IGNORABLE_DESTINATION:
       word = jj_consume_token(IGNORABLE_DESTINATION);
       break;
     case CONTROL_WORD:
       word = jj_consume_token(CONTROL_WORD);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case CW_VAL:
         val = jj_consume_token(CW_VAL);
         break;
       default:
         jj_la1[12] = jj_gen;
         ;
       }
       break;
     default:
       jj_la1[13] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
     long v = null == val ? VALUE_NOT_SPECIFIED : Long.parseLong(val.image);
     _delegate.controlWord(word.image, v, _where);
   }
 
   final public void u(StringBuilder buf) throws ParseException {
   Token val;
     jj_consume_token(U);
     val = jj_consume_token(CW_VAL);
     int ucValue = Integer.parseInt(val.image);
     // correct RTF negative unicode char value
     if (ucValue < 0) {
       ucValue += 65536;
     }
     buf.append((char)ucValue);
   }
 
   byte[] skip_after_unicode() throws ParseException, UnsupportedEncodingException {
   Token tok;
   byte[] raw = null;
 
   for (int skip = getCurrentSkipState().intValue(); skip != 0; skip--) {
     tok = getNextToken();
     switch (tok.kind) {
     case HEX_CHAR:
       break; // buh bye!
     case TEXT:
     case TEXT_CONTROL_DELIMITER:
       if (tok.image.length() > skip) {
          byte[] tmp = stringToBytes(tok.image);
          raw = new byte[ tmp.length - skip ];
          System.arraycopy(tmp,skip,raw,0,raw.length);
          return raw;
       }
       break; // the text was exactly what we needed: buh bye!
     default:
       throw new IllegalStateException("unexpected token while skipping");
     }
   }
   return raw;
   }
 
   final public void uc() throws ParseException {
   Token word = null, val = null;
     word = jj_consume_token(UC);
     val = jj_consume_token(CW_VAL);
     int bytesToSkip = null == val ? 0 : Integer.parseInt(val.image);
     setCurrentSkipState(new Integer(bytesToSkip));
   }
 
   final public void fcharset() throws ParseException {
   Token word = null, val = null;
     word = jj_consume_token(FCHARSET);
     val = jj_consume_token(CW_VAL);
     _currentCharsetValue = null == val ? 0 : Integer.parseInt(val.image);
     _delegate.controlWord(word.image, _currentCharsetValue, _where);
   }
 
   final public void deff() throws ParseException {
   Token val = null;
     jj_consume_token(DEFF);
     val = jj_consume_token(CW_VAL);
     // need to figure out if this really has to be handled.
     _defaultFont = null == val ? 0 : Integer.parseInt(val.image);
     _delegate.controlWord("\\deff", _defaultFont, _where);
   }
 
   final public void f() throws ParseException {
   Token val;
     jj_consume_token(F);
     val = jj_consume_token(CW_VAL);
     int font = null == val ? 0 : Integer.parseInt(val.image);
     if (IN_FONTTBL == _where) {
       _currentFontValue = font;
     } else if (IN_DOCUMENT == _where) {
       String encoding = (String)_fontEncodingMap.get(new Integer(font));
       setCurrentEncoding(null == encoding ? DEFAULT_ENCODING : encoding);
     }
     _delegate.controlWord("\\f", font, _where);
   }
 
   final public void cs() throws ParseException {
   Token val = null;
     jj_consume_token(CS);
     val = jj_consume_token(CW_VAL);
     int style = null == val ? 0 : Integer.parseInt(val.image);
     if (IN_STYLESHEET == _where) {
       _currentStyleValue = style;
     } else if (IN_DOCUMENT == _where) {
       setCurrentStyle((String)_styleMap.get(new Integer(style)));
     }
     _delegate.controlWord("\\cs", style, _where);
   }
 
   final public void plain() throws ParseException {
     jj_consume_token(PLAIN);
         setCurrentStyle(NO_STYLE);
     _delegate.controlWord("\\plain", VALUE_NOT_SPECIFIED, _where);
   }
 
 /* these productions identify the document encoding; note that they
  * are almost always clobbered by an \ansicpg or by unicode characters */
   final public void document_charset() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case PC:
       jj_consume_token(PC);
               setDocumentEncoding(getJavaEncoding(437));
       break;
     case PCA:
       jj_consume_token(PCA);
               setDocumentEncoding(getJavaEncoding(850));
       break;
     case MAC:
       jj_consume_token(MAC);
               setDocumentEncoding("MacRoman");
       break;
     case ANSI:
       jj_consume_token(ANSI);
                setDocumentEncoding(getJavaEncoding(1252));
       break;
     default:
       jj_la1[14] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
   }
 
 /* specifies the ANSI codepage to use as the document's encoding. Subject
  * to local overrides. */
   final public void ansicpg() throws ParseException {
   Token val = null;
     jj_consume_token(ANSICPG);
     val = jj_consume_token(CW_VAL);
     // must be a value in the map - we should throw if it isn't there.
     int cp = null == val ? 0 : Integer.parseInt(val.image);
     setDocumentEncoding(getJavaEncoding(cp));
   }
 
   final public void rtf_start() throws ParseException {
   Token word = null;
   Token val = null;
     word = jj_consume_token(RTF);
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case CW_VAL:
       val = jj_consume_token(CW_VAL);
       break;
     default:
       jj_la1[15] = jj_gen;
       ;
     }
     int depth = null == val ? 1 : Integer.parseInt(val.image);
     _rtfDepth = _braceDepth;
     _delegate.controlWord(word.image, depth, _where);
   }
 
   final public void from_html() throws ParseException {
   Token val = null;
     jj_consume_token(FROMHTML);
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case CW_VAL:
       jj_consume_token(CW_VAL);
       break;
     default:
       jj_la1[16] = jj_gen;
       ;
     }
     _delegate.controlWord("\\fromhtml", VALUE_NOT_SPECIFIED, _where);
   }
 
   final public void bin() throws ParseException, ParseException {
   Token val = null;
     jj_consume_token(BIN);
     val = jj_consume_token(CW_VAL);
     int nbytes = null == val ? 0 : Integer.parseInt(val.image);
     byte[] data = new byte[nbytes];
     OutputStream os = _delegate.getNextOutputStream(_where);
     try
     {
         try
         {
             // Skip leading space.
             jj_input_stream.readChar();
             for (int i = 0; i < nbytes; i++)
             {
                 // Will only return 8-bit characters.
                 byte b = (byte)jj_input_stream.readChar();
                 if (os != null)
                 {
                     os.write(b);
                 }
             }
         }
         finally
         {
             if (os != null)
             {
                 os.close();
             }
         }
     }
     catch (IOException e)
     {
         {if (true) throw new ParseException("Unable to process binary data");}
         e.printStackTrace();
     }
   }
 
 // TODO: consider collecting special characters in a buffer
   final public void groupContents() throws ParseException, UnsupportedEncodingException {
   Token word = null, val = null;
     label_2:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case LBRACE:
       case NON_BREAKING_SPACE:
       case OPTIONAL_HYPHEN:
       case NON_BREAKING_HYPHEN:
       case ESCAPED_NEWLINE:
       case ESCAPED_CARRIAGE_RETURN:
       case IGNORABLE_DESTINATION:
       case FORMULA_CHARACTER:
       case INDEX_SUBENTRY:
       case ESCAPED_LBRACE:
       case ESCAPED_RBRACE:
       case ESCAPED_BACKSLASH:
       case CONTROL_SYM:
       case TEXT:
       case HEX_CHAR:
       case PAR:
       case LINE:
       case U:
       case UC:
       case F:
       case CS:
       case FCHARSET:
       case PLAIN:
       case PC:
       case PCA:
       case MAC:
       case RTF:
       case ANSI:
       case ANSICPG:
       case DEFF:
       case FROMTEXT:
       case FROMHTML:
       case FBIDIS:
       case INFO:
       case REVTBL:
       case PNTEXT:
       case FONTTBL:
       case COLORTBL:
       case PNSECLVL:
       case LISTTABLE:
       case STYLESHEET:
       case TAB:
       case ZWJ:
       case ZWNJ:
       case EMDASH:
       case ENDASH:
       case EMSPACE:
       case ENSPACE:
       case QMSPACE:
       case BULLET:
       case LQUOTE:
       case RQUOTE:
       case LTRMARK:
       case RTLMARK:
       case LDBLQUOTE:
       case RDBLQUOTE:
       case BIN:
       case CONTROL_WORD:
       case TEXT_CONTROL_DELIMITER:
         ;
         break;
       default:
         jj_la1[17] = jj_gen;
         break label_2;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case RTF:
         rtf_start();
         break;
       case PC:
       case PCA:
       case MAC:
       case ANSI:
         document_charset();
         break;
       case FROMTEXT:
         jj_consume_token(FROMTEXT);
         break;
       case FROMHTML:
         from_html();
         break;
       case FBIDIS:
         jj_consume_token(FBIDIS);
         break;
       case ANSICPG:
         ansicpg();
         break;
       case DEFF:
         deff();
         break;
       case INFO:
       case REVTBL:
       case PNTEXT:
       case FONTTBL:
       case COLORTBL:
       case PNSECLVL:
       case LISTTABLE:
       case STYLESHEET:
         table_declaration();
         break;
       case UC:
         uc();
         break;
       case F:
         f();
         break;
       case FCHARSET:
         fcharset();
         break;
       case CS:
         cs();
         break;
       case PLAIN:
         plain();
         break;
       case BIN:
         bin();
         break;
       case ESCAPED_NEWLINE:
       case ESCAPED_CARRIAGE_RETURN:
       case PAR:
       case LINE:
         line_breaks();
         break;
       case IGNORABLE_DESTINATION:
       case CONTROL_WORD:
         control_word();
         break;
       case FORMULA_CHARACTER:
       case INDEX_SUBENTRY:
       case CONTROL_SYM:
         control_symbol();
         break;
       case LBRACE:
         group();
         break;
       case NON_BREAKING_SPACE:
       case OPTIONAL_HYPHEN:
       case NON_BREAKING_HYPHEN:
       case ESCAPED_LBRACE:
       case ESCAPED_RBRACE:
       case ESCAPED_BACKSLASH:
       case TEXT:
       case HEX_CHAR:
       case U:
       case TAB:
       case ZWJ:
       case ZWNJ:
       case EMDASH:
       case ENDASH:
       case EMSPACE:
       case ENSPACE:
       case QMSPACE:
       case BULLET:
       case LQUOTE:
       case RQUOTE:
       case LTRMARK:
       case RTLMARK:
       case LDBLQUOTE:
       case RDBLQUOTE:
       case TEXT_CONTROL_DELIMITER:
         text();
         break;
       default:
         jj_la1[18] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
     }
   }
 
   final public void group() throws ParseException, UnsupportedEncodingException {
   Token word = null, val = null;
     lbrace();
     groupContents();
     rbrace();
   }
 
   final public void document() throws ParseException, UnsupportedEncodingException {
     _delegate.startDocument();
     groupContents();
     _delegate.endDocument();
     jj_consume_token(0);
   }
 
   public RTFParserTokenManager token_source;
   SimpleCharStream jj_input_stream;
   public Token token, jj_nt;
   private int jj_ntk;
   private int jj_gen;
   final private int[] jj_la1 = new int[19];
   static private int[] jj_la1_0;
   static private int[] jj_la1_1;
   static private int[] jj_la1_2;
   static {
       jj_la1_0();
       jj_la1_1();
       jj_la1_2();
    }
    private static void jj_la1_0() {
       jj_la1_0 = new int[] {0x800e0e00,0x80ae0e00,0x80ae0e00,0x200000,0xe0000,0xe00,0x0,0x60003000,0x0,0x0,0x0,0x118000,0x0,0x4000,0x0,0x0,0x0,0xe0bffe80,0xe0bffe80,};
    }
    private static void jj_la1_1() {
       jj_la1_1 = new int[] {0xff800000,0xff800000,0xff800000,0x0,0x0,0x0,0xff800000,0x0,0x0,0x0,0x7f8000,0x0,0x0,0x0,0x2e0,0x0,0x0,0xffffffff,0xffffffff,};
    }
    private static void jj_la1_2() {
       jj_la1_2 = new int[] {0x3f,0x43f,0x43f,0x400,0x0,0x0,0x3f,0x0,0x200,0x200,0x0,0x0,0x200,0x80,0x0,0x200,0x200,0x4ff,0x4ff,};
    }
 
   public RTFParser(java.io.InputStream stream) {
      this(stream, null);
   }
   public RTFParser(java.io.InputStream stream, String encoding) {
     try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
     token_source = new RTFParserTokenManager(jj_input_stream);
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
     for (int i = 0; i < 19; i++) jj_la1[i] = -1;
   }
 
   public void ReInit(java.io.InputStream stream) {
      ReInit(stream, null);
   }
   public void ReInit(java.io.InputStream stream, String encoding) {
     try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
     token_source.ReInit(jj_input_stream);
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
     for (int i = 0; i < 19; i++) jj_la1[i] = -1;
   }
 
   public RTFParser(java.io.Reader stream) {
     jj_input_stream = new SimpleCharStream(stream, 1, 1);
     token_source = new RTFParserTokenManager(jj_input_stream);
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
     for (int i = 0; i < 19; i++) jj_la1[i] = -1;
   }
 
   public void ReInit(java.io.Reader stream) {
     jj_input_stream.ReInit(stream, 1, 1);
     token_source.ReInit(jj_input_stream);
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
     for (int i = 0; i < 19; i++) jj_la1[i] = -1;
   }
 
   public RTFParser(RTFParserTokenManager tm) {
     token_source = tm;
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
     for (int i = 0; i < 19; i++) jj_la1[i] = -1;
   }
 
   public void ReInit(RTFParserTokenManager tm) {
     token_source = tm;
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
     for (int i = 0; i < 19; i++) jj_la1[i] = -1;
   }
 
   final private Token jj_consume_token(int kind) throws ParseException {
     Token oldToken;
     if ((oldToken = token).next != null) token = token.next;
     else token = token.next = token_source.getNextToken();
     jj_ntk = -1;
     if (token.kind == kind) {
       jj_gen++;
       return token;
     }
     token = oldToken;
     jj_kind = kind;
     throw generateParseException();
   }
 
   final public Token getNextToken() {
     if (token.next != null) token = token.next;
     else token = token.next = token_source.getNextToken();
     jj_ntk = -1;
     jj_gen++;
     return token;
   }
 
   final public Token getToken(int index) {
     Token t = token;
     for (int i = 0; i < index; i++) {
       if (t.next != null) t = t.next;
       else t = t.next = token_source.getNextToken();
     }
     return t;
   }
 
   final private int jj_ntk() {
     if ((jj_nt=token.next) == null)
       return (jj_ntk = (token.next=token_source.getNextToken()).kind);
     else
       return (jj_ntk = jj_nt.kind);
   }
 
   private java.util.Vector jj_expentries = new java.util.Vector();
   private int[] jj_expentry;
   private int jj_kind = -1;
 
   public ParseException generateParseException() {
     jj_expentries.removeAllElements();
     boolean[] la1tokens = new boolean[75];
     for (int i = 0; i < 75; i++) {
       la1tokens[i] = false;
     }
     if (jj_kind >= 0) {
       la1tokens[jj_kind] = true;
       jj_kind = -1;
     }
     for (int i = 0; i < 19; i++) {
       if (jj_la1[i] == jj_gen) {
         for (int j = 0; j < 32; j++) {
           if ((jj_la1_0[i] & (1<<j)) != 0) {
             la1tokens[j] = true;
           }
           if ((jj_la1_1[i] & (1<<j)) != 0) {
             la1tokens[32+j] = true;
           }
           if ((jj_la1_2[i] & (1<<j)) != 0) {
             la1tokens[64+j] = true;
           }
         }
       }
     }
     for (int i = 0; i < 75; i++) {
       if (la1tokens[i]) {
         jj_expentry = new int[1];
         jj_expentry[0] = i;
         jj_expentries.addElement(jj_expentry);
       }
     }
     int[][] exptokseq = new int[jj_expentries.size()][];
     for (int i = 0; i < jj_expentries.size(); i++) {
       exptokseq[i] = (int[])jj_expentries.elementAt(i);
     }
     return new ParseException(token, exptokseq, tokenImage);
   }
 
   final public void enable_tracing() {
   }
 
   final public void disable_tracing() {
   }
 
 }
