  /*
   * Copyright 2012 Michael Bischoff
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
 
 package de.jpaw.persistence.dsl.scoping;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.eclipse.emf.ecore.EObject;
 //import org.eclipse.xtext.naming.DefaultDeclarativeQualifiedNameProvider;
 //import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
 import org.eclipse.xtext.scoping.impl.ImportNormalizer;
 import org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider;
 
 import de.jpaw.bonaparte.dsl.bonScript.ClassDefinition;
 import de.jpaw.bonaparte.dsl.bonScript.PackageDefinition;
 import de.jpaw.bonaparte.dsl.generator.XUtil;
 import de.jpaw.persistence.dsl.bDDL.CollectionDefinition;
 import de.jpaw.persistence.dsl.bDDL.EntityDefinition;
 import de.jpaw.persistence.dsl.bDDL.ForeignKeyDefinition;
 import de.jpaw.persistence.dsl.bDDL.ListOfColumns;
 import de.jpaw.persistence.dsl.bDDL.SingleColumn;
 import de.jpaw.persistence.dsl.generator.YUtil;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 
 /**
  * This class contains custom scoping description.
  * 
  * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping
  * on how and when to use it 
  *
  */
 /* The following code is based on guidelines found on the net, given by Jan Kohnlein (http://www.eclipse.org/forums/index.php/t/359674/)
  * Quote: "add your imports as an ImportNormalizer.
  * The method createImportedNamespaceResolver(String, boolean) helps you create such
  * an object. The XtendImportedNamespaceScopeProvider does something similar."
  * ...
  * "Don't forget to bind your subclass of the ImportedNamespaceAwareScopeProviderin the runtime module of your language."
  *  */
 public class BDDLScopeProvider extends ImportedNamespaceAwareLocalScopeProvider { // was autogenerated: AbstractDeclarativeScopeProvider {
     private static Log logger = LogFactory.getLog("BDDLScopeProvider"); // jcl
     
     private void recursivelyAddColumnsOfClassAndParents(List<ImportNormalizer> preliminaryResult,
             ClassDefinition cl, boolean ignoreCase) {
         while (cl != null) {
             //System.out.println("DEBUG:   POJO is " + cl.getName());
             if (cl.eContainer() == null)  // occurs if a previously referenced import is deleted... 
                 return;
             PackageDefinition bonScriptPd = (PackageDefinition)cl.eContainer();  // ATTN: the bonScript one!
             // alternative way to get the namespace could be to run it through a new DefaultDeclarativeQualifiedNameProvider(); 
             String qualifiedImportNamespace = bonScriptPd.getName() + "." + cl.getName() + ".*";
             //System.out.println("DEBUG:   adding " + qualifiedImportNamespace + " to imports...");
             preliminaryResult.add(createImportedNamespaceResolver(qualifiedImportNamespace, ignoreCase));
             cl = XUtil.getParent(cl);
         }
     }
 
     private List<ImportNormalizer> getColumnsSub(EntityDefinition entity, boolean ignoreCase) {
         List<ImportNormalizer> preliminaryResult = new ArrayList<ImportNormalizer>(50);
         //ListOfColumns loc = (ListOfColumns)context;
         //System.out.println("DEBUG: Resolver invoked for ListOfColumns inside " + entity.getName());
         recursivelyAddColumnsOfClassAndParents(preliminaryResult, entity.getPojoType(), ignoreCase);
         // also add the fields of the entity category class (& parents)
         if (entity.getTableCategory() != null)
             recursivelyAddColumnsOfClassAndParents(preliminaryResult, entity.getTableCategory().getTrackingColumns(), ignoreCase);
         // also add the fields in a potential tenant discriminator class
         if (YUtil.getInheritanceRoot(entity).getTenantClass() != null)
             recursivelyAddColumnsOfClassAndParents(preliminaryResult, YUtil.getInheritanceRoot(entity).getTenantClass(), ignoreCase);
         //System.out.println("DEBUG: Resolver found " + preliminaryResult.size() + " entries");
         return preliminaryResult;
     }
     
     @Override
     protected
     List<ImportNormalizer> internalGetImportedNamespaceResolvers(EObject context, boolean ignoreCase) {
         List<ImportNormalizer> preliminaryResult;
         if ((context instanceof ListOfColumns ||
              context instanceof SingleColumn ||
              context instanceof ForeignKeyDefinition ||
              context instanceof CollectionDefinition) && context.eContainer() != null) {
             // the only valid reference in a list of columns is a column of the entity referenced.
            preliminaryResult = getColumnsSub(YUtil.getBaseEntity(context.eContainer()), ignoreCase);
             
         } else {
             preliminaryResult = super.internalGetImportedNamespaceResolvers(context, ignoreCase);
         }
         return preliminaryResult;
     }
 }
