 /* Generated By:JavaCC: Do not edit this line. WMParser_impl.java */
 package org.webmacro.parser;
 
 import java.util.*;
 import java.io.*;
 import org.webmacro.*;
 import org.webmacro.engine.*;
 import org.webmacro.directive.*;
 import org.webmacro.directive.Directive;
 import org.webmacro.directive.DirectiveBuilder;
 import org.webmacro.directive.Directive.ArgDescriptor;
 import org.webmacro.directive.Directive.Subdirective;
 
 /**
  * WMParser_impl
  *
  * JavaCC parser class for parsing WebMacro templates.  
  * The supported entry point is WMDocument, which returns a BlockBuilder. 
  *
  * @author Brian Goetz
  */
 
 public class WMParser_impl implements WMParser_implConstants {
 
   private Broker broker;
 
   public WMParser_impl(Broker broker, java.io.Reader reader) {
     this(new BackupCharStream(reader));
     this.broker = broker;
   }
 
   // Standalone test harness
   public static void main(String[] args) throws Exception {
     WM wm = new WM();
     Broker broker = wm.getBroker();
     WMParser_impl parser;
 
     if (args.length >= 1)
       parser = new WMParser_impl(broker, new FileReader(args[0]));
     else
       parser = new WMParser_impl(broker, new InputStreamReader(System.in));
 
     Builder bb = parser.WMDocument();
     Context context = null;
 
     try {
        context = wm.getContext();
        Object names[] = { "prop" };
        context.setProperty(names, "Example property");
        Block b = (Block) bb.build(new BuildContext(broker));
        // TemplateDumper d = new TemplateDumper();
        // b.accept(d);
        // System.out.println("---------------------------------------------");
        System.out.println((String) b.evaluate(context));
     } catch (Exception e) {
        e.printStackTrace();
     }
   }
 
 
   // JavaCC hack for doing lexical state transitions syntactically
 
   private void SetState(int state) {
     if (state != token_source.curLexState) {
       while (token.next != null) {
         Token t = token;
         while (t.next != null && t.next.next != null) {
           t = t.next;
         }
 
         token_source.backup(t.next.image.length());
         t.next = null;
       };
       jj_ntk = -1;
       token_source.SwitchTo(state);
     }
   }
 
   private static String SEMI_FEATURE =
     "Use of semicolon to delimit property reference -- use $( ) instead";
   private static String DDOLLAR_FEATURE =
     "Use of $$ to reference template property -- use single $ instead";
 
   // Warning routines
   private void warnDeprecated(String feature) {
     broker.getLog("parser").warning("Deprecated feature: " + feature);
   }
 
   Subdirective lookahead_subdirective(Subdirective[] subdirectives) throws ParseException {
   int n=1;
   if (getToken(n).kind == WS)            ++n;
   if (getToken(n).kind == NEWLINE)       ++n;
   if (getToken(n).kind == WS)            ++n;
   if (getToken(n).kind == POUND
       && getToken(n+1).kind == WORD) {
     String word = getToken(n+1).image;
     for (int i=0; i<subdirectives.length; i++)
       if (word.equals(subdirectives[i].name))
         return subdirectives[i];
   }
   return null;
   }
 
   boolean lookahead_keyword(String keyword) throws ParseException {
   int n=1;
   if (getToken(n).kind == WS)
     ++n;
   if (getToken(n).kind == WORD
       && getToken(n).image.equals(keyword))
     return true;
   else
     return false;
   }
 
   Object parse_arg(ArgDescriptor arg) throws ParseException {
   switch (arg.type) {
   case Directive.ArgType_CONDITION:
     return Conditional();
 
   case Directive.ArgType_BLOCK: {
     OptionalWsNl();
     SetState(DEFAULT);
     BlockBuilder b = Block();
     SetState(WM);
     OptionalWs();
     return b;
   }
 
   case Directive.ArgType_LITBLOCK: {
     OptionalWsNl();
     SetState(DEFAULT);
     BlockBuilder b = LiteralBlock();
     SetState(WM);
     OptionalWs();
     return b;
   }
 
   case Directive.ArgType_LVALUE:
     return LValue();
 
   case Directive.ArgType_RVALUE:
     return RValue();
 
   case Directive.ArgType_QUOTEDSTRING:
     return QuotedString();
 
   case Directive.ArgType_ASSIGN:
     Punct_EQ();
     return "=";
 
   case Directive.ArgType_KEYWORD:
     if (arg.optional && !lookahead_keyword(arg.keyword))
       return null;
     else {
       Keyword(arg.keyword);
       return arg.keyword;
     }
 
   default:
     throw new ParseException("ParseDirectiveArg: Unknown argument type "
                              + arg.type);
  }
   }
 
   boolean parse_arg_group(ArgDescriptor[] args, int i,
                          DirectiveArgs da) throws ParseException, BuildException {
   if (args[i].optional)
     if (!lookahead_keyword(args[args[i].children[0]].keyword))
       return false;
   for (int j=0; j<args[i].subordinateArgs; j++) {
     ArgDescriptor child = args[args[i].children[j]];
     if (child.type == Directive.ArgType_GROUP) {
       parse_arg_group(args, args[i].children[j], da);
     }
     else {
       Object o = parse_arg(child);
       da.setArg(child.id, o);
     }
   }
   return true;
   }
 
   void parse_args(ArgDescriptor[] args, DirectiveArgs da) throws ParseException {
   try {
     for (int i=0; i < args.length; ) {
       ArgDescriptor arg = args[i];
 
       if (arg.type == Directive.ArgType_GROUP)
         parse_arg_group(args, i, da);
       else if (arg.type == Directive.ArgType_CHOICE) {
         for (int j=0; j<arg.subordinateArgs; j++) {
           // Each child is a GROUP, so we want to look at child's first child
           ArgDescriptor child = args[arg.children[j]];
           if (lookahead_keyword(args[child.children[0]].keyword))
             parse_arg_group(args, arg.children[j], da);
         }
       }
       else {
         Object o = parse_arg(arg);
         da.setArg(arg.id, o);
       }
       i = arg.nextArg;
     }
   }
   catch (BuildException e) {
     throw new ParseException("BuildException", e);
   }
   }
 
   DirectiveBuilder parse_directive(String directive) throws ParseException, ParseException {
   DirectiveBuilder db=null;
   DirectiveDescriptor descriptor=null;
   Subdirective subd;
 
   try {
     descriptor =
       (DirectiveDescriptor) broker.get("org.webmacro.directive.Directive",
                                        directive);
     if (!descriptor.valid)
       throw new ParseException("Descriptor for directive " + directive
                                + " is not valid");
   }
   catch (Exception e) {
     throw new ParseException("Exception fetching directive "+directive
                              + System.getProperty("line.separator"), e);
   }
   db = new DirectiveBuilder(descriptor);
   parse_args(descriptor.args, db);
 
   if (descriptor.subdirectives != null
       && descriptor.subdirectives.length > 0) {
     DirectiveArgs da;
 
     while ((subd = lookahead_subdirective(descriptor.subdirectives)) != null) {
       SubdirectiveStart();
       try {
         da = db.newSubdirective(subd.id);
       } catch (BuildException e) {
         throw new ParseException("BuildException", e);
       };
       parse_args(subd.args, da);
     }
   }
   OptionalWs();
 
   return db;
   }
 
 /* Utility productions used by above JavaCode productions (State: WM) */
   final public void OptionalWsNl() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[0] = jj_gen;
       ;
     }
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case NEWLINE:
       jj_consume_token(NEWLINE);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[1] = jj_gen;
         ;
       }
       break;
     default:
       jj_la1[2] = jj_gen;
       ;
     }
   }
 
   final public void OptionalWs() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[3] = jj_gen;
       ;
     }
   }
 
   final public void SubdirectiveStart() throws ParseException {
     OptionalWsNl();
     jj_consume_token(POUND);
     jj_consume_token(WORD);
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[4] = jj_gen;
       ;
     }
   }
 
 /* Productions used by JavaCode productions to parse directive arguments. 
    Correpond mostly to the defined argument types.  (State: WM) */
   final public Builder LValue() throws ParseException {
   Builder lv;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[5] = jj_gen;
       ;
     }
     lv = VariableReference();
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[6] = jj_gen;
       ;
     }
                                              {if (true) return lv;}
     throw new Error("Missing return statement in function");
   }
 
   final public Object RValue() throws ParseException {
   Object rv;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[7] = jj_gen;
       ;
     }
     rv = Expression();
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[8] = jj_gen;
       ;
     }
                                       {if (true) return rv;}
     throw new Error("Missing return statement in function");
   }
 
   final public void Punct_EQ() throws ParseException {
   Token t;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[9] = jj_gen;
       ;
     }
     jj_consume_token(OP_SET);
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[10] = jj_gen;
       ;
     }
   }
 
   final public void Punct_COMMA() throws ParseException {
   Token t;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[11] = jj_gen;
       ;
     }
     jj_consume_token(COMMA);
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[12] = jj_gen;
       ;
     }
   }
 
   final public void Punct_LPAREN() throws ParseException {
   Token t;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[13] = jj_gen;
       ;
     }
     jj_consume_token(LPAREN);
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[14] = jj_gen;
       ;
     }
   }
 
   final public void Punct_RPAREN() throws ParseException {
   Token t;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[15] = jj_gen;
       ;
     }
     jj_consume_token(RPAREN);
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[16] = jj_gen;
       ;
     }
   }
 
   final public void Keyword(String s) throws ParseException {
   Token t;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[17] = jj_gen;
       ;
     }
     t = jj_consume_token(WORD);
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[18] = jj_gen;
       ;
     }
     if (!s.equals(t.image))
       {if (true) throw new ParseException("Encountered " + t.image + " at line "
                                + t.beginLine + "; expecting " + s);}
   }
 
   final public Object Conditional() throws ParseException {
   Object e;
     jj_consume_token(LPAREN);
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[19] = jj_gen;
       ;
     }
     e = Expression();
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[20] = jj_gen;
       ;
     }
     jj_consume_token(RPAREN);
                                                        {if (true) return e;}
     throw new Error("Missing return statement in function");
   }
 
 /* ******************* */
 /* Variable References */
 /* ******************* */
 
 /* Productions used in WM variable references.  State: WM.  */
 
 // Used by VariableReference; shouldn't be used outside it
   final public void VariableReferenceGuts(Vector v) throws ParseException {
   Token t;
   Object element;
   ListBuilder argList;
     t = jj_consume_token(WORD);
              v.addElement(t.image);
     label_1:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case DOT:
         ;
         break;
       default:
         jj_la1[21] = jj_gen;
         break label_1;
       }
       jj_consume_token(DOT);
       t = jj_consume_token(WORD);
                      element = t.image;
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case LPAREN:
         jj_consume_token(LPAREN);
         argList = ArgList();
         jj_consume_token(RPAREN);
         element = new PropertyMethodBuilder((String) element, argList);
         break;
       default:
         jj_la1[22] = jj_gen;
         ;
       }
       v.addElement(element);
     }
   }
 
   final public Builder VariableReference() throws ParseException {
   Vector v = new Vector();
     jj_consume_token(DOLLAR);
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case DOLLAR:
       jj_consume_token(DOLLAR);
                warnDeprecated(DDOLLAR_FEATURE);
       break;
     default:
       jj_la1[23] = jj_gen;
       ;
     }
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WORD:
       VariableReferenceGuts(v);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case SEMI:
         jj_consume_token(SEMI);
                                         warnDeprecated(SEMI_FEATURE);
         break;
       default:
         jj_la1[24] = jj_gen;
         ;
       }
       break;
     case LPAREN:
       jj_consume_token(LPAREN);
       VariableReferenceGuts(v);
       jj_consume_token(RPAREN);
       break;
     default:
       jj_la1[25] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
     Object[] names = new Object[v.size()];
     v.copyInto(names);
     {if (true) return new VariableBuilder(names, false);}
     throw new Error("Missing return statement in function");
   }
 
 /* ********************** */
 /* Expression Productions */
 /* ********************** */
 
 /* Productions used in parsing WM expressions.  State: WM.  
    Most general expression type is Expression() */
 
 // State: preserved
   final public Builder QuotedString() throws ParseException {
   int entryState = token_source.curLexState;
   Token t;
   QuotedStringBuilder qs = new QuotedStringBuilder();
     jj_consume_token(QUOTE);
             SetState(QS);
     label_2:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case DOLLAR:
       case QCHAR:
       case SLASH:
       case QS_TEXT:
         ;
         break;
       default:
         jj_la1[26] = jj_gen;
         break label_2;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case QS_TEXT:
         t = jj_consume_token(QS_TEXT);
                   qs.addElement(t.image);
         break;
       case QCHAR:
         t = jj_consume_token(QCHAR);
                   qs.addElement(t.image.substring(1));
         break;
       case SLASH:
         t = jj_consume_token(SLASH);
                   qs.addElement(t.image);
         break;
       default:
         jj_la1[27] = jj_gen;
         if (jj_2_1(2147483647)) {
           DollarReference(qs);
         } else {
           jj_consume_token(-1);
           throw new ParseException();
         }
       }
     }
     jj_consume_token(QUOTE);
     SetState(entryState);
     {if (true) return qs;}
     throw new Error("Missing return statement in function");
   }
 
   final public ListBuilder ArgList() throws ParseException {
   ListBuilder list = new ListBuilder();
   Object e;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case DOLLAR:
     case QUOTE:
     case NULL:
     case TRUE:
     case FALSE:
     case LPAREN:
     case LBRACKET:
     case OP_MINUS:
     case OP_NOT:
     case NUMBER:
       e = Expression();
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[28] = jj_gen;
         ;
       }
                             list.addElement(e);
       label_3:
       while (true) {
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case COMMA:
           ;
           break;
         default:
           jj_la1[29] = jj_gen;
           break label_3;
         }
         jj_consume_token(COMMA);
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case WS:
           jj_consume_token(WS);
           break;
         default:
           jj_la1[30] = jj_gen;
           ;
         }
         e = Expression();
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case WS:
           jj_consume_token(WS);
           break;
         default:
           jj_la1[31] = jj_gen;
           ;
         }
                                                list.addElement(e);
       }
       break;
     default:
       jj_la1[32] = jj_gen;
       ;
     }
     {if (true) return list;}
     throw new Error("Missing return statement in function");
   }
 
   final public ListBuilder BracketList() throws ParseException {
   ListBuilder list;
     jj_consume_token(LBRACKET);
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case WS:
       jj_consume_token(WS);
       break;
     default:
       jj_la1[33] = jj_gen;
       ;
     }
     list = ArgList();
     jj_consume_token(RBRACKET);
     {if (true) return list;}
     throw new Error("Missing return statement in function");
   }
 
   final public Object Term() throws ParseException {
   Object e;
   Token t;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case DOLLAR:
       e = VariableReference();
       break;
     case LPAREN:
       jj_consume_token(LPAREN);
       e = Expression();
       jj_consume_token(RPAREN);
       break;
     case QUOTE:
       e = QuotedString();
       break;
     case LBRACKET:
       e = BracketList();
       break;
     case NULL:
       jj_consume_token(NULL);
                          e = null;
       break;
     case TRUE:
       jj_consume_token(TRUE);
                          e = Boolean.TRUE;
       break;
     case FALSE:
       jj_consume_token(FALSE);
                          e = Boolean.FALSE;
       break;
     case OP_NOT:
       jj_consume_token(OP_NOT);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[34] = jj_gen;
         ;
       }
       e = Term();
                                  e = new Expression.NotBuilder(e);
       break;
     case NUMBER:
       t = jj_consume_token(NUMBER);
         try { e = new Long(t.image); }
         catch (NumberFormatException ex) { e=null; }
       break;
     case OP_MINUS:
       jj_consume_token(OP_MINUS);
       t = jj_consume_token(NUMBER);
         try { long l = Long.parseLong(t.image); e = new Long(-l); }
         catch (NumberFormatException ex) { e=null; }
       break;
     default:
       jj_la1[35] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
     {if (true) return e;}
     throw new Error("Missing return statement in function");
   }
 
   final public Object Factor() throws ParseException {
   Object e1, e2=null;
   Token op=null;
     e1 = Term();
     if (jj_2_2(2)) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[36] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case OP_MULT:
         op = jj_consume_token(OP_MULT);
         break;
       case OP_DIV:
         op = jj_consume_token(OP_DIV);
         break;
       default:
         jj_la1[37] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[38] = jj_gen;
         ;
       }
       e2 = Factor();
     } else {
       ;
     }
     if (op == null)
       {if (true) return e1;}
     else if (op.kind == OP_MULT)
       {if (true) return new Expression.MultiplyBuilder(e1, e2);}
     else if (op.kind == OP_DIV)
       {if (true) return new Expression.DivideBuilder(e1, e2);}
     else
       {if (true) throw new ParseException("internal parser error in Factor()");}
     throw new Error("Missing return statement in function");
   }
 
   final public Object AExpression() throws ParseException {
   Object e1, e2=null;
   Token op=null;
     e1 = Factor();
     if (jj_2_3(2)) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[39] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case OP_PLUS:
         op = jj_consume_token(OP_PLUS);
         break;
       case OP_MINUS:
         op = jj_consume_token(OP_MINUS);
         break;
       default:
         jj_la1[40] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[41] = jj_gen;
         ;
       }
       e2 = AExpression();
     } else {
       ;
     }
     if (op == null)
       {if (true) return e1;}
     else if (op.kind == OP_PLUS)
       {if (true) return new Expression.AddBuilder(e1, e2);}
     else if (op.kind == OP_MINUS)
       {if (true) return new Expression.SubtractBuilder(e1, e2);}
     else
       {if (true) throw new ParseException("internal parser error in AExpression()");}
     throw new Error("Missing return statement in function");
   }
 
   final public Token RelOp() throws ParseException {
   Token t;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case OP_EQ:
       t = jj_consume_token(OP_EQ);
       break;
     case OP_SET:
       t = jj_consume_token(OP_SET);
       break;
     case OP_NE:
       t = jj_consume_token(OP_NE);
       break;
     case OP_GT:
       t = jj_consume_token(OP_GT);
       break;
     case OP_GE:
       t = jj_consume_token(OP_GE);
       break;
     case OP_LE:
       t = jj_consume_token(OP_LE);
       break;
     case OP_LT:
       t = jj_consume_token(OP_LT);
       break;
     default:
       jj_la1[42] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
     {if (true) return t;}
     throw new Error("Missing return statement in function");
   }
 
   final public Object CExpression() throws ParseException {
   // Note that CExpression is a little different from other binary
   // expression rules, as we don't want to accept a == b == c
   // Thanks to Aldona Majorek for pointing this out
 
   Object e1, e2=null;
   Token op=null;
     e1 = AExpression();
     if (jj_2_4(2)) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[43] = jj_gen;
         ;
       }
       op = RelOp();
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[44] = jj_gen;
         ;
       }
       e2 = AExpression();
     } else {
       ;
     }
     if (op == null)
       {if (true) return e1;}
     else switch (op.kind) {
       case OP_EQ:  {if (true) return new Expression.CompareEqBuilder(e1, e2);}
       case OP_SET: {if (true) return new Expression.CompareEqBuilder(e1, e2);}
       case OP_NE:  {if (true) return new Expression.CompareNeBuilder(e1, e2);}
       case OP_GT:  {if (true) return new Expression.CompareGtBuilder(e1, e2);}
       case OP_GE:  {if (true) return new Expression.CompareGeBuilder(e1, e2);}
       case OP_LE:  {if (true) return new Expression.CompareLeBuilder(e1, e2);}
       case OP_LT:  {if (true) return new Expression.CompareLtBuilder(e1, e2);}
       default:
         {if (true) throw new ParseException("internal parser error in CExpression()");}
     }
     throw new Error("Missing return statement in function");
   }
 
   final public Object AndExpression() throws ParseException {
   Object e1, e2=null;
     e1 = CExpression();
     if (jj_2_5(2)) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[45] = jj_gen;
         ;
       }
       jj_consume_token(OP_AND);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[46] = jj_gen;
         ;
       }
       e2 = AndExpression();
     } else {
       ;
     }
     if (e2 == null)
       {if (true) return e1;}
     else
       {if (true) return new Expression.AndBuilder(e1, e2);}
     throw new Error("Missing return statement in function");
   }
 
   final public Object OrExpression() throws ParseException {
   Object e1, e2=null;
     e1 = AndExpression();
     if (jj_2_6(2)) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[47] = jj_gen;
         ;
       }
       jj_consume_token(OP_OR);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[48] = jj_gen;
         ;
       }
       e2 = OrExpression();
     } else {
       ;
     }
     if (e2 == null)
       {if (true) return e1;}
     else
       {if (true) return new Expression.OrBuilder(e1, e2);}
     throw new Error("Missing return statement in function");
   }
 
   final public Object Expression() throws ParseException {
   Object e=null;
     e = OrExpression();
                      {if (true) return e;}
     throw new Error("Missing return statement in function");
   }
 
 /* ********************** */
 /* WM Content Productions */
 /* ********************** */
 
 /* All of the following operate in the DEFAULT state */
 
 // Parses an entire directive.  Treats # as text if the previous character
 // is a letter, digit, or certain special characters (=, ', ")
   final public void Directive(ParserBlockBuilder b) throws ParseException {
   Token t;
   Object o;
     jj_consume_token(POUND);
     SetState(WM);
     if (jj_2_7(2147483647) && (b.directiveOk())) {
       t = jj_consume_token(WORD);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case WS:
         jj_consume_token(WS);
         break;
       default:
         jj_la1[49] = jj_gen;
         ;
       }
       o = parse_directive(t.image);
          b.eatTrailingWsNl(); b.addElement(o);
     } else {
         b.addElement("#");
     }
     SetState(DEFAULT);
   }
 
 // Parses an entire directive.  Treats ## as text if the previous character
 // is a letter, digit, or certain special characters (=, ', ")
   final public void Comment(ParserBlockBuilder b) throws ParseException {
     jj_consume_token(POUNDPOUND);
     SetState(COMMENT);
     if (b.directiveOk()) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case RESTOFLINE:
         jj_consume_token(RESTOFLINE);
         break;
       default:
         jj_la1[50] = jj_gen;
         ;
       }
                          b.eatTrailingWsNl();
     } else {
         b.addElement("##");
     }
     SetState(DEFAULT);
   }
 
   final public void DollarReference(Vector v) throws ParseException {
   int entryState = token_source.curLexState;
   Object o;
     SetState(WM);
     if (jj_2_8(2147483647)) {
       o = VariableReference();
                               v.addElement(o);
     } else {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case DOLLAR:
         jj_consume_token(DOLLAR);
                  v.addElement("$");
         break;
       default:
         jj_la1[51] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
     }
     SetState(entryState);
   }
 
   final public void WMContent(ParserBlockBuilder b) throws ParseException {
   Token t;
   Object o;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case STUFF:
       t = jj_consume_token(STUFF);
                       b.addElement(t.image);
       break;
     case QCHAR:
       t = jj_consume_token(QCHAR);
                       b.addElement(t.image.substring(1)); b.markLiteral();
       break;
     case SLASH:
       t = jj_consume_token(SLASH);
                       b.addElement(t.image);
       break;
     case POUND:
       Directive(b);
       break;
     case POUNDPOUND:
       Comment(b);
       break;
     default:
       jj_la1[52] = jj_gen;
       if (jj_2_9(2147483647)) {
         DollarReference(b);
       } else {
         jj_consume_token(-1);
         throw new ParseException();
       }
     }
   }
 
   final public void LiteralWMContent(ParserBlockBuilder b) throws ParseException {
   Token t;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
     case QCHAR:
       t = jj_consume_token(QCHAR);
                 b.addElement(t.image.substring(1));
       break;
     case STUFF:
     case POUNDPOUND:
     case DOLLAR:
     case SLASH:
     case POUND:
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case STUFF:
         t = jj_consume_token(STUFF);
         break;
       case SLASH:
         t = jj_consume_token(SLASH);
         break;
       case POUND:
         t = jj_consume_token(POUND);
         break;
       case DOLLAR:
         t = jj_consume_token(DOLLAR);
         break;
       case POUNDPOUND:
         t = jj_consume_token(POUNDPOUND);
         break;
       default:
         jj_la1[53] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
         b.addElement(t.image);
       break;
     default:
       jj_la1[54] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
   }
 
   final public BlockBuilder LiteralBlock() throws ParseException {
   ParserBlockBuilder block = new ParserBlockBuilder();
   Token t;
     if (jj_2_10(2147483647)) {
       jj_consume_token(LBRACE);
       label_4:
       while (true) {
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case STUFF:
         case BEGIN:
         case END:
         case POUNDPOUND:
         case DOLLAR:
         case QCHAR:
         case SLASH:
         case POUND:
           ;
           break;
         default:
           jj_la1[55] = jj_gen;
           break label_4;
         }
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case STUFF:
         case POUNDPOUND:
         case DOLLAR:
         case QCHAR:
         case SLASH:
         case POUND:
           LiteralWMContent(block);
           break;
         case BEGIN:
         case END:
           switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
           case BEGIN:
             t = jj_consume_token(BEGIN);
             break;
           case END:
             t = jj_consume_token(END);
             break;
           default:
             jj_la1[56] = jj_gen;
             jj_consume_token(-1);
             throw new ParseException();
           }
                                         block.addElement(t.image);
           break;
         default:
           jj_la1[57] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
       }
       jj_consume_token(RBRACE);
     } else {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case STUFF:
       case BEGIN:
       case END:
       case LBRACE:
       case RBRACE:
       case POUNDPOUND:
       case DOLLAR:
       case QCHAR:
       case SLASH:
       case POUND:
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case BEGIN:
           jj_consume_token(BEGIN);
           break;
         default:
           jj_la1[58] = jj_gen;
           ;
         }
         label_5:
         while (true) {
           switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
           case STUFF:
           case LBRACE:
           case RBRACE:
           case POUNDPOUND:
           case DOLLAR:
           case QCHAR:
           case SLASH:
           case POUND:
             ;
             break;
           default:
             jj_la1[59] = jj_gen;
             break label_5;
           }
           switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
           case STUFF:
           case POUNDPOUND:
           case DOLLAR:
           case QCHAR:
           case SLASH:
           case POUND:
             LiteralWMContent(block);
             break;
           case LBRACE:
           case RBRACE:
             switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
             case LBRACE:
               t = jj_consume_token(LBRACE);
               break;
             case RBRACE:
               t = jj_consume_token(RBRACE);
               break;
             default:
               jj_la1[60] = jj_gen;
               jj_consume_token(-1);
               throw new ParseException();
             }
                                         block.addElement(t.image);
             break;
           default:
             jj_la1[61] = jj_gen;
             jj_consume_token(-1);
             throw new ParseException();
           }
         }
         jj_consume_token(END);
         break;
       default:
         jj_la1[62] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
     }
     {if (true) return block;}
     throw new Error("Missing return statement in function");
   }
 
   final public BlockBuilder Block() throws ParseException {
   ParserBlockBuilder block = new ParserBlockBuilder();
   Token t;
     if (jj_2_11(2147483647)) {
       jj_consume_token(LBRACE);
       label_6:
       while (true) {
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case STUFF:
         case BEGIN:
         case END:
         case POUNDPOUND:
         case DOLLAR:
         case QCHAR:
         case SLASH:
         case POUND:
           ;
           break;
         default:
           jj_la1[63] = jj_gen;
           break label_6;
         }
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case STUFF:
         case POUNDPOUND:
         case DOLLAR:
         case QCHAR:
         case SLASH:
         case POUND:
           WMContent(block);
           break;
         case BEGIN:
         case END:
           switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
           case BEGIN:
             t = jj_consume_token(BEGIN);
             break;
           case END:
             t = jj_consume_token(END);
             break;
           default:
             jj_la1[64] = jj_gen;
             jj_consume_token(-1);
             throw new ParseException();
           }
                                       block.addElement(t.image);
           break;
         default:
           jj_la1[65] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
       }
       jj_consume_token(RBRACE);
                      block.eatTrailingWs();
     } else {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case STUFF:
       case BEGIN:
       case END:
       case LBRACE:
       case RBRACE:
       case POUNDPOUND:
       case DOLLAR:
       case QCHAR:
       case SLASH:
       case POUND:
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case BEGIN:
           jj_consume_token(BEGIN);
           break;
         default:
           jj_la1[66] = jj_gen;
           ;
         }
         label_7:
         while (true) {
           switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
           case STUFF:
           case LBRACE:
           case RBRACE:
           case POUNDPOUND:
           case DOLLAR:
           case QCHAR:
           case SLASH:
           case POUND:
             ;
             break;
           default:
             jj_la1[67] = jj_gen;
             break label_7;
           }
           switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
           case STUFF:
           case POUNDPOUND:
           case DOLLAR:
           case QCHAR:
           case SLASH:
           case POUND:
             WMContent(block);
             break;
           case LBRACE:
           case RBRACE:
             switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
             case LBRACE:
               t = jj_consume_token(LBRACE);
               break;
             case RBRACE:
               t = jj_consume_token(RBRACE);
               break;
             default:
               jj_la1[68] = jj_gen;
               jj_consume_token(-1);
               throw new ParseException();
             }
                                       block.addElement(t.image);
             break;
           default:
             jj_la1[69] = jj_gen;
             jj_consume_token(-1);
             throw new ParseException();
           }
         }
         jj_consume_token(END);
                   block.eatTrailingWs();
         break;
       default:
         jj_la1[70] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
     }
     {if (true) return block;}
     throw new Error("Missing return statement in function");
   }
 
   final public BlockBuilder WMDocument() throws ParseException {
   ParserBlockBuilder block = new ParserBlockBuilder();
   Token t;
     label_8:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case STUFF:
       case BEGIN:
       case END:
       case LBRACE:
       case RBRACE:
       case POUNDPOUND:
       case DOLLAR:
       case QCHAR:
       case SLASH:
       case POUND:
         ;
         break;
       default:
         jj_la1[71] = jj_gen;
         break label_8;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case STUFF:
       case POUNDPOUND:
       case DOLLAR:
       case QCHAR:
       case SLASH:
       case POUND:
         WMContent(block);
         break;
       case BEGIN:
       case END:
       case LBRACE:
       case RBRACE:
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case BEGIN:
           t = jj_consume_token(BEGIN);
           break;
         case END:
           t = jj_consume_token(END);
           break;
         case LBRACE:
           t = jj_consume_token(LBRACE);
           break;
         case RBRACE:
           t = jj_consume_token(RBRACE);
           break;
         default:
           jj_la1[72] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
           block.addElement(t.image);
         break;
       default:
         jj_la1[73] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
     }
     jj_consume_token(0);
     {if (true) return block;}
     throw new Error("Missing return statement in function");
   }
 
   final private boolean jj_2_1(int xla) {
     jj_la = xla; jj_lastpos = jj_scanpos = token;
     boolean retval = !jj_3_1();
     jj_save(0, xla);
     return retval;
   }
 
   final private boolean jj_2_2(int xla) {
     jj_la = xla; jj_lastpos = jj_scanpos = token;
     boolean retval = !jj_3_2();
     jj_save(1, xla);
     return retval;
   }
 
   final private boolean jj_2_3(int xla) {
     jj_la = xla; jj_lastpos = jj_scanpos = token;
     boolean retval = !jj_3_3();
     jj_save(2, xla);
     return retval;
   }
 
   final private boolean jj_2_4(int xla) {
     jj_la = xla; jj_lastpos = jj_scanpos = token;
     boolean retval = !jj_3_4();
     jj_save(3, xla);
     return retval;
   }
 
   final private boolean jj_2_5(int xla) {
     jj_la = xla; jj_lastpos = jj_scanpos = token;
     boolean retval = !jj_3_5();
     jj_save(4, xla);
     return retval;
   }
 
   final private boolean jj_2_6(int xla) {
     jj_la = xla; jj_lastpos = jj_scanpos = token;
     boolean retval = !jj_3_6();
     jj_save(5, xla);
     return retval;
   }
 
   final private boolean jj_2_7(int xla) {
     jj_la = xla; jj_lastpos = jj_scanpos = token;
     boolean retval = !jj_3_7();
     jj_save(6, xla);
     return retval;
   }
 
   final private boolean jj_2_8(int xla) {
     jj_la = xla; jj_lastpos = jj_scanpos = token;
     boolean retval = !jj_3_8();
     jj_save(7, xla);
     return retval;
   }
 
   final private boolean jj_2_9(int xla) {
     jj_la = xla; jj_lastpos = jj_scanpos = token;
     boolean retval = !jj_3_9();
     jj_save(8, xla);
     return retval;
   }
 
   final private boolean jj_2_10(int xla) {
     jj_la = xla; jj_lastpos = jj_scanpos = token;
     boolean retval = !jj_3_10();
     jj_save(9, xla);
     return retval;
   }
 
   final private boolean jj_2_11(int xla) {
     jj_la = xla; jj_lastpos = jj_scanpos = token;
     boolean retval = !jj_3_11();
     jj_save(10, xla);
     return retval;
   }
 
   final private boolean jj_3R_36() {
     if (jj_scan_token(OP_LE)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_51() {
     if (jj_scan_token(LBRACKET)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_33() {
     if (jj_scan_token(OP_NE)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3_8() {
     if (jj_scan_token(DOLLAR)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     Token xsp;
     xsp = jj_scanpos;
     if (jj_3R_28()) jj_scanpos = xsp;
     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     xsp = jj_scanpos;
     if (jj_3R_29()) jj_scanpos = xsp;
     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     if (jj_scan_token(WORD)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_16() {
     if (jj_scan_token(OP_MINUS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3_1() {
     if (jj_scan_token(DOLLAR)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_35() {
     if (jj_scan_token(OP_GE)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3_4() {
     Token xsp;
     xsp = jj_scanpos;
     if (jj_3R_19()) jj_scanpos = xsp;
     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     if (jj_3R_20()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     xsp = jj_scanpos;
     if (jj_3R_21()) jj_scanpos = xsp;
     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     if (jj_3R_18()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_38() {
     if (jj_3R_18()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_32() {
     if (jj_scan_token(OP_SET)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_34() {
     if (jj_scan_token(OP_GT)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_15() {
     if (jj_scan_token(OP_PLUS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_31() {
     if (jj_scan_token(OP_EQ)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_50() {
     if (jj_scan_token(QUOTE)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_20() {
     Token xsp;
     xsp = jj_scanpos;
     if (jj_3R_31()) {
     jj_scanpos = xsp;
     if (jj_3R_32()) {
     jj_scanpos = xsp;
     if (jj_3R_33()) {
     jj_scanpos = xsp;
     if (jj_3R_34()) {
     jj_scanpos = xsp;
     if (jj_3R_35()) {
     jj_scanpos = xsp;
     if (jj_3R_36()) {
     jj_scanpos = xsp;
     if (jj_3R_37()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_11() {
     if (jj_scan_token(OP_DIV)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_17() {
     if (jj_scan_token(WS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_14() {
     if (jj_scan_token(WS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3_7() {
     if (jj_scan_token(WORD)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_10() {
     if (jj_scan_token(OP_MULT)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3_3() {
     Token xsp;
     xsp = jj_scanpos;
     if (jj_3R_14()) jj_scanpos = xsp;
     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     xsp = jj_scanpos;
     if (jj_3R_15()) {
     jj_scanpos = xsp;
     if (jj_3R_16()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     xsp = jj_scanpos;
     if (jj_3R_17()) jj_scanpos = xsp;
     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     if (jj_3R_18()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_26() {
     if (jj_scan_token(WS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_18() {
     if (jj_3R_13()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3_11() {
     if (jj_scan_token(LBRACE)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_12() {
     if (jj_scan_token(WS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_9() {
     if (jj_scan_token(WS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_49() {
     if (jj_scan_token(DOLLAR)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_23() {
     if (jj_scan_token(WS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_25() {
     if (jj_scan_token(WS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3_2() {
     Token xsp;
     xsp = jj_scanpos;
     if (jj_3R_9()) jj_scanpos = xsp;
     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     xsp = jj_scanpos;
     if (jj_3R_10()) {
     jj_scanpos = xsp;
     if (jj_3R_11()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     xsp = jj_scanpos;
     if (jj_3R_12()) jj_scanpos = xsp;
     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     if (jj_3R_13()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_13() {
     if (jj_3R_30()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3_10() {
     if (jj_scan_token(LBRACE)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_48() {
     if (jj_scan_token(OP_MINUS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_22() {
     if (jj_scan_token(WS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3_6() {
     Token xsp;
     xsp = jj_scanpos;
     if (jj_3R_25()) jj_scanpos = xsp;
     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     if (jj_scan_token(OP_OR)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     xsp = jj_scanpos;
     if (jj_3R_26()) jj_scanpos = xsp;
     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     if (jj_3R_27()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_47() {
     if (jj_scan_token(NUMBER)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_27() {
     if (jj_3R_24()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_46() {
     if (jj_scan_token(OP_NOT)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_45() {
     if (jj_scan_token(FALSE)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_21() {
     if (jj_scan_token(WS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_44() {
     if (jj_scan_token(TRUE)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_43() {
     if (jj_scan_token(NULL)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_29() {
     if (jj_scan_token(LPAREN)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_42() {
     if (jj_3R_51()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_41() {
     if (jj_3R_50()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_40() {
     if (jj_scan_token(LPAREN)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3_9() {
     if (jj_scan_token(DOLLAR)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_39() {
     if (jj_3R_49()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_37() {
     if (jj_scan_token(OP_LT)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3_5() {
     Token xsp;
     xsp = jj_scanpos;
     if (jj_3R_22()) jj_scanpos = xsp;
     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     if (jj_scan_token(OP_AND)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     xsp = jj_scanpos;
     if (jj_3R_23()) jj_scanpos = xsp;
     else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     if (jj_3R_24()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_30() {
     Token xsp;
     xsp = jj_scanpos;
     if (jj_3R_39()) {
     jj_scanpos = xsp;
     if (jj_3R_40()) {
     jj_scanpos = xsp;
     if (jj_3R_41()) {
     jj_scanpos = xsp;
     if (jj_3R_42()) {
     jj_scanpos = xsp;
     if (jj_3R_43()) {
     jj_scanpos = xsp;
     if (jj_3R_44()) {
     jj_scanpos = xsp;
     if (jj_3R_45()) {
     jj_scanpos = xsp;
     if (jj_3R_46()) {
     jj_scanpos = xsp;
     if (jj_3R_47()) {
     jj_scanpos = xsp;
     if (jj_3R_48()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_24() {
     if (jj_3R_38()) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_28() {
     if (jj_scan_token(DOLLAR)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   final private boolean jj_3R_19() {
     if (jj_scan_token(WS)) return true;
     if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
     return false;
   }
 
   public WMParser_implTokenManager token_source;
   public Token token, jj_nt;
   private int jj_ntk;
   private Token jj_scanpos, jj_lastpos;
   private int jj_la;
   public boolean lookingAhead = false;
   private boolean jj_semLA;
   private int jj_gen;
   final private int[] jj_la1 = new int[74];
   final private int[] jj_la1_0 = {0x10000000,0x10000000,0x20000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x0,0x40000000,0x100000,0x0,0x40000000,0x700000,0x600000,0x10000000,0x0,0x10000000,0x10000000,0x4f100000,0x10000000,0x10000000,0x4f100000,0x10000000,0x0,0x10000000,0x10000000,0x0,0x10000000,0x0,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x10000000,0x40000,0x100000,0xe20800,0xd20800,0xf20800,0xf23800,0x3000,0xf23800,0x1000,0xf2c800,0xc000,0xf2c800,0xf2f800,0xf23800,0x3000,0xf23800,0x1000,0xf2c800,0xc000,0xf2c800,0xf2f800,0xf2f800,0xf000,0xf2f800,};
   final private int[] jj_la1_1 = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x40000,0x80000,0x400000,0x400000,0x0,0x20000,0x0,0x0,0x110801,0x0,0x0,0x110801,0x0,0x3000,0x0,0x0,0xc00,0x0,0x3f8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   final private JJCalls[] jj_2_rtns = new JJCalls[11];
   private boolean jj_rescan = false;
   private int jj_gc = 0;
 
   public WMParser_impl(CharStream stream) {
     token_source = new WMParser_implTokenManager(stream);
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
     for (int i = 0; i < 74; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
   public void ReInit(CharStream stream) {
     token_source.ReInit(stream);
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
     for (int i = 0; i < 74; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
   public WMParser_impl(WMParser_implTokenManager tm) {
     token_source = tm;
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
     for (int i = 0; i < 74; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
   public void ReInit(WMParser_implTokenManager tm) {
     token_source = tm;
     token = new Token();
     jj_ntk = -1;
     jj_gen = 0;
     for (int i = 0; i < 74; i++) jj_la1[i] = -1;
     for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
   }
 
   final private Token jj_consume_token(int kind) throws ParseException {
     Token oldToken;
     if ((oldToken = token).next != null) token = token.next;
     else token = token.next = token_source.getNextToken();
     jj_ntk = -1;
     if (token.kind == kind) {
       jj_gen++;
       if (++jj_gc > 100) {
         jj_gc = 0;
         for (int i = 0; i < jj_2_rtns.length; i++) {
           JJCalls c = jj_2_rtns[i];
           while (c != null) {
             if (c.gen < jj_gen) c.first = null;
             c = c.next;
           }
         }
       }
       return token;
     }
     token = oldToken;
     jj_kind = kind;
     throw generateParseException();
   }
 
   final private boolean jj_scan_token(int kind) {
     if (jj_scanpos == jj_lastpos) {
       jj_la--;
       if (jj_scanpos.next == null) {
         jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
       } else {
         jj_lastpos = jj_scanpos = jj_scanpos.next;
       }
     } else {
       jj_scanpos = jj_scanpos.next;
     }
     if (jj_rescan) {
       int i = 0; Token tok = token;
       while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
       if (tok != null) jj_add_error_token(kind, i);
     }
     return (jj_scanpos.kind != kind);
   }
 
   final public Token getNextToken() {
     if (token.next != null) token = token.next;
     else token = token.next = token_source.getNextToken();
     jj_ntk = -1;
     jj_gen++;
     return token;
   }
 
   final public Token getToken(int index) {
     Token t = lookingAhead ? jj_scanpos : token;
     for (int i = 0; i < index; i++) {
       if (t.next != null) t = t.next;
       else t = t.next = token_source.getNextToken();
     }
     return t;
   }
 
   final private int jj_ntk() {
     if ((jj_nt=token.next) == null)
       return (jj_ntk = (token.next=token_source.getNextToken()).kind);
     else
       return (jj_ntk = jj_nt.kind);
   }
 
   private java.util.Vector jj_expentries = new java.util.Vector();
   private int[] jj_expentry;
   private int jj_kind = -1;
   private int[] jj_lasttokens = new int[100];
   private int jj_endpos;
 
   private void jj_add_error_token(int kind, int pos) {
     if (pos >= 100) return;
     if (pos == jj_endpos + 1) {
       jj_lasttokens[jj_endpos++] = kind;
     } else if (jj_endpos != 0) {
       jj_expentry = new int[jj_endpos];
       for (int i = 0; i < jj_endpos; i++) {
         jj_expentry[i] = jj_lasttokens[i];
       }
       boolean exists = false;
       for (java.util.Enumeration enum = jj_expentries.elements(); enum.hasMoreElements();) {
         int[] oldentry = (int[])(enum.nextElement());
         if (oldentry.length == jj_expentry.length) {
           exists = true;
           for (int i = 0; i < jj_expentry.length; i++) {
             if (oldentry[i] != jj_expentry[i]) {
               exists = false;
               break;
             }
           }
           if (exists) break;
         }
       }
       if (!exists) jj_expentries.addElement(jj_expentry);
       if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
     }
   }
 
   final public ParseException generateParseException() {
     jj_expentries.removeAllElements();
     boolean[] la1tokens = new boolean[55];
     for (int i = 0; i < 55; i++) {
       la1tokens[i] = false;
     }
     if (jj_kind >= 0) {
       la1tokens[jj_kind] = true;
       jj_kind = -1;
     }
     for (int i = 0; i < 74; i++) {
       if (jj_la1[i] == jj_gen) {
         for (int j = 0; j < 32; j++) {
           if ((jj_la1_0[i] & (1<<j)) != 0) {
             la1tokens[j] = true;
           }
           if ((jj_la1_1[i] & (1<<j)) != 0) {
             la1tokens[32+j] = true;
           }
         }
       }
     }
     for (int i = 0; i < 55; i++) {
       if (la1tokens[i]) {
         jj_expentry = new int[1];
         jj_expentry[0] = i;
         jj_expentries.addElement(jj_expentry);
       }
     }
     jj_endpos = 0;
     jj_rescan_token();
     jj_add_error_token(0, 0);
     int[][] exptokseq = new int[jj_expentries.size()][];
     for (int i = 0; i < jj_expentries.size(); i++) {
       exptokseq[i] = (int[])jj_expentries.elementAt(i);
     }
     return new ParseException(token, exptokseq, tokenImage);
   }
 
   final public void enable_tracing() {
   }
 
   final public void disable_tracing() {
   }
 
   final private void jj_rescan_token() {
     jj_rescan = true;
     for (int i = 0; i < 11; i++) {
       JJCalls p = jj_2_rtns[i];
       do {
         if (p.gen > jj_gen) {
           jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
           switch (i) {
             case 0: jj_3_1(); break;
             case 1: jj_3_2(); break;
             case 2: jj_3_3(); break;
             case 3: jj_3_4(); break;
             case 4: jj_3_5(); break;
             case 5: jj_3_6(); break;
             case 6: jj_3_7(); break;
             case 7: jj_3_8(); break;
             case 8: jj_3_9(); break;
             case 9: jj_3_10(); break;
             case 10: jj_3_11(); break;
           }
         }
         p = p.next;
       } while (p != null);
     }
     jj_rescan = false;
   }
 
   final private void jj_save(int index, int xla) {
     JJCalls p = jj_2_rtns[index];
     while (p.gen > jj_gen) {
       if (p.next == null) { p = p.next = new JJCalls(); break; }
       p = p.next;
     }
     p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
   }
 
   static final class JJCalls {
     int gen;
     Token first;
     int arg;
     JJCalls next;
   }
 
 }
