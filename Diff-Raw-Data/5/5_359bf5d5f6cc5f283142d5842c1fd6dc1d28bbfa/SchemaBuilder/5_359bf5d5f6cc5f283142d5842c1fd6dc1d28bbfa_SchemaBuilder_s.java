 /* *****************************************************************************
  * SchemaBuilder.java
  * ****************************************************************************/
 
 /* J_LZ_COPYRIGHT_BEGIN *******************************************************
 * Copyright 2008 Laszlo Systems, Inc.  All Rights Reserved.                   *
 * Use is subject to license terms.                                            *
 * J_LZ_COPYRIGHT_END *********************************************************/
 
 package org.openlaszlo.js2doc;
 
 import java.io.*;
 import java.util.*;
 import java.util.logging.*;
 import org.openlaszlo.js2doc.JS2DocUtils.InternalError;
 import org.openlaszlo.server.LPS;
 import org.w3c.dom.*;
 import javax.xml.xpath.*;
 import org.apache.xpath.NodeSet;
 
 // TODO: handle initargs, e.g. this from canvas:
 //  * @initarg Boolean accessible: Specifies if this application is intended to be accessible
 //  * @initarg Boolean debug: If true, the application is compiled with debugging enabled.
 //
 // should appear as:
 //  <attribute name="debug" type="boolean" value="false"/>
 //  <attribute name="accessible" type="boolean" value="false"/>
 //
 // Unfortunately, initargs seem 'unstructured', here are various examples:
 //   @initarg secureport
 //   @initarg deprecated port
 //   @initarg Number thickness (swf8 only)
 //   @initarg public String resource: A string denoting the library resource to use...
 //
 // We'd probably need to more sharply define the syntax of @initargs and clean up
 // all the usages
 
 
 // TODO: We are NOT looking for classname.setXXX (setters)
 //   or the newer form $lzc$set_apply() from the javadocs.
 //   Should we, and indicate them as attributes?
 
 /**
   * Builds a specialized schema for lfc,
   * invoked via the --schema option.
   * This uses the parsed internal XML doc tree and
   * generates the schema in a specialized XML format.
   */
 public class SchemaBuilder {
 
     static private Logger logger = Logger.getLogger("org.openlaszlo.js2doc");
 
     public static final String INITIAL_COMMENT = "\n\n" +
         "       !!!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!!\n\n" +
         "       This file was created by js2doc.SchemaBuilder.\n" +
         "       Contents can be modified by editing lfc-undeclared.lzx.\n";
 
     private Element droot;
     private TreeMap jsClasses = new TreeMap(); // key is name
     private TreeMap jsClassesOrdered = new TreeMap(); // key is contrived for ordering
     private XPathFactory xpathFactory=XPathFactory.newInstance();
     private XPath xPath = xpathFactory.newXPath();
 
     private XPathExpression TagNameModifiersXpr;
 
     private Element mergeSchema = null;
     private String mergeName = null;
 
     /** A class seen in the input */
     public static class JsClass {
         String jsname;
         String access;
         String lzxname;
         String extname;
         Element classnode;
     }
 
     // values of 'kind' argument to addMember()
     public static final String MEMBER_ATTRIBUTE = "attribute";
     public static final String MEMBER_METHOD = "method";
     public static final String MEMBER_EVENT = "event";
 
     /** A member of a class seen in the input.
      * This may be a method, event or attribute.
      */
     public static class JsMember {
         String name;
         String type = null;         // only used for attribute, otherwise null
         String defaultvalue = null; // only used for attribute (but optional), otherwise null
         String enumvalues = null;   // If attribute is enum, this is a '|' separated list
         boolean isfinal;
         boolean isstatic;
     }
 
     public class SchemaBuilderError extends RuntimeException {
         public SchemaBuilderError(String s) {
             super("Error building schema: " + s);
         }
     }
 
     /**
      * Initialize the SchemaBuilder using the document root.
      */
     public SchemaBuilder(Element droot) {
         this.droot = droot;
     }
 
     /**
      * Get the data string associated with a Text element.
      */
     private String getTextData(Element textElement) {
         if (textElement == null) {
             return null;
         }
         Node ch = textElement.getFirstChild();
         if (ch == null || !(ch instanceof Text)) {
             return null;
         }
         else {
             return ((Text)ch).getData();
         }
     }
 
     /**
      * Create an return a new child tag beneath an existing node.
      */
     private Element createChild(Node n, String tagname) {
         return (Element)n.appendChild(n.getOwnerDocument().createElement(tagname));
     }
 
     /**
      * Precompile xpath expressions that are used frequently.
      */
     private void compileXpathExpressions()
         throws XPathExpressionException {
         TagNameModifiersXpr = xPath.compile("tag[@name='modifiers']");
     }
 
     /**
      * Create a key that guarantees that superclasses appear first.
      * <pre>
      * class:                        key:
      *  Bar                           "Bar"
      *  Foo extends Bar               "Bar.Foo"
      *  Aha extends Foo extends Bar   "Bar.Foo.Aha"
      * </pre>
      */
     public String getOrderedKey(JsClass j) {
         JsClass sup = (j.extname == null) ? null : 
             (JsClass)jsClasses.get(j.extname);
         if (sup == null) {
             return j.jsname;
         }
         else {
             return getOrderedKey(sup) + "." + j.jsname;
         }
     }
 
     public void addSchemaToMerge(String filename, Element merge) {
         this.mergeName = filename;
         this.mergeSchema = merge;
     }
 
     /**
      * Just pull the Element children.  If there are
      * unexpected other nodes (anything other than
      * whitespace Text nodes and Comment nodes), throw
      * an exception.
      */
     public Element[] getChildElements(Element el) {
         List list = new ArrayList();
         NodeList children = el.getChildNodes();
         for (int count=children.getLength(), i=0; i<count; i++) {
             Node n = children.item(i);
             if (n instanceof Element) {
                 list.add(n);
             }
             else if (n instanceof org.w3c.dom.Text) {
                 String str = ((Text)n).getData();
                 if (str.trim().length() > 0) {
                     throw new SchemaBuilderError(position(n) + "unexpected text \"" +
                                                  str + "\" beneath " + el);
                 }
             }
             else if (n instanceof org.w3c.dom.Comment) {
                 //ignored
             }
             else {
                 throw new SchemaBuilderError(position(n) + "unexpected node " +
                                              n + "(" + n.getClass().getName() + ") child of " + el);
             }
         }
         return (Element[])list.toArray(new Element[0]);
     }
 
     String position(Node n) {
         String pos = mergeName + ": ";
         // TODO: no way to get an input line number from a node?
 
         String path = showpath(n);
         if (path.length() > 0) {
             path += ": ";
         }
         return pos + path;
     }
 
     Element getSingleChild(Element el) {
         String tagname = el.getTagName();
         Element[] children = getChildElements(el);
         if (children.length != 1) {
             if (children.length > 1) {
                 String got = "";
                 for (int i=0; i< children.length; i++) {
                     if (i > 0) {
                         got += ", ";
                     }
                     if (i > 2) {
                         break;
                     }
                     got += children[i];
                 }
                 throw new SchemaBuilderError(position(el) + "each <" + tagname +
                                              "> may have only one child node, got: " + got);
             } else {
                 throw new SchemaBuilderError(position(el) + "each <" + tagname +
                                              "> must have a single child node");
             }
         }
         return children[0];
     }
 
     Element getMatchingElement(Element el, Element match) {
         String tagname = match.getTagName();
         String name = match.getAttribute("name");
         String xpath = tagname;
         if (name != null) {
             xpath += "[@name = \"" + name + "\"]";
         }
 
         //System.out.println("xpath=\"" + xpath + "\": matching against " + show(el));
         try {
             return (Element)xPath.evaluate(xpath, el,
                                            XPathConstants.NODE);
         }
         catch (XPathExpressionException e) {
             throw new InternalError(e);
         }
 
     }
 
     String show(Element el) {
         String name = el.getAttribute("name");
         if (name == null) {
             name = "";
         }
         else {
             name = " name=\"" + name + "\"";
         }
         return "<" + el.getTagName() + name + ">";
     }
 
     String showpath(Node n) {
         String path = "";
         while (n != null) {
             if (n instanceof Element) {
                 Element el = (Element)n;
                 String name = el.getAttribute("name");
                 if (name == null || name.length() == 0) {
                     name = "";
                 }
                 else {
                     name = " \"" + name + "\"";
                 }
                 path = "/" + el.getTagName() + name + path;
             }
             n = n.getParentNode();
         }
         return path;
     }
 
     /**
      * Insert the new node under the parent.
      * If ordering under the parent is important (e.g. for <interface> dependencies),
      * that is handled here.
      */
     public void insertChild(Element parent, Element newnode) {
         // The new node is not from the same document from the parent
         // so it needs to be imported.
         Element n = (Element)parent.getOwnerDocument().importNode(newnode, true);
         if ("interface".equals(n.getTagName())) {
             String extend = n.getAttribute("extends");
 
             // TODO: find the best 'sorted' spot, or resort the result.
             //   right now, we put Object at the front and everything else at the end.
             //   This happens to work with what we have in lfc-undefined.lzx, but is fragile.
             //
             if ("Object".equals(extend)) {
                 parent.insertBefore(n, parent.getFirstChild());
             }
             else {
                 parent.appendChild(n);
             }
         }
         else {
             parent.appendChild(n);
         }
     }
 
     public void replaceChild(Element parent, Element newnode, Element orignode) {
         Node n = parent.getOwnerDocument().importNode(newnode, true);
         parent.replaceChild(n, orignode);
     }
 
     public void merge(Element orig, Element merge) {
         Element[] children = getChildElements(merge);
         for (int i=0; i<children.length; i++) {
             Element mergeel = children[i];
             String tagname = mergeel.getTagName();
             if (tagname.equals("insert")) {
                 Element[] subchildren = getChildElements(mergeel);
                 for (int j=0; j<subchildren.length; j++) {
                     Element sub = subchildren[j];
                     Element origel = getMatchingElement(orig, sub);
                     if (origel == null) {
                         insertChild(orig, sub);
                     }
                     else {
                         throw new SchemaBuilderError(show(sub) + " in <insert> matches an existing element: " + showpath(origel));
                     }
                 }
             }
             else if (tagname.equals("replace")) {
                 Element[] subchildren = getChildElements(mergeel);
                 for (int j=0; j<subchildren.length; j++) {
                     Element sub = subchildren[j];
                     Element origel = getMatchingElement(orig, sub);
                     if (origel == null) {
                         throw new SchemaBuilderError(show(sub) + " in <replace> does not match an existing element under " + showpath(orig));
                     }
                     else {
                         replaceChild(orig, sub, origel);
                     }
                 }
             }
             else if (tagname.equals("delete")) {
                 Element[] subchildren = getChildElements(mergeel);
                 for (int j=0; j<subchildren.length; j++) {
                     Element sub = subchildren[j];
                     Element origel = getMatchingElement(orig, sub);
                     if (origel == null) {
                         throw new SchemaBuilderError(show(sub) + " in <delete> does not match an existing element under " + showpath(orig));
                     }
                     else {
                         orig.removeChild(origel);
                     }
                 }
             }
             else {              // merge with existing node, recursively
                 Element origel = getMatchingElement(orig, mergeel);
                 if (origel == null) {
                     throw new SchemaBuilderError(show(mergeel) + " does not match an existing element under " + showpath(orig));
                 }
                 else {
                     merge(origel, mergeel);
                 }
             }
         }
     }
 
     /**
      * Top level method to build the XML output from the
      * parsed XML input tree.
      */
     public void build(Element sroot) {
         try {
             compileXpathExpressions();
 
             String versionstr = LPS.getVersion() + "|" +
                 LPS.getRelease() + "|" +
                 LPS.getBuild() + "|" +
                 LPS.getBuildDate();
 
             sroot.setAttribute("version", versionstr);
 
             // Walk the set of nodes that correspond to classes
             // to collect their names and position in the input XML tree.
             NodeList nodes = (NodeList)xPath.evaluate("/js2doc/property/doc/tag[@name='lzxname']/text", droot, XPathConstants.NODESET);
             for (int count=nodes.getLength(), i=0; i<count; i++) {
                 Element elzxname = (Element) nodes.item(i);
                 Element eprop = (Element)elzxname.getParentNode().getParentNode().getParentNode();
                 Element classNode = (Element)xPath.evaluate("class", eprop, XPathConstants.NODE);
                 // TODO: we currently say:
                 //   if the class doesn't have access, get it from the unitid.
                 //   If an element in the class doesn't have access, get it from the class.
                 // A slightly different approach, but one which I think matches the doc is:
                 //   if the class doesn't have access, get it from the unitid.
                 //   If an element in the class doesn't have access, get it from the *unitid*.
                 // TODO: test this difference, and if so, implement it.
                 // 
                 if (classNode != null) {
                     JsClass j = new JsClass();
                     j.jsname = eprop.getAttribute("name");
                     j.access = eprop.getAttribute("access");
                     if (j.access == null) {
                         String unitid = eprop.getAttribute("unitid");
                         if (unitid != null) {
                             Element unitNode = (Element)xPath.evaluate("/js2doc/unit[id='" + unitid + "']", droot, XPathConstants.NODE);
                             if (unitNode != null) {
                                 j.access = unitNode.getAttribute("access");
                             }
                         }
                     }
                     j.lzxname = getTextData(elzxname);
                     j.extname = classNode.getAttribute("extends");
                     j.classnode = classNode;
                     jsClasses.put(j.jsname, j);
                 }
             }
 
             //
             // The reader of this schema file needs the
             // classes ordered so that no class is used as a superclass
             // before it is defined.  Use a different tree to
             // hold that ordering.  We do that after seeing
             // all the classes so we know the complete inheritance chains.
             for (Iterator iter = jsClasses.keySet().iterator(); iter.hasNext(); ) {
                 JsClass j = (JsClass)jsClasses.get(iter.next());
                 jsClassesOrdered.put(getOrderedKey(j), j);
             }
 
             // Walk the classes, and for each one, pull out its
             // methods, events, attrs
             for (Iterator iter = jsClassesOrdered.keySet().iterator(); iter.hasNext(); ) {
                 JsClass j = (JsClass)jsClassesOrdered.get(iter.next());
                 Element iface = createChild(sroot, "interface");
                 iface.setAttribute("name", j.lzxname);
                 String lzxExtends = "Instance";
                 if (j.extname != null) {
                     JsClass extj = (JsClass)jsClasses.get(j.extname);
                     if (extj != null) {
                         lzxExtends = extj.lzxname;
                     }
                 }
                 iface.setAttribute("extends", lzxExtends);
 
                 TreeMap methods = new TreeMap();
                 TreeMap events = new TreeMap();
                 TreeMap attrs = new TreeMap();
 
                 addMethods(methods, j, true);
                 addMethods(methods, j, false);
                 addEvents(events, j);
 
                 addAttributes(attrs, j, true);
                 addAttributes(attrs, j, false);
 
                 // Put the found class members into the output XML
                 createMembers(methods, iface, "method");
                 createMembers(events, iface, "event");
                 createMembers(attrs, iface, "attribute");
             }
             if (mergeSchema != null) {
                 merge(sroot, mergeSchema);
             }
             sroot.insertBefore(sroot.getOwnerDocument().createComment(INITIAL_COMMENT), sroot.getFirstChild());
         }
         catch (XPathExpressionException e) {
             throw new InternalError(e);
         }
     }
 
     /**
      * Add any methods to the treemap.
      */
     protected void addMethods(TreeMap methods, JsClass jsclass,
                               boolean classMethods)
         throws XPathExpressionException
     {
         String path = classMethods ? "property/function" : 
             "property/object/property/function";
 
         NodeList nodes = (NodeList)xPath.evaluate(path, jsclass.classnode,
                                                   XPathConstants.NODESET);
         for (int count=nodes.getLength(), i=0; i<count; i++) {
             JsMember member = addMember(MEMBER_METHOD, (Element) nodes.item(i).getParentNode(), jsclass, classMethods);
             if (member != null) {
                 // ignore constructors
                 if (!member.name.equals(jsclass.jsname)) {
                     methods.put(member.name, member);
                 }
             }
         }
     }
 
     /**
      * Add any events to the treemap.
      */
     protected void addEvents(TreeMap events, JsClass jsclass)
         throws XPathExpressionException
     {
         String path = "property/object/property[((doc/tag[@name='lzxtype']/text) = 'event')]";
 
         NodeList nodes = (NodeList)xPath.evaluate(path, jsclass.classnode,
                                                   XPathConstants.NODESET);
         for (int count=nodes.getLength(), i=0; i<count; i++) {
             Element eprop = (Element)nodes.item(i);
             JsMember member = addMember(MEMBER_EVENT, eprop, jsclass, false);
             if (member != null) {
                 events.put(member.name, member);
             }
         }
     }
 
     /**
      * Add any attributes to the treemap.
      */
     protected void addAttributes(TreeMap attrs, JsClass jsclass,
                                  boolean classAttrs)
         throws XPathExpressionException
     {
         String path = classAttrs ? "property[doc]" : 
             "property[@name='__ivars__']/object/property";
 
         NodeList nodes = (NodeList)xPath.evaluate(path, jsclass.classnode,
                                                   XPathConstants.NODESET);
         for (int count=nodes.getLength(), i=0; i<count; i++) {
             Element eprop = (Element)nodes.item(i);
             // Our query for attributes can pick up events too.
             String lzxtype = getTextData((Element)xPath.evaluate("doc/tag[@name='lzxtype']/text", eprop, XPathConstants.NODE));
             String lzxdefault = getTextData((Element)xPath.evaluate("doc/tag[@name='lzxdefault']/text", eprop, XPathConstants.NODE));
             // TODO: consider using "event".equals(lzxtype)?
             Boolean isEvent = (Boolean)xPath.evaluate("(doc/tag[@name='lzxtype']/text) = 'event'", eprop, XPathConstants.BOOLEAN);
             if (isEvent.booleanValue()) {
                 continue;
             }
             // Our query for class attributes can pick up functions too.
             Boolean isFunction = (Boolean)xPath.evaluate("function", eprop, XPathConstants.BOOLEAN);
             if (isFunction.booleanValue()) {
                 continue;
             }
             JsMember member = addMember(MEMBER_ATTRIBUTE, eprop, jsclass, classAttrs);
             if (member != null) {
                 member.type = lzxtype;
                 if (lzxdefault != null) {
                     member.defaultvalue = convertDefaultValue(lzxdefault);
                 }
                 if (member.type == null || member.type.equals("")) {
                     member.type = eprop.getAttribute("type");
                 }
                 if (member.type != null && !"".equals(member.type)) {
                     member.type = convertAttributeType(eprop, member.type);
                     if (member.type.indexOf('|') >= 0) {
                         member.enumvalues = member.type;
                         member.type = "string";
                     }
                 }
                 else {
                     member.type = null;
                 }
                 if (member.type == null) {
 
                     System.err.println("Warning: attribute " + jsclass.jsname + "." + member.name + " has no @lzxtype or @type in javadoc, needed for schema");
                 }
                 attrs.put(member.name, member);
             }
         }
     }
 
     /**
      * Create and initialize a JsMember (method/attribute/event),
      * from the given property node.
      */
     protected JsMember addMember(String kind, Element eprop, JsClass jsclass, boolean isstatic)
         throws XPathExpressionException
     {
         String access = eprop.getAttribute("access");
         JsMember member = null;
         if (access == null) {
             access = jsclass.access;
         }
         if (access == null) {
             System.err.println("Warning: access is unknown for " + jsclass.jsname + "." + eprop.getAttribute("name"));
         }
         // Note: we need to include methods that are marked private in doc,
         // because if they are redefined, they must be marked as 'override'.
         if (kind.equals(MEMBER_METHOD) || !"private".equals(access)) {
             member = new JsMember();
             member.name = eprop.getAttribute("name");
             member.isfinal = isFinal(eprop);
             member.isstatic = isstatic;
         }
         return member;
     }
 
     /**
      * True if the member is marked 'final'.
      */
     protected boolean isFinal(Element eprop)
         throws XPathExpressionException
     {
         // Modifiers can exist as attributes on the property containing
         // function and also as <tag name="modifiers"> nodes under property.
         String mods = eprop.getAttribute("modifiers");
         if (mods == null) {
             mods = "";
         }
         Element emod = (Element)TagNameModifiersXpr.evaluate(eprop, XPathConstants.NODE);
         if (emod != null) {
             String modtext = getTextData(emod);
             if (modtext != null) {
                 mods += " " + modtext;
             }
         }
         //TODO: Can't final also appear as:  <tag name="modifiers"><text>final</text></tag>
         // TODO: how are multiple modifiers delimited?
         return (mods != null && mods.contains("final"));
     }
 
     /**
      * Given a map of JsMembers, create them all within the interface.
      */
     protected void createMembers(TreeMap methods, Element iface, String tag) {
         for (Iterator iter = methods.keySet().iterator(); iter.hasNext(); ) {
             JsMember member = (JsMember)methods.get(iter.next());
             createMember(iface, member, tag);
         }
     }
 
     /**
      * Given a JsMember, create it within the interface.
      */
     protected void createMember(Element iface, JsMember member, String tag) {
         Element emember = createChild(iface, tag);
         emember.setAttribute("name", member.name);
         if (member.isfinal) {
             emember.setAttribute("final", "true");
         }
         if (member.type != null) {
             emember.setAttribute("type", member.type);
         }
         if (member.enumvalues != null) {
             emember.setAttribute("enum", member.enumvalues);
         }
         if (member.defaultvalue != null) {
             emember.setAttribute("value", member.defaultvalue);
         }
         if (member.isstatic) {
             emember.setAttribute("allocation", "class");
         }
     }
 
     /**
      * A type found in doc may need to be converted to
      * a different naming convention for the output schema format.
      * TODO: is there a good reason for this, maybe we should
      * generally use the type found in the doc, and teach the reader
      * of lfc.lzx to know those types.
      */
     String convertAttributeType(Element el, String s) {
         String result = null;
         if (s.indexOf('|') >= 0) {
             result = s.replaceAll("\"", "").replaceAll("'", "").replaceAll(" ", "");
             // special case: booleanLiteral|'inherit' becomes inheritableBoolean
             if ("booleanLiteral|inherit".equals(result)) {
                 result = "inheritableBoolean";
             }
         } else if ("String".equals(s)) {
             result = "string";
         } else if ("Number".equals(s) || "integer".equals(s) || "uint".equals(s)) {
             result = "number";
         } else if ("Boolean".equals(s)) {
             result = "boolean";
         } else if ("booleanLiteral".equals(s)) {
             result = "boolean";   // TODO: not exactly true, but this is what appears in the schema...
         } else if ("sizeExpression".equals(s)) {
             result = "size";
         } else if ("Array".equals(s) ||
                    "LzDataNodeMixin".equals(s) ||
                    "LzDelegate".equals(s) ||
                    "LzNode".equals(s) ||
                    "LzParam".equals(s) ||
                    "LzView".equals(s) ||
                    "Object".equals(s) ||
                    "[LzView]".equals(s) ||
                    "[String]".equals(s) ||
                    "DisplayKeys".equals(s) ||
                    "Dictionary".equals(s)) {
             // TODO: these have no good alternative!
             result = "string";
         } else if ("ID".equals(s) ||
                    "boolean".equals(s) ||
                    "color".equals(s) ||
                    "css".equals(s) ||
                    "expression".equals(s) ||
                    "inheritableBoolean".equals(s) ||
                    "number".equals(s) ||
                    "numberExpression".equals(s) ||
                    "reference".equals(s) ||
                    "size".equals(s) ||
                    "string".equals(s) ||
                    "token".equals(s)) {
             result = s;
         } else {
             throw new SchemaBuilderError(position(el) + "type \"" +
                                          s + "\" not supported by schema builder");
         }
         return result;
     }
 
     String convertDefaultValue(String s) {
         return s.replaceAll("\"", "").replaceAll("'", "");
     }
 
     /**
      * For debugging, show the given tree as XML.
      */
     private void showNodeTree(Element e, String prefix)
     {
         System.out.print(prefix + "<" + e.getTagName());
         NamedNodeMap attrs = e.getAttributes();
         for (int i=0; i<attrs.getLength(); i++) {
             Node n = attrs.item(i);
             System.out.print(" " + n.getNodeName() + "='" + n.getNodeValue() + "'");
         }
         System.out.println(">");
         NodeList children = e.getChildNodes();
         for (int i=0; i<children.getLength(); i++) {
             Node n = children.item(i);
             if (n instanceof Element) {
                 showNodeTree((Element)n, prefix + "  ");
             }
         }
         System.out.println(prefix + "</" + e.getTagName() + ">");
     }
 }
