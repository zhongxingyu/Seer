 /**
  * SnakeRun
  * 
  * @package FIS
  * @author Jyrki Lilja
  */
 
 package com.laserinne.snakerun;
 
 import java.util.ArrayList;
 
 import blobDetection.Blob;
 import blobDetection.BlobDetection;
 import blobDetection.EdgeVertex;
 
 import com.laserinne.util.Mover;
 import com.laserinne.util.SkierContestant;
 import com.laserinne.util.RandomWalkOscillator;
 
 import geomerative.RFont;
 import geomerative.RG;
 import laserschein.Laser3D;
 import laserschein.Laserschein;
 import processing.core.PApplet;
 import processing.core.PGraphics;
 import processing.core.PImage;
 import processing.core.PVector;
 import processing.opengl.PGraphicsOpenGL;
 
 public class SnakeRun extends PApplet {
     /**
      * Generated by Jyrki Lilja on 2011-08-09 11.01
      */
     private static final long serialVersionUID = -6130751878909898451L;
     
     private boolean laserOn = false;
     
     private Laserschein laser;
     private Laser3D renderer;
     
     private Mover leftSnake,
                   rightSnake;
     private ArrayList<PVector> leftPoints,
                                rightPoints;
     private SkierContestant leftSkier,
                             rightSkier;
     private RFont font;
     
     /**
      * @field pg renders the snakes here
      */
     private PGraphics pg;
     /**
      * @field img used to detect contours
      */
     private PImage img;
     private BlobDetection bd;
     
     private static final int FINISH_LINE = 400;
     private static final int WIDTH = 640;
     private static final int HEIGHT = 480;
     
     public static final int LASER_COLOR = 0xFFFF0000;
     public static final int SCREEN_COLOR = 0xFF0000FF;
     
     public static final int NUM_FOLLOWERS = 50;
     
     /**
      * main
      * 
      * This has to be commented out when running in Processing to allow font
      * loading, but available when running in Eclipse or building with Ant /
      * exporting to application from Processing or building with Ant.
      */
     public static void main(String args[]) {
          PApplet.main(new String[] { com.laserinne.snakerun.SnakeRun.class.getName() });
     }
     
     public void setup() {
         size(SnakeRun.WIDTH, SnakeRun.HEIGHT, PGraphicsOpenGL.OPENGL);
         frameRate(-1); // Use maximum frame rate.
         laser = new Laserschein(this, Laserschein.EASYLASEUSB2);
         renderer = laser.renderer();
         
         smooth();
         
         colorMode(RGB);
         stroke(SnakeRun.SCREEN_COLOR);
         noFill();
         
         // Create the snakes
         leftSnake = new Mover(width / 4, 0, this);
         leftSnake.addFollowers(SnakeRun.NUM_FOLLOWERS);
         rightSnake = new Mover(width * 3 / 4, 0, this);
         rightSnake.addFollowers(SnakeRun.NUM_FOLLOWERS);
         // Create paths
         leftPoints = new ArrayList<PVector>();
         rightPoints = new ArrayList<PVector>();
         generatePaths();
         // Assign paths to snakes
         leftSnake.targets(leftPoints);
         rightSnake.targets(rightPoints);
         
         // Initialize fake skiers
         leftSkier = new SkierContestant(width / 4, 0, this);
         leftSkier.finishLine(SnakeRun.FINISH_LINE);
         rightSkier = new SkierContestant(width * 3 / 4, 0, this);
         rightSkier.finishLine(SnakeRun.FINISH_LINE);
         
         RG.init(this);
         font = new RFont("Laserfont.ttf", 80, RFont.CENTER);
         
         pg = createGraphics(width, height, PGraphics.P2D);
         img = new PImage(60, 60);
         bd = new BlobDetection(img.width, img.height);
         bd.setPosDiscrimination(true);
         bd.setThreshold(0.1f);
     }
     
     public void draw() {
         background(0);
         stroke(SnakeRun.SCREEN_COLOR);
         
         // float cameraZ = (float) ((height/2.0) / Math.tan(PI * 60.0 / 360.0));
         // perspective(PI / 3.0, width/height, cameraZ/10.0, cameraZ*10.0);
         
         float eyeX = width / 2.0f,
               eyeY = height / 2.0f,
               eyeZ = (float) ((height / 2.0) / Math.tan(PI * 60.0 / 360.0)),
               centerX = width / 2.0f,
               centerY = height / 2.0f,
               centerZ = 0,
               upX = 0,
               upY = 1,
               upZ = 0;
         camera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ);
         
         // rotateX(-PI * 1 / 3);
         
         // Draw FPS on screen
         pushMatrix();
         translate(30, 80);
         font.setAlign(RFont.LEFT);
         font.draw(new Integer(Math.round(frameRate)).toString());
         popMatrix();
         
         drawPath(leftPoints);
         drawPath(rightPoints);
         
         line(width / 4, 0, width / 4, height);
         line(width / 2, 0, width / 2, height);
         line(width * 3 / 4, 0, width * 3 / 4, height);
         
         if (laserOn) {
             if (leftSkier.finished())
                 leftSnake.stop();
             if (rightSkier.finished())
                 rightSnake.stop();
             
             leftSnake.update();
             rightSnake.update();
             
             pg.beginDraw();
             pg.background(0);
             pg.loadPixels();
             pg.stroke(255);
             pg.fill(255);
             leftSnake.draw(pg);
             rightSnake.draw(pg);
             pg.updatePixels();
             pg.endDraw();
             
             // Now, we have to threshold the image, and DETECT A CONTOUR:
             // first, copy on the small image:
             img.copy(pg, 0, 0, pg.width, pg.height, 0, 0, img.width, img.height);
             //detect the contours:
             bd.computeBlobs(img.pixels);
             
             stroke(SnakeRun.LASER_COLOR);
             beginRaw(renderer);
             drawBlobsAndEdges(false, true);
             endRaw();
             stroke(SnakeRun.SCREEN_COLOR);
             
             handleSkier(leftSkier, leftSnake);
             // handleSkier(rightSkier, rightSnake);
             
             //image(pg, 0, 0, width, height);
         }
     }
     private void drawBlobsAndEdges(boolean drawBlobs, boolean drawEdges) {
         Blob b;
         EdgeVertex eA, eB;
         for (int n = 0; n < bd.getBlobNb(); n++) {
             b = bd.getBlob(n);
             if (b != null) {
                 // Blobs
                 if (drawBlobs) {
                     rect(
                         b.xMin * width, b.yMin * height,
                         b.w * width, b.h * height
                         );
                 }
                 // Edges
                 if (drawEdges) {
                     for (int m = 0; m < b.getEdgeNb(); m++) {
                         eA = b.getEdgeVertexA(m);
                         eB = b.getEdgeVertexB(m);
                         if (eA != null && eB != null)
                             line(
                                 eA.x * width, eA.y * height, 
                                 eB.x * width, eB.y * height
                                 );
                     }
                 }
             }
         }
     }
     private void handleSkier(SkierContestant skier, Mover snakeHead) {
         skier.update();
         int followerCount = snakeHead.followerCount(),
             /**
              * Allow the skier to be between 1 / 2 and 2 / 3 of the snake. If
             * the skier is faster accelerate the snake and vice versa.
              */
             lastAllowedIndex = followerCount * 2 / 3,
             firstAllowedIndex = followerCount * 1 / 2;
         Mover m = snakeHead;
         boolean skierInSnake = false;
         stroke(SnakeRun.SCREEN_COLOR);
         while (m.follower() != null) {
             if (m.closeTo(new PVector(skier.getX(), skier.getY()), 10)) {
                 if (m.index() > lastAllowedIndex) {
                     snakeHead.changeTopSpeed(-0.02f);
                 }
                 if (m.index() < firstAllowedIndex) {
                     snakeHead.changeTopSpeed(0.01f);
                 }
                 stroke(0, 255, 0);
                 skierInSnake = true;
                 break;
             }
             m = m.follower();
         }
         if (!skierInSnake) {
             snakeHead.changeTopSpeed(-0.02f);
         }
         ellipseMode(CENTER);
         ellipse(skier.getX(), skier.getY(), 10, 10);
         stroke(SnakeRun.SCREEN_COLOR);
     }
     
     private void drawPath(ArrayList<PVector> points) {
         beginShape();
         for (PVector p : points) {
             // First point is the first control point as well.
             if (points.get(0) == p) {
                 curveVertex(p.x, p.y);
             }
             curveVertex(p.x, p.y);
             // Last point is the last control point as well.
             if (points.get(points.size() - 1) == p) {
                 curveVertex(p.x, p.y);
             }
         }
         endShape();
         
         // Show the points
         beginShape();
         for (PVector p : points) {
             ellipseMode(CENTER);
             ellipse(p.x, p.y, 3, 3);
         }
         endShape();
     }
     
     private void generatePaths() {
         int steps = 25;
         
         leftPoints.clear();
         leftPoints.add(new PVector(width * 1 / 4, 0));
         rightPoints.clear();
         rightPoints.add(new PVector(width * 3 / 4, 0));
         
         RandomWalkOscillator rwo = new RandomWalkOscillator();
         
         for (int step = 0; step <= steps; step++) {
             float walkValue = (float) rwo.nextStep();
             
             // Calculate points for left and right snakes.
             float x, y = (height / steps) * (step + 1);
             x = width / 4 + walkValue;
             if (x < width / 20) {
                 x = width / 20;
             } else if (x > width * 9 / 20) {
                 x = width * 9 / 20;
             }
             leftPoints.add(new PVector(x, y));
             
             x += width / 2;
             if (x < width * 11 / 20) {
                 x = width * 11 / 20;
             }
             if (x > width * 19 / 20) {
                 x = width * 19 / 20;
             }
             rightPoints.add(new PVector(x, y));
         }
     }
     
     private void reset() {
         leftSnake.reset(width / 4, 0, leftPoints);
         leftSnake.stop();
         leftSkier.reset();
         
         rightSnake.reset(width * 3 / 4, 0, rightPoints);
         rightSnake.stop();
         rightSkier.reset();
     }
     
     public void keyPressed() {
         if (key == CODED) {
             // Snake speed control for test purposes
             if (keyCode == UP) { // add speed for *Left snake*
                 leftSnake.changeTopSpeed(0.25f);
             } else if (keyCode == DOWN) { // slow down *Left snake*
                 leftSnake.changeTopSpeed(-0.25f);
             } else if (keyCode == RIGHT) { // add speed for *Right snake*
                 rightSnake.changeTopSpeed(0.25f);
             } else if (keyCode == LEFT) { // slow down *Right snake*
                 rightSnake.changeTopSpeed(-0.25f);
             }
         } else if (key == 'n') {
             // Generate new paths & reset positions
             generatePaths();
             reset();
             
         } else if (key == 's') {
             // Start/stop
             if (laserOn) {
                 if (leftSnake.running() || rightSnake.running()) {
                     leftSnake.stop();
                     rightSnake.stop();
                 } else {
                     leftSnake.start();
                     rightSnake.start();
                     leftSkier.start();
                     rightSkier.start();
                 }
             }
         } else if (key == 'r') {
             // Reset positions
             reset();
         } else if (key == 'l') {
             // Switch laser on/off
             laserOn = !laserOn;
         }
     }
 }
