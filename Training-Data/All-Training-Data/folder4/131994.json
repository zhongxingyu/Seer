{
  "nr_root_ast_changes": 1,
  "faulty_ast": [
    {
      "label": "fichier",
      "type": "Field",
      "children": [
        {
          "label": "java.lang.String",
          "type": "VARIABLE_TYPE",
          "children": []
        },
        {
          "label": "",
          "type": "Modifiers",
          "children": [
            {
              "label": "final",
              "type": "Modifier",
              "children": []
            },
            {
              "label": "private",
              "type": "Modifier",
              "children": []
            },
            {
              "label": "static",
              "type": "Modifier",
              "children": []
            }
          ]
        },
        {
          "label": "\"import java.util.*;interface SemiGroupeAdd\u003cT\u003e {    T somme(T x);}interface MonoideAdd\u003cT\u003e extends SemiGroupeAdd\u003cT\u003e {    T zero();}interface GroupeAdd\u003cT\u003e extends MonoideAdd\u003cT\u003e {    T oppose();}interface SemiGroupeMul\u003cT\u003e {    T produit(T x);}interface MonoideMul\u003cT\u003e extends SemiGroupeMul\u003cT\u003e {    T un();}interface GroupeMul\u003cT\u003e extends MonoideMul\u003cT\u003e {    T inverse();}interface Anneau\u003cT\u003e extends GroupeAdd\u003cT\u003e, SemiGroupeMul\u003cT\u003e {}interface AnneauUnitaire\u003cT\u003e extends Anneau\u003cT\u003e, MonoideMul\u003cT\u003e {}interface Corps\u003cT\u003e extends AnneauUnitaire\u003cT\u003e, GroupeMul\u003cT\u003e {}class Calculs {    /*\u003cquestion id\u003d\\\"q1\\\"\u003e\u003csegment id\u003d\\\"q1s1\\\"\u003e*/        public static \u003cT extends GroupeAdd\u003cT\u003e\u003e T soustraction(T x, T y)        /*\u003c/segment\u003e*/        {       /*\u003csegment id\u003d\\\"q1s2\\\"\u003e*/            return x.somme(y.oppose());           /*\u003c/segment\u003e*/            }                /*\u003c/question\u003e*/    public static \u003cT extends MonoideAdd\u003cT\u003e\u003e T sommeNAire(T fab, List\u003cT\u003e l){\\tT r \u003d fab.zero();\\tfor(T e : l){\\t    r \u003d r.somme(e);\\t}\\treturn r;    }}interface Nat extends MonoideAdd\u003cNat\u003e, MonoideMul\u003cNat\u003e {    boolean estZero(); // Teste \\ufffd\\ufffd z\\ufffd\\ufffdro l\\\u0027entier naturel    Nat predecesseur(); // Donne le pr\\ufffd\\ufffdd\\ufffd\\ufffdcesseur s\\\u0027il existe    Nat creer(); // Cr\\ufffd\\ufffde un entier valant z\\ufffd\\ufffdro     Nat creer(Nat pred); // Cr\\ufffd\\ufffde un entier naturel \\ufffd\\ufffdgal au successeur de pred    int val(); // Convertit l\\\u0027entier naturel en int       boolean equals(Object o); // Renvoie false                              //   si o n\\\u0027est pas de type Nat,                              // teste l\\\u0027\\ufffd\\ufffdgalit\\ufffd\\ufffd des entiers naturels sinon    String toString(); // Affiche l\\\u0027entier renvoy\\ufffd\\ufffd par val}final class Zero implements Nat {    public static final Nat singleton \u003d new Zero();    private Zero(){}    public boolean estZero(){\\treturn true;    }    public Nat predecesseur(){\\treturn null;    }    public Nat creer(){\\treturn Zero.singleton;    }    public Nat creer(Nat pred){\\treturn new Succ(pred);    }    public Nat somme(Nat x){\\treturn x;    }    public Nat zero(){\\treturn creer();    }    public Nat produit(Nat x){\\treturn this;    }    public Nat un(){\\treturn creer(creer());    }    public int val(){\\treturn 0;    }    public boolean equals(Object o){\\tif(!(o instanceof Nat)) return false;\\tNat x \u003d (Nat)o;\\tif(x.estZero()) return true;\\treturn false;    }    public String toString(){\\treturn \\\"\\\" + val();    }}final class Succ implements Nat {    private Nat pred;    public Succ(Nat pred){\\tthis.pred \u003d pred;    }    public boolean estZero(){\\treturn false;    }    public Nat predecesseur(){\\treturn pred;    }    public Nat creer(){\\treturn Zero.singleton;    }    public Nat creer(Nat pred){\\treturn new Succ(pred);    }    public Nat somme(Nat x){\\treturn creer(predecesseur().somme(x));    }    public Nat zero(){\\treturn creer();    }    public Nat produit(Nat x){\\treturn x.somme(predecesseur().produit(x));    }    public Nat un(){\\treturn creer(creer());    }    public int val(){\\treturn 1 + predecesseur().val();    }\\t    public boolean equals(Object o){\\tif(!(o instanceof Nat)) return false;\\tNat x \u003d (Nat)o;\\tif(x.estZero()) return false;\\treturn predecesseur().equals(x.predecesseur());    }    public String toString(){\\treturn \\\"\\\" + val();    }}class Couple\u003cT1, T2\u003e {    public Couple(T1 c1, T2 c2){\\tpi1 \u003d c1;\\tpi2 \u003d c2;    }    public final T1 pi1;    public final T2 pi2;}interface Z extends AnneauUnitaire\u003cZ\u003e {    Z creer(Nat positif, Nat negatif); // Cr\\ufffd\\ufffde un entier relatif correspondant                                        //   \\ufffd\\ufffd la diff\\ufffd\\ufffdrence positif - n\\ufffd\\ufffdgatif      Couple\u003cNat, Nat\u003e representant(); // Renvoie un couple dont la diff\\ufffd\\ufffdrence                                     //   correspond \\ufffd\\ufffd l\\\u0027entier relatif    int val(); // Convertit l\\\u0027entier relatif en int       boolean equals(Object o); // Renvoie false                              //   si o n\\\u0027est pas de type Z,                              // teste l\\\u0027\\ufffd\\ufffdgalit\\ufffd\\ufffd des entiers relatifs sinon    String toString(); // Affiche l\\\u0027entier renvoy\\ufffd\\ufffd par val}class Relatif implements Z {    private Nat positif;    private Nat negatif;    public Relatif(){\\tthis(Zero.singleton, Zero.singleton);    }    public Relatif(Nat positif, Nat negatif){\\tthis.positif \u003d positif;\\tthis.negatif \u003d negatif;    }    public Couple\u003cNat, Nat\u003e representant(){\\treturn new Couple\u003cNat, Nat\u003e(positif, negatif);    }    public Z creer(Nat positif, Nat negatif){\\treturn new Relatif(positif, negatif);    }    public Z somme(Z x){\\tCouple\u003cNat, Nat\u003e rep \u003d this.representant(); \\tCouple\u003cNat, Nat\u003e repX \u003d x.representant(); \\tNat positif \u003d rep.pi1.somme(repX.pi1);\\tNat negatif \u003d rep.pi2.somme(repX.pi2);\\treturn creer(positif, negatif);    }    public Z zero(){\\treturn creer(Zero.singleton, Zero.singleton);    }    public Z oppose(){\\tCouple\u003cNat, Nat\u003e rep \u003d this.representant(); \\treturn creer(rep.pi2, rep.pi1);    }    public Z produit(Z x){\\tCouple\u003cNat, Nat\u003e rep \u003d this.representant(); \\tCouple\u003cNat, Nat\u003e repX \u003d x.representant();\\tNat positif \u003d rep.pi1.produit(repX.pi1).somme(rep.pi2.produit(repX.pi2));\\tNat negatif \u003d rep.pi2.produit(repX.pi1).somme(rep.pi1.produit(repX.pi2));\\treturn creer(positif, negatif);    }    public Z un(){\\tNat fab \u003d Zero.singleton;\\tNat zero \u003d Zero.singleton;\\tNat un \u003d fab.creer(zero);\\treturn creer(un, zero);    }    public int val(){\\tCouple\u003cNat, Nat\u003e rep \u003d this.representant(); \\treturn (rep.pi1.val() - rep.pi2.val());    }    public boolean equals(Object o){\\tif(!(o instanceof Z)) return false;\\tZ x \u003d (Z)o;\\tCouple\u003cNat, Nat\u003e rep \u003d this.representant(); \\tCouple\u003cNat, Nat\u003e repX \u003d x.representant();\\treturn rep.pi1.somme(repX.pi2).equals(rep.pi2.somme(repX.pi1));    }   public String toString(){       return \\\"\\\" + val();    }}interface Symetrise\u003cT extends MonoideAdd\u003cT\u003e \u0026 MonoideMul\u003cT\u003e\u003e     extends AnneauUnitaire\u003cSymetrise\u003cT\u003e\u003e {    Symetrise\u003cT\u003e creer(T positif, T negatif);     Couple\u003cT, T\u003e representant();    boolean equals(Object o); }class Diagonale\u003cT extends MonoideAdd\u003cT\u003e \u0026 MonoideMul\u003cT\u003e\u003e      implements Symetrise\u003cT\u003e {    private T positif;    private T negatif;    public Diagonale(T positif, T negatif){\\tthis.positif \u003d positif;\\tthis.negatif \u003d negatif;    }    public Couple\u003cT, T\u003e representant(){\\treturn new Couple\u003cT, T\u003e(positif, negatif);    }    public Symetrise\u003cT\u003e creer(T positif, T negatif){\\treturn new Diagonale\u003cT\u003e(positif, negatif);    }    public Symetrise\u003cT\u003e somme(Symetrise\u003cT\u003e x){\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\tCouple\u003cT, T\u003e repX \u003d x.representant(); \\tT positif \u003d rep.pi1.somme(repX.pi1);\\tT negatif \u003d rep.pi2.somme(repX.pi2);\\treturn creer(positif, negatif);    }    public Symetrise\u003cT\u003e zero(){\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\treturn creer(rep.pi1, rep.pi1);    }    public Symetrise\u003cT\u003e oppose(){\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\treturn creer(rep.pi2, rep.pi1);    }    public Symetrise\u003cT\u003e produit(Symetrise\u003cT\u003e x){\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\tCouple\u003cT, T\u003e repX \u003d x.representant();\\tT positif \u003d rep.pi1.produit(repX.pi1).somme(rep.pi2.produit(repX.pi2));\\tT negatif \u003d rep.pi2.produit(repX.pi1).somme(rep.pi1.produit(repX.pi2));\\treturn creer(positif, negatif);    }    public Symetrise\u003cT\u003e un(){\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\tT fab \u003d rep.pi1;\\tT zero \u003d fab.zero();\\tT un \u003d fab.un();\\treturn creer(un, zero);    }    public boolean equals(Object o){\\tif(!(o instanceof Symetrise)) return false;\\tSymetrise\u003cT\u003e x \u003d (Symetrise\u003cT\u003e)o;\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\tCouple\u003cT, T\u003e repX \u003d x.representant();\\treturn rep.pi1.somme(repX.pi2).equals(rep.pi2.somme(repX.pi1));    }    public String toString(){\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\treturn rep.pi1.toString() + \\\" - \\\" + rep.pi2.toString();     }}interface Q extends Corps\u003cQ\u003e {    Z getNumerateur(); // Renvoie le num\\ufffd\\ufffdrateur    Z getDenominateur(); // Renvoie le d\\ufffd\\ufffdnominateur    Q creer(Z numerateur, Z denominateur); // Cr\\ufffd\\ufffde le rationnel numerateur/denominateur    String toString(); // Repr\\ufffd\\ufffdsente le rationnel sous la forme \\\"numerateur/denominateur\\\"    boolean equals(Object o); // Renvoie false                              //   si o n\\\u0027est pas de type Q,                              // teste l\\\u0027\\ufffd\\ufffdgalit\\ufffd\\ufffd des rationnels sinon}class Rationnel implements Q {    private Z numerateur;    private Z denominateur;    public Rationnel(Z numerateur, Z denominateur){\\tthis.numerateur \u003d numerateur;\\tthis.denominateur \u003d denominateur;    }    public Z getNumerateur(){\\treturn numerateur;    }    public Z getDenominateur(){\\treturn denominateur;    }    public Q creer(Z numerateur, Z denominateur){\\treturn new Rationnel(numerateur, denominateur);    }    public Q somme(Q x){\\tZ n \u003d getNumerateur().produit(x.getDenominateur()).somme(x.getNumerateur().produit(getDenominateur()));\\tZ d \u003d getDenominateur().produit(x.getDenominateur());\\treturn creer(n, d);    }    public Q zero(){\\tZ fab \u003d new Relatif();\\treturn creer(fab.zero(), fab.un());    }    public Q oppose(){\\treturn creer(getNumerateur().oppose(), getDenominateur());    }    public Q produit(Q x){\\treturn creer(getNumerateur().produit(x.getNumerateur()), \\t\\t     getDenominateur().produit(x.getDenominateur()) );    }    public Q un(){\\tZ fab \u003d new Relatif();\\treturn creer(fab.un(), fab.un());    }    public Q inverse(){\\treturn creer(getDenominateur(), getNumerateur());    }    public String toString(){\\treturn getNumerateur() + \\\"/\\\" + getDenominateur();    }    public boolean equals(Object o){\\tif(!(o instanceof Q)) return false;\\tQ x \u003d (Q)o;\\treturn\\t    getNumerateur().produit(x.getDenominateur())\\t    .equals(x.getNumerateur().produit(getDenominateur()));    }}interface Fraction\u003cT extends AnneauUnitaire\u003cT\u003e\u003e     extends Corps\u003cFraction\u003cT\u003e\u003e {    T getNumerateur();    T getDenominateur();    Fraction\u003cT\u003e creer(T numerateur, T denominateur);    String toString();    boolean equals(Object o);}class Rapport\u003cT extends AnneauUnitaire\u003cT\u003e\u003e      implements Fraction\u003cT\u003e {    private T numerateur;    private T denominateur;    public Rapport(T numerateur, T denominateur){\\tthis.numerateur \u003d numerateur;\\tthis.denominateur \u003d denominateur;    }    public T getNumerateur(){\\treturn numerateur;    }    public T getDenominateur(){\\treturn denominateur;    }    public Fraction\u003cT\u003e creer(T numerateur, T denominateur){\\treturn new Rapport\u003cT\u003e(numerateur, denominateur);    }    public Fraction\u003cT\u003e somme(Fraction\u003cT\u003e x){\\tT n \u003d getNumerateur().produit(x.getDenominateur()).somme(x.getNumerateur().produit(getDenominateur()));\\tT d \u003d getDenominateur().produit(x.getDenominateur());\\treturn creer(n, d);    }    public Fraction\u003cT\u003e zero(){\\tT fab \u003d numerateur;\\treturn creer(fab.zero(), fab.un());    }    public Fraction\u003cT\u003e oppose(){\\treturn creer(getNumerateur().oppose(), getDenominateur());    }    public Fraction\u003cT\u003e produit(Fraction\u003cT\u003e x){\\treturn creer(getNumerateur().produit(x.getNumerateur()), \\t\\t     getDenominateur().produit(x.getDenominateur()) );    }    public Fraction\u003cT\u003e un(){\\tT fab \u003d numerateur;\\treturn creer(fab.un(), fab.un());    }    public Fraction\u003cT\u003e inverse(){\\treturn creer(getDenominateur(), getNumerateur());    }    public String toString(){\\treturn \\\"(\\\" + getNumerateur() + \\\")/(\\\" + getDenominateur() + \\\")\\\";    }    public boolean equals(Object o){\\tif(!(o instanceof Fraction)) return false;\\tFraction\u003cT\u003e x \u003d (Fraction\u003cT\u003e)o;\\treturn\\t    getNumerateur().produit(x.getDenominateur())\\t    .equals(x.getNumerateur().produit(getDenominateur()));    }}\\t\\t\\t  public class Test {    public static void main(String[] args){\\t/* Nat */\\tSystem.out.println(\\\"******* Test de Nat *******\\\");      \\tNat fab \u003d Zero.singleton;\\tNat zero \u003d fab.creer();\\tNat un \u003d fab.creer(zero);\\tNat deux \u003d fab.creer(un);\\tNat quatre \u003d deux.somme(deux);      \\tNat huit \u003d deux.produit(quatre);\\t\\tSystem.out.println(\\\"z\\ufffd\\ufffdro : \\\" + zero);\\tSystem.out.println(\\\"un : \\\" + un);\\tSystem.out.println(\\\"deux : \\\" + deux);\\tSystem.out.println(\\\"quatre : \\\" + quatre);      \\tSystem.out.println(\\\"huit : \\\" + huit);      \\tSystem.out.println(\\\"\\ufffd\\ufffdgal : \\\" + zero.equals(un.zero()));      \\tSystem.out.println(\\\"\\ufffd\\ufffdgal : \\\" + un.equals(un.un()));      \\t/* Z */\\tSystem.out.println(\\\"******* Test de Z *******\\\");      \\tZ fabZ \u003d new Relatif();        Z zeroZ \u003d fabZ.zero();\\tZ moinsUn \u003d fabZ.creer(un, deux);\\tZ moinsDeux \u003d fabZ.creer(deux, quatre);\\tZ quatreZ \u003d moinsDeux.produit(moinsDeux);        System.out.println(\\\"z\\ufffd\\ufffdro Z : \\\" + zeroZ);    \\tSystem.out.println(\\\"moins un : \\\" + moinsUn);\\tSystem.out.println(\\\"moins deux : \\\" + moinsDeux);\\tSystem.out.println(\\\"quatre Z : \\\" + quatreZ); \\tSystem.out.println(\\\"\\ufffd\\ufffdgal : \\\" + moinsDeux.equals(moinsDeux));\\tSystem.out.println(\\\"in\\ufffd\\ufffdgal : \\\" + moinsDeux.equals(quatreZ));\\t/* Symetrise\u003cNat\u003e */\\tSystem.out.println(\\\"******* Test de Symetrise\u003cNat\u003e *******\\\");      \\tSymetrise\u003cNat\u003e fabS \u003d new Diagonale\u003cNat\u003e(Zero.singleton, Zero.singleton);\\tSymetrise\u003cNat\u003e zeroS \u003d fabS.zero();\\tSymetrise\u003cNat\u003e moinsUnS \u003d fabS.creer(un, deux);\\tSymetrise\u003cNat\u003e moinsDeuxS \u003d fabS.creer(deux, quatre);\\tSymetrise\u003cNat\u003e quatreS \u003d moinsDeuxS.produit(moinsDeuxS);\\tSystem.out.println(\\\"z\\ufffd\\ufffdro S: \\\" + zeroS);  \\tSystem.out.println(\\\"moins un S: \\\" + moinsUnS);\\tSystem.out.println(\\\"moins deux S: \\\" + moinsDeuxS);  \\tSystem.out.println(\\\"quatre S: \\\" + quatreS); \\tSystem.out.println(\\\"un S: \\\" + moinsUnS.oppose());\\tSystem.out.println(\\\"\\ufffd\\ufffdgal S: \\\" + moinsDeuxS.equals(moinsDeuxS));\\tSystem.out.println(\\\"in\\ufffd\\ufffdgal S: \\\" + moinsDeuxS.equals(quatreS));\\t/* Q */\\tSystem.out.println(\\\"******* Test de Q *******\\\");      \\tQ fabQ \u003d new Rationnel(fabZ, fabZ);\\tQ unDemi \u003d fabQ.creer(moinsUn, moinsDeux);\\tQ deuxQ \u003d fabQ.creer(moinsDeux, moinsUn); \\tQ unQ \u003d unDemi.somme(unDemi);\\tQ unQuart \u003d unDemi.produit(unDemi);\\tSystem.out.println(\\\"un demi : \\\" + unDemi);\\tSystem.out.println(\\\"deux : \\\" + deuxQ);\\tSystem.out.println(\\\"un : \\\" + unQ); \\tSystem.out.println(\\\"un quart : \\\" + unQuart);\\tSystem.out.println(\\\"un demi \\ufffd\\ufffdgal \\ufffd\\ufffd inverse de deux: \\\" + unDemi.equals(deuxQ.inverse()));\\tSystem.out.println(\\\"\\ufffd\\ufffdgal : \\\" + unQuart.equals(unQuart));\\tSystem.out.println(\\\"in\\ufffd\\ufffdgal : \\\" + unQuart.equals(deuxQ));\\t/* Fraction\u003cSymetrise\u003cNat\u003e\u003e */\\tSystem.out.println(\\\"******* Test de Fraction\u003cSymetrise\u003cNat\u003e\u003e *******\\\");      \\tFraction\u003cSymetrise\u003cNat\u003e\u003e fabFS \u003d new Rapport\u003cSymetrise\u003cNat\u003e\u003e(fabS, fabS);\\tFraction\u003cSymetrise\u003cNat\u003e\u003e unDemiFS \u003d fabFS.creer(moinsUnS, moinsDeuxS);\\tFraction\u003cSymetrise\u003cNat\u003e\u003e deuxFS \u003d fabFS.creer(moinsDeuxS, moinsUnS); \\tFraction\u003cSymetrise\u003cNat\u003e\u003e unFS \u003d unDemiFS.somme(unDemiFS);\\tFraction\u003cSymetrise\u003cNat\u003e\u003e unQuartFS \u003d unDemiFS.produit(unDemiFS);\\tSystem.out.println(\\\"un demi : \\\" + unDemiFS);\\tSystem.out.println(\\\"deux : \\\" + deuxFS);\\tSystem.out.println(\\\"un : \\\" + unFS); \\tSystem.out.println(\\\"un quart : \\\" + unQuartFS);\\tSystem.out.println(\\\"un demi \\ufffd\\ufffdgal \\ufffd\\ufffd inverse de deux: \\\" + unDemiFS.equals(deuxFS.inverse()));    }    public static void main(String[] args) {        /*\u003cvalidation/\u003e*/    }        public static double validationQ1F1(){        double note \u003d 0;        //@@@        return note;    }}\"",
          "type": "Literal",
          "susp": [
            "susp_constChange_literal"
          ],
          "return_type": "java.lang.String",
          "index_of_exper": "expression_0",
          "children": []
        }
      ]
    }
  ],
  "context": {
    "cntx": {
      "S1_LOCAL_VAR_NOT_ASSIGNED": "false",
      "S14_TYPE_OF_FAULTY_STATEMENT_PARENT": "Class",
      "S9_METHOD_CALL_WITH_NORMAL_GUARD": "false",
      "S2_SIMILAR_OBJECT_TYPE_WITH_NORMAL_GUARD": "false",
      "S4_Field_NOT_USED": "false",
      "S18_In_Synchronized_Method": "false",
      "S8_PRIMITIVE_USED_IN_ASSIGNMENT": "false",
      "S11_FAULTY_CLASS_EXCEPTION_TYPE": "false",
      "S16_HAS_Invocations_Prone_Exception": "false",
      "S7_OBJECT_USED_IN_ASSIGNMENT": "false",
      "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NULL_GUARD": "false",
      "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_2": "",
      "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_1": "",
      "S13_TYPE_OF_FAULTY_STATEMENT_BEFORE_3": "",
      "S12_METHOD_CALL_WITH_TRY_CATCH": "false",
      "CONSTANT": {
        "\"import java.util.*;interface SemiGroupeAdd\u003cT\u003e {    T somme(T x);}interface MonoideAdd\u003cT\u003e extends SemiGroupeAdd\u003cT\u003e {    T zero();}interface GroupeAdd\u003cT\u003e extends MonoideAdd\u003cT\u003e {    T oppose();}interface SemiGroupeMul\u003cT\u003e {    T produit(T x);}interface MonoideMul\u003cT\u003e extends SemiGroupeMul\u003cT\u003e {    T un();}interface GroupeMul\u003cT\u003e extends MonoideMul\u003cT\u003e {    T inverse();}interface Anneau\u003cT\u003e extends GroupeAdd\u003cT\u003e, SemiGroupeMul\u003cT\u003e {}interface AnneauUnitaire\u003cT\u003e extends Anneau\u003cT\u003e, MonoideMul\u003cT\u003e {}interface Corps\u003cT\u003e extends AnneauUnitaire\u003cT\u003e, GroupeMul\u003cT\u003e {}class Calculs {    /*\u003cquestion id\u003d\\\"q1\\\"\u003e\u003csegment id\u003d\\\"q1s1\\\"\u003e*/        public static \u003cT extends GroupeAdd\u003cT\u003e\u003e T soustraction(T x, T y)        /*\u003c/segment\u003e*/        {       /*\u003csegment id\u003d\\\"q1s2\\\"\u003e*/            return x.somme(y.oppose());           /*\u003c/segment\u003e*/            }                /*\u003c/question\u003e*/    public static \u003cT extends MonoideAdd\u003cT\u003e\u003e T sommeNAire(T fab, List\u003cT\u003e l){\\tT r \u003d fab.zero();\\tfor(T e : l){\\t    r \u003d r.somme(e);\\t}\\treturn r;    }}interface Nat extends MonoideAdd\u003cNat\u003e, MonoideMul\u003cNat\u003e {    boolean estZero(); // Teste \\ufffd\\ufffd z\\ufffd\\ufffdro l\\\u0027entier naturel    Nat predecesseur(); // Donne le pr\\ufffd\\ufffdd\\ufffd\\ufffdcesseur s\\\u0027il existe    Nat creer(); // Cr\\ufffd\\ufffde un entier valant z\\ufffd\\ufffdro     Nat creer(Nat pred); // Cr\\ufffd\\ufffde un entier naturel \\ufffd\\ufffdgal au successeur de pred    int val(); // Convertit l\\\u0027entier naturel en int       boolean equals(Object o); // Renvoie false                              //   si o n\\\u0027est pas de type Nat,                              // teste l\\\u0027\\ufffd\\ufffdgalit\\ufffd\\ufffd des entiers naturels sinon    String toString(); // Affiche l\\\u0027entier renvoy\\ufffd\\ufffd par val}final class Zero implements Nat {    public static final Nat singleton \u003d new Zero();    private Zero(){}    public boolean estZero(){\\treturn true;    }    public Nat predecesseur(){\\treturn null;    }    public Nat creer(){\\treturn Zero.singleton;    }    public Nat creer(Nat pred){\\treturn new Succ(pred);    }    public Nat somme(Nat x){\\treturn x;    }    public Nat zero(){\\treturn creer();    }    public Nat produit(Nat x){\\treturn this;    }    public Nat un(){\\treturn creer(creer());    }    public int val(){\\treturn 0;    }    public boolean equals(Object o){\\tif(!(o instanceof Nat)) return false;\\tNat x \u003d (Nat)o;\\tif(x.estZero()) return true;\\treturn false;    }    public String toString(){\\treturn \\\"\\\" + val();    }}final class Succ implements Nat {    private Nat pred;    public Succ(Nat pred){\\tthis.pred \u003d pred;    }    public boolean estZero(){\\treturn false;    }    public Nat predecesseur(){\\treturn pred;    }    public Nat creer(){\\treturn Zero.singleton;    }    public Nat creer(Nat pred){\\treturn new Succ(pred);    }    public Nat somme(Nat x){\\treturn creer(predecesseur().somme(x));    }    public Nat zero(){\\treturn creer();    }    public Nat produit(Nat x){\\treturn x.somme(predecesseur().produit(x));    }    public Nat un(){\\treturn creer(creer());    }    public int val(){\\treturn 1 + predecesseur().val();    }\\t    public boolean equals(Object o){\\tif(!(o instanceof Nat)) return false;\\tNat x \u003d (Nat)o;\\tif(x.estZero()) return false;\\treturn predecesseur().equals(x.predecesseur());    }    public String toString(){\\treturn \\\"\\\" + val();    }}class Couple\u003cT1, T2\u003e {    public Couple(T1 c1, T2 c2){\\tpi1 \u003d c1;\\tpi2 \u003d c2;    }    public final T1 pi1;    public final T2 pi2;}interface Z extends AnneauUnitaire\u003cZ\u003e {    Z creer(Nat positif, Nat negatif); // Cr\\ufffd\\ufffde un entier relatif correspondant                                        //   \\ufffd\\ufffd la diff\\ufffd\\ufffdrence positif - n\\ufffd\\ufffdgatif      Couple\u003cNat, Nat\u003e representant(); // Renvoie un couple dont la diff\\ufffd\\ufffdrence                                     //   correspond \\ufffd\\ufffd l\\\u0027entier relatif    int val(); // Convertit l\\\u0027entier relatif en int       boolean equals(Object o); // Renvoie false                              //   si o n\\\u0027est pas de type Z,                              // teste l\\\u0027\\ufffd\\ufffdgalit\\ufffd\\ufffd des entiers relatifs sinon    String toString(); // Affiche l\\\u0027entier renvoy\\ufffd\\ufffd par val}class Relatif implements Z {    private Nat positif;    private Nat negatif;    public Relatif(){\\tthis(Zero.singleton, Zero.singleton);    }    public Relatif(Nat positif, Nat negatif){\\tthis.positif \u003d positif;\\tthis.negatif \u003d negatif;    }    public Couple\u003cNat, Nat\u003e representant(){\\treturn new Couple\u003cNat, Nat\u003e(positif, negatif);    }    public Z creer(Nat positif, Nat negatif){\\treturn new Relatif(positif, negatif);    }    public Z somme(Z x){\\tCouple\u003cNat, Nat\u003e rep \u003d this.representant(); \\tCouple\u003cNat, Nat\u003e repX \u003d x.representant(); \\tNat positif \u003d rep.pi1.somme(repX.pi1);\\tNat negatif \u003d rep.pi2.somme(repX.pi2);\\treturn creer(positif, negatif);    }    public Z zero(){\\treturn creer(Zero.singleton, Zero.singleton);    }    public Z oppose(){\\tCouple\u003cNat, Nat\u003e rep \u003d this.representant(); \\treturn creer(rep.pi2, rep.pi1);    }    public Z produit(Z x){\\tCouple\u003cNat, Nat\u003e rep \u003d this.representant(); \\tCouple\u003cNat, Nat\u003e repX \u003d x.representant();\\tNat positif \u003d rep.pi1.produit(repX.pi1).somme(rep.pi2.produit(repX.pi2));\\tNat negatif \u003d rep.pi2.produit(repX.pi1).somme(rep.pi1.produit(repX.pi2));\\treturn creer(positif, negatif);    }    public Z un(){\\tNat fab \u003d Zero.singleton;\\tNat zero \u003d Zero.singleton;\\tNat un \u003d fab.creer(zero);\\treturn creer(un, zero);    }    public int val(){\\tCouple\u003cNat, Nat\u003e rep \u003d this.representant(); \\treturn (rep.pi1.val() - rep.pi2.val());    }    public boolean equals(Object o){\\tif(!(o instanceof Z)) return false;\\tZ x \u003d (Z)o;\\tCouple\u003cNat, Nat\u003e rep \u003d this.representant(); \\tCouple\u003cNat, Nat\u003e repX \u003d x.representant();\\treturn rep.pi1.somme(repX.pi2).equals(rep.pi2.somme(repX.pi1));    }   public String toString(){       return \\\"\\\" + val();    }}interface Symetrise\u003cT extends MonoideAdd\u003cT\u003e \u0026 MonoideMul\u003cT\u003e\u003e     extends AnneauUnitaire\u003cSymetrise\u003cT\u003e\u003e {    Symetrise\u003cT\u003e creer(T positif, T negatif);     Couple\u003cT, T\u003e representant();    boolean equals(Object o); }class Diagonale\u003cT extends MonoideAdd\u003cT\u003e \u0026 MonoideMul\u003cT\u003e\u003e      implements Symetrise\u003cT\u003e {    private T positif;    private T negatif;    public Diagonale(T positif, T negatif){\\tthis.positif \u003d positif;\\tthis.negatif \u003d negatif;    }    public Couple\u003cT, T\u003e representant(){\\treturn new Couple\u003cT, T\u003e(positif, negatif);    }    public Symetrise\u003cT\u003e creer(T positif, T negatif){\\treturn new Diagonale\u003cT\u003e(positif, negatif);    }    public Symetrise\u003cT\u003e somme(Symetrise\u003cT\u003e x){\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\tCouple\u003cT, T\u003e repX \u003d x.representant(); \\tT positif \u003d rep.pi1.somme(repX.pi1);\\tT negatif \u003d rep.pi2.somme(repX.pi2);\\treturn creer(positif, negatif);    }    public Symetrise\u003cT\u003e zero(){\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\treturn creer(rep.pi1, rep.pi1);    }    public Symetrise\u003cT\u003e oppose(){\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\treturn creer(rep.pi2, rep.pi1);    }    public Symetrise\u003cT\u003e produit(Symetrise\u003cT\u003e x){\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\tCouple\u003cT, T\u003e repX \u003d x.representant();\\tT positif \u003d rep.pi1.produit(repX.pi1).somme(rep.pi2.produit(repX.pi2));\\tT negatif \u003d rep.pi2.produit(repX.pi1).somme(rep.pi1.produit(repX.pi2));\\treturn creer(positif, negatif);    }    public Symetrise\u003cT\u003e un(){\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\tT fab \u003d rep.pi1;\\tT zero \u003d fab.zero();\\tT un \u003d fab.un();\\treturn creer(un, zero);    }    public boolean equals(Object o){\\tif(!(o instanceof Symetrise)) return false;\\tSymetrise\u003cT\u003e x \u003d (Symetrise\u003cT\u003e)o;\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\tCouple\u003cT, T\u003e repX \u003d x.representant();\\treturn rep.pi1.somme(repX.pi2).equals(rep.pi2.somme(repX.pi1));    }    public String toString(){\\tCouple\u003cT, T\u003e rep \u003d this.representant(); \\treturn rep.pi1.toString() + \\\" - \\\" + rep.pi2.toString();     }}interface Q extends Corps\u003cQ\u003e {    Z getNumerateur(); // Renvoie le num\\ufffd\\ufffdrateur    Z getDenominateur(); // Renvoie le d\\ufffd\\ufffdnominateur    Q creer(Z numerateur, Z denominateur); // Cr\\ufffd\\ufffde le rationnel numerateur/denominateur    String toString(); // Repr\\ufffd\\ufffdsente le rationnel sous la forme \\\"numerateur/denominateur\\\"    boolean equals(Object o); // Renvoie false                              //   si o n\\\u0027est pas de type Q,                              // teste l\\\u0027\\ufffd\\ufffdgalit\\ufffd\\ufffd des rationnels sinon}class Rationnel implements Q {    private Z numerateur;    private Z denominateur;    public Rationnel(Z numerateur, Z denominateur){\\tthis.numerateur \u003d numerateur;\\tthis.denominateur \u003d denominateur;    }    public Z getNumerateur(){\\treturn numerateur;    }    public Z getDenominateur(){\\treturn denominateur;    }    public Q creer(Z numerateur, Z denominateur){\\treturn new Rationnel(numerateur, denominateur);    }    public Q somme(Q x){\\tZ n \u003d getNumerateur().produit(x.getDenominateur()).somme(x.getNumerateur().produit(getDenominateur()));\\tZ d \u003d getDenominateur().produit(x.getDenominateur());\\treturn creer(n, d);    }    public Q zero(){\\tZ fab \u003d new Relatif();\\treturn creer(fab.zero(), fab.un());    }    public Q oppose(){\\treturn creer(getNumerateur().oppose(), getDenominateur());    }    public Q produit(Q x){\\treturn creer(getNumerateur().produit(x.getNumerateur()), \\t\\t     getDenominateur().produit(x.getDenominateur()) );    }    public Q un(){\\tZ fab \u003d new Relatif();\\treturn creer(fab.un(), fab.un());    }    public Q inverse(){\\treturn creer(getDenominateur(), getNumerateur());    }    public String toString(){\\treturn getNumerateur() + \\\"/\\\" + getDenominateur();    }    public boolean equals(Object o){\\tif(!(o instanceof Q)) return false;\\tQ x \u003d (Q)o;\\treturn\\t    getNumerateur().produit(x.getDenominateur())\\t    .equals(x.getNumerateur().produit(getDenominateur()));    }}interface Fraction\u003cT extends AnneauUnitaire\u003cT\u003e\u003e     extends Corps\u003cFraction\u003cT\u003e\u003e {    T getNumerateur();    T getDenominateur();    Fraction\u003cT\u003e creer(T numerateur, T denominateur);    String toString();    boolean equals(Object o);}class Rapport\u003cT extends AnneauUnitaire\u003cT\u003e\u003e      implements Fraction\u003cT\u003e {    private T numerateur;    private T denominateur;    public Rapport(T numerateur, T denominateur){\\tthis.numerateur \u003d numerateur;\\tthis.denominateur \u003d denominateur;    }    public T getNumerateur(){\\treturn numerateur;    }    public T getDenominateur(){\\treturn denominateur;    }    public Fraction\u003cT\u003e creer(T numerateur, T denominateur){\\treturn new Rapport\u003cT\u003e(numerateur, denominateur);    }    public Fraction\u003cT\u003e somme(Fraction\u003cT\u003e x){\\tT n \u003d getNumerateur().produit(x.getDenominateur()).somme(x.getNumerateur().produit(getDenominateur()));\\tT d \u003d getDenominateur().produit(x.getDenominateur());\\treturn creer(n, d);    }    public Fraction\u003cT\u003e zero(){\\tT fab \u003d numerateur;\\treturn creer(fab.zero(), fab.un());    }    public Fraction\u003cT\u003e oppose(){\\treturn creer(getNumerateur().oppose(), getDenominateur());    }    public Fraction\u003cT\u003e produit(Fraction\u003cT\u003e x){\\treturn creer(getNumerateur().produit(x.getNumerateur()), \\t\\t     getDenominateur().produit(x.getDenominateur()) );    }    public Fraction\u003cT\u003e un(){\\tT fab \u003d numerateur;\\treturn creer(fab.un(), fab.un());    }    public Fraction\u003cT\u003e inverse(){\\treturn creer(getDenominateur(), getNumerateur());    }    public String toString(){\\treturn \\\"(\\\" + getNumerateur() + \\\")/(\\\" + getDenominateur() + \\\")\\\";    }    public boolean equals(Object o){\\tif(!(o instanceof Fraction)) return false;\\tFraction\u003cT\u003e x \u003d (Fraction\u003cT\u003e)o;\\treturn\\t    getNumerateur().produit(x.getDenominateur())\\t    .equals(x.getNumerateur().produit(getDenominateur()));    }}\\t\\t\\t  public class Test {    public static void main(String[] args){\\t/* Nat */\\tSystem.out.println(\\\"******* Test de Nat *******\\\");      \\tNat fab \u003d Zero.singleton;\\tNat zero \u003d fab.creer();\\tNat un \u003d fab.creer(zero);\\tNat deux \u003d fab.creer(un);\\tNat quatre \u003d deux.somme(deux);      \\tNat huit \u003d deux.produit(quatre);\\t\\tSystem.out.println(\\\"z\\ufffd\\ufffdro : \\\" + zero);\\tSystem.out.println(\\\"un : \\\" + un);\\tSystem.out.println(\\\"deux : \\\" + deux);\\tSystem.out.println(\\\"quatre : \\\" + quatre);      \\tSystem.out.println(\\\"huit : \\\" + huit);      \\tSystem.out.println(\\\"\\ufffd\\ufffdgal : \\\" + zero.equals(un.zero()));      \\tSystem.out.println(\\\"\\ufffd\\ufffdgal : \\\" + un.equals(un.un()));      \\t/* Z */\\tSystem.out.println(\\\"******* Test de Z *******\\\");      \\tZ fabZ \u003d new Relatif();        Z zeroZ \u003d fabZ.zero();\\tZ moinsUn \u003d fabZ.creer(un, deux);\\tZ moinsDeux \u003d fabZ.creer(deux, quatre);\\tZ quatreZ \u003d moinsDeux.produit(moinsDeux);        System.out.println(\\\"z\\ufffd\\ufffdro Z : \\\" + zeroZ);    \\tSystem.out.println(\\\"moins un : \\\" + moinsUn);\\tSystem.out.println(\\\"moins deux : \\\" + moinsDeux);\\tSystem.out.println(\\\"quatre Z : \\\" + quatreZ); \\tSystem.out.println(\\\"\\ufffd\\ufffdgal : \\\" + moinsDeux.equals(moinsDeux));\\tSystem.out.println(\\\"in\\ufffd\\ufffdgal : \\\" + moinsDeux.equals(quatreZ));\\t/* Symetrise\u003cNat\u003e */\\tSystem.out.println(\\\"******* Test de Symetrise\u003cNat\u003e *******\\\");      \\tSymetrise\u003cNat\u003e fabS \u003d new Diagonale\u003cNat\u003e(Zero.singleton, Zero.singleton);\\tSymetrise\u003cNat\u003e zeroS \u003d fabS.zero();\\tSymetrise\u003cNat\u003e moinsUnS \u003d fabS.creer(un, deux);\\tSymetrise\u003cNat\u003e moinsDeuxS \u003d fabS.creer(deux, quatre);\\tSymetrise\u003cNat\u003e quatreS \u003d moinsDeuxS.produit(moinsDeuxS);\\tSystem.out.println(\\\"z\\ufffd\\ufffdro S: \\\" + zeroS);  \\tSystem.out.println(\\\"moins un S: \\\" + moinsUnS);\\tSystem.out.println(\\\"moins deux S: \\\" + moinsDeuxS);  \\tSystem.out.println(\\\"quatre S: \\\" + quatreS); \\tSystem.out.println(\\\"un S: \\\" + moinsUnS.oppose());\\tSystem.out.println(\\\"\\ufffd\\ufffdgal S: \\\" + moinsDeuxS.equals(moinsDeuxS));\\tSystem.out.println(\\\"in\\ufffd\\ufffdgal S: \\\" + moinsDeuxS.equals(quatreS));\\t/* Q */\\tSystem.out.println(\\\"******* Test de Q *******\\\");      \\tQ fabQ \u003d new Rationnel(fabZ, fabZ);\\tQ unDemi \u003d fabQ.creer(moinsUn, moinsDeux);\\tQ deuxQ \u003d fabQ.creer(moinsDeux, moinsUn); \\tQ unQ \u003d unDemi.somme(unDemi);\\tQ unQuart \u003d unDemi.produit(unDemi);\\tSystem.out.println(\\\"un demi : \\\" + unDemi);\\tSystem.out.println(\\\"deux : \\\" + deuxQ);\\tSystem.out.println(\\\"un : \\\" + unQ); \\tSystem.out.println(\\\"un quart : \\\" + unQuart);\\tSystem.out.println(\\\"un demi \\ufffd\\ufffdgal \\ufffd\\ufffd inverse de deux: \\\" + unDemi.equals(deuxQ.inverse()));\\tSystem.out.println(\\\"\\ufffd\\ufffdgal : \\\" + unQuart.equals(unQuart));\\tSystem.out.println(\\\"in\\ufffd\\ufffdgal : \\\" + unQuart.equals(deuxQ));\\t/* Fraction\u003cSymetrise\u003cNat\u003e\u003e */\\tSystem.out.println(\\\"******* Test de Fraction\u003cSymetrise\u003cNat\u003e\u003e *******\\\");      \\tFraction\u003cSymetrise\u003cNat\u003e\u003e fabFS \u003d new Rapport\u003cSymetrise\u003cNat\u003e\u003e(fabS, fabS);\\tFraction\u003cSymetrise\u003cNat\u003e\u003e unDemiFS \u003d fabFS.creer(moinsUnS, moinsDeuxS);\\tFraction\u003cSymetrise\u003cNat\u003e\u003e deuxFS \u003d fabFS.creer(moinsDeuxS, moinsUnS); \\tFraction\u003cSymetrise\u003cNat\u003e\u003e unFS \u003d unDemiFS.somme(unDemiFS);\\tFraction\u003cSymetrise\u003cNat\u003e\u003e unQuartFS \u003d unDemiFS.produit(unDemiFS);\\tSystem.out.println(\\\"un demi : \\\" + unDemiFS);\\tSystem.out.println(\\\"deux : \\\" + deuxFS);\\tSystem.out.println(\\\"un : \\\" + unFS); \\tSystem.out.println(\\\"un quart : \\\" + unQuartFS);\\tSystem.out.println(\\\"un demi \\ufffd\\ufffdgal \\ufffd\\ufffd inverse de deux: \\\" + unDemiFS.equals(deuxFS.inverse()));    }    public static void main(String[] args) {        /*\u003cvalidation/\u003e*/    }        public static double validationQ1F1(){        double note \u003d 0;        //@@@        return note;    }}\"": {
          "C1_SAME_TYPE_CONSTANT": "false",
          "C2_SAME_TYPE_CONSTANT_VAR": "false",
          "C2_SAME_TYPE_VAR": "false"
        }
      },
      "S10_METHOD_CALL_WITH_NULL_GUARD": "false",
      "S5_SIMILAR_PRIMITIVE_TYPE_WITH_NORMAL_GUARD": "false",
      "S2_SIMILAR_OBJECT_TYPE_WITH_NULL_GUARD": "false",
      "S4_Field_NOT_ASSIGNED": "false",
      "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_1": "",
      "S1_LOCAL_VAR_NOT_USED": "false",
      "S3_TYPE_OF_FAULTY_STATEMENT": "Field",
      "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_3": "",
      "S13_TYPE_OF_FAULTY_STATEMENT_AFTER_2": "",
      "S15_HAS_OBJECTIVE_METHOD_CALL": "false"
    }
  }
}