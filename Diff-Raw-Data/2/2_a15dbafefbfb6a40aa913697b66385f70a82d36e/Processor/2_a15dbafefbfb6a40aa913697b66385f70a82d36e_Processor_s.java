 /*******************************************************************************
  * Copyright (c) 2009 Siemens AG
  * 
  * All rights reserved. This program and the accompanying materials
  * are made available under the terms of the Eclipse Public License v1.0
  * which accompanies this distribution, and is available at
  * http://www.eclipse.org/legal/epl-v10.html
  *
  * Contributors:
  *    Kai Toedter - initial API and implementation
  *******************************************************************************/
 
 package com.siemens.ct.osgi.a4ds;
 
 import java.io.IOException;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Hashtable;
 import java.util.List;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 import javax.annotation.processing.AbstractProcessor;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedAnnotationTypes;
 import javax.annotation.processing.SupportedSourceVersion;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementScanner6;
 import javax.tools.Diagnostic;
 import javax.tools.FileObject;
 import javax.tools.StandardLocation;
 
 import org.jdom.Comment;
 import org.jdom.Document;
 import org.jdom.output.Format;
 import org.jdom.output.XMLOutputter;
 
 @SupportedAnnotationTypes(value = { "com.siemens.ct.osgi.a4ds.*" })
 @SupportedSourceVersion(SourceVersion.RELEASE_6)
 public class Processor extends AbstractProcessor {
 
 	private final Scanner scanner = new Scanner();
 	private org.jdom.Element component = null;
 	private Hashtable<String, org.jdom.Element> references = null;
 	private String outputDir = null;
 	private boolean errorsFound;
 
 	public String getOutputDir() {
 		return outputDir;
 	}
 
 	public void setOutputDir(String outputDir) {
 		this.outputDir = outputDir;
 	}
 
 	@Override
 	public boolean process(Set<? extends TypeElement> annotations,
 			RoundEnvironment roundEnv) {
 		errorsFound = false;
 		if (!roundEnv.processingOver()) {
 			Set<? extends Element> elements = roundEnv.getRootElements();
 
 			for (Element element : elements) {
 				component = null;
 				references = new Hashtable<String, org.jdom.Element>();
 
 				List<? extends AnnotationMirror> annotationMirrors = element
 						.getAnnotationMirrors();
 
 				for (AnnotationMirror mirror : annotationMirrors) {
 					final String annotationType = mirror.getAnnotationType()
 							.toString();
 					if (annotationType.equals(Component.class.getName())) {
 						component = new org.jdom.Element("component");
 						scanner.scan(element);
 					}
 				}
 
 				if (component != null && !errorsFound) {
 					Document doc = new Document();
 					doc.addContent(new Comment(
 							"Generated by A4DS - Do not edit"));
 					doc.setRootElement(component);
 					XMLOutputter fmt = new XMLOutputter();
 					Format format = Format.getPrettyFormat();
 					format.setIndent("    ");
 					fmt.setFormat(format);
 
 					OutputStream os = null;
 					try {
 						String fileName = component.getAttributeValue("name");
 						if (fileName.indexOf('.') != -1) {
 							fileName = fileName.substring(fileName
 									.lastIndexOf('.') + 1);
 						}
 						fileName += ".xml";
 						if (outputDir != null) {
 							fileName = outputDir + "/" + fileName;
 						}
 
 						final FileObject fo = processingEnv.getFiler()
 								.createResource(StandardLocation.SOURCE_OUTPUT,
 										"", fileName);
 						os = fo.openOutputStream();
 
 						fmt.output(doc, os);
 						processingEnv.getMessager().printMessage(
 								Diagnostic.Kind.NOTE,
 								"A4DS annotation processor: wrote file "
 										+ fo.toUri());
 
 					} catch (Throwable e1) {
 						// TODO Auto-generated catch block
 						e1.printStackTrace();
 					} finally {
 						try {
 							os.close();
 						} catch (IOException e) {
 							// TODO Auto-generated catch block
 							e.printStackTrace();
 						}
 					}
 				}
 			}
 		}
 		return false;
 	}
 
 	private class Scanner extends ElementScanner6<Void, Void> {
 		@Override
 		public Void visitType(TypeElement e, Void p) {
 			org.jdom.Element implementation = new org.jdom.Element(
 					"implementation");
 			implementation.setAttribute("class", e.toString());
 			component.getContent().add(implementation);
 			component.setAttribute("name", e.toString());
 			Component componentAnnotation = e.getAnnotation(Component.class);
 			if (componentAnnotation != null) {
 				List<String> interfaces2 = new ArrayList<String>();
 				String provides = componentAnnotation.provides();
 				List<? extends TypeMirror> interfaces = e.getInterfaces();
 				if (provides.trim().length() == 0) {
 					for (TypeMirror mirror : interfaces) {
 						interfaces2.add(mirror.toString());
 					}
 				} else {
 					StringTokenizer tokenizer = new StringTokenizer(provides
 							.trim(), ",");
 					while (tokenizer.hasMoreElements()) {
 						boolean foundInterface = false;
 						String interfaze = tokenizer.nextToken();
 						for (TypeMirror mirror : interfaces) {
 							if (interfaze.equals(mirror.toString())) {
 								interfaces2.add(interfaze);
 								foundInterface = true;
 							}
 						}
 						if (!foundInterface) {
 							processingEnv.getMessager().printMessage(
 									Diagnostic.Kind.ERROR,
									"class does not implement declared interface \""
 											+ interfaze + "\"", e);
 							errorsFound = true;
 						}
 					}
 				}
 				if (interfaces2.size() > 0 && component != null) {
 					org.jdom.Element service = new org.jdom.Element("service");
 					component.getContent().add(service);
 					for (String serviceInterface : interfaces2) {
 						org.jdom.Element provide = new org.jdom.Element(
 								"provide");
 						provide.setAttribute("interface", serviceInterface);
 						service.getContent().add(provide);
 					}
 				}
 
 			}
 			super.visitType(e, p);
 			return null;
 		}
 
 		@Override
 		public Void visitExecutable(ExecutableElement e, Void p) {
 			if (e.getKind() == ElementKind.METHOD) {
 				if (e.getAnnotation(Bind.class) != null
 						|| e.getAnnotation(Unbind.class) != null) {
 
 					String serviceInterface = e.getParameters().get(0).asType()
 							.toString();
 					org.jdom.Element reference = references
 							.get(serviceInterface);
 					if (reference == null) {
 						reference = new org.jdom.Element("reference");
 						references.put(serviceInterface, reference);
 						reference.setAttribute("name", serviceInterface);
 						component.getContent().add(reference);
 					}
 					reference.setAttribute("interface", serviceInterface);
 
 					String bindAttribute;
 					if (e.getAnnotation(Unbind.class) != null) {
 						bindAttribute = "unbind";
 					} else {
 						bindAttribute = "bind";
 						Bind bind = e.getAnnotation(Bind.class);
 						reference.setAttribute("cardinality", bind
 								.cardinality());
 						reference.setAttribute("policy", bind.policy());
 					}
 
 					reference.setAttribute(bindAttribute, e.getSimpleName()
 							.toString());
 				}
 			}
 			return null;
 		}
 	}
 }
