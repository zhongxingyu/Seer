 /**   
  * Copyright 2011 The Buzz Media, LLC
  * Additional work in this class Copyright 2009 Matthias Kaeppler
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 package com.thebuzzmedia.common.crypto;
 
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URLEncoder;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 
 import javax.crypto.Mac;
 import javax.crypto.SecretKey;
 import javax.crypto.spec.SecretKeySpec;
 
 import com.thebuzzmedia.common.charset.EncodingUtils;
 import com.thebuzzmedia.common.util.Base64;
 
 /**
  * Class used to provide OAuth-compatible functionality around the construction
  * of a signature base string and eventual signing of that string with a secret
  * key and an optional secret token key to generate an HMAC as defined by <a
  * href="http://tools.ietf.org/html/rfc5849#section-3.4">Section 3.4</a> of the
  * OAuth spec.
  * <p/>
  * The value generated by this class by way of one of the <code>sign(...)</code>
  * methods is meant to be used as the <code>oauth_signature</code> value in an
  * OAuth-compliant API call or as the signature for any other API using the same
  * methods for generating an HMAC to verify client calls.
  * <p/>
  * Using HMACs to secure HTTP-based web APIs is commonly used when <a href=
  * "http://www.thebuzzmedia.com/designing-a-secure-rest-api-without-oauth-authentication/"
  * >designing secure web-based APIs</a>.
  * <p/>
  * Since the OAuth spec clearly defines the process for normalizing, combining
  * and generating an HMAC from all these common query values, many web APIs
  * decide to simply follow the specification in this one regard (Section 3.4)
  * and use the same method for HMAC generation. So this class will make working
  * with APIs, following the OAuth spec with regards to signature/HMAC
  * generation, easier to write.
  * <p/>
  * This class can be used in a builder-pattern method, specifying the different
  * values to be signed on the fly or all passed to the constructor. This was
  * done for convenience.
  * 
  * @author Riyad Kalla (software@thebuzzmedia.com)
  * @since 2.3
  */
 public class OAuthSigner {
 	/**
 	 * All <code>String[]</code> data structures referenced by this class are
 	 * meant to be of length 2, with 'name' in the 0th index position and
 	 * 'value' in the 1st index position.
 	 * <p/>
 	 * This is a constant used to define the name's index, <code>0</code>.
 	 */
 	public static final int NAME_INDEX = 0;
 
 	/**
 	 * All <code>String[]</code> data structures referenced by this class are
 	 * meant to be of length 2, with 'name' in the 0th index position and
 	 * 'value' in the 1st index position.
 	 * <p/>
 	 * This is a constant used to define the value's index, <code>1</code>.
 	 */
 	public static final int VALUE_INDEX = 1;
 
 	private static final String UTF8 = "UTF-8";
 	private static final ParameterComparator COMPARATOR = new ParameterComparator();
 
 	/**
 	 * Used to define the different strengths of hashing algorithms this class
 	 * supports being used to hash the resultant signature base string.
 	 */
 	public enum Algorithm {
 		MD5("HmacMD5", "MD5"), SHA1("HmacSHA1", "SHA-1"), SHA256("HmacSHA256",
 				"SHA-256"), SHA512("HmacSHA512", "SHA-512");
 
 		private static final Map<String, Algorithm> FRIENDLY_NAME_MAP = new HashMap<String, OAuthSigner.Algorithm>(
 				13);
 
 		static {
 			FRIENDLY_NAME_MAP.put(MD5.friendlyName, MD5);
 			FRIENDLY_NAME_MAP.put(SHA1.friendlyName, SHA1);
 			FRIENDLY_NAME_MAP.put(SHA256.friendlyName, SHA256);
 			FRIENDLY_NAME_MAP.put(SHA512.friendlyName, SHA512);
 		}
 
 		public static Algorithm forFriendlyName(String friendlyName) {
 			return FRIENDLY_NAME_MAP.get(friendlyName);
 		}
 
 		public String getName() {
 			return name;
 		}
 
 		public String getFriendlyName() {
 			return friendlyName;
 		}
 
 		/**
 		 * Defined to match the "algorithm" argument understood by the
 		 * {@link Mac} class in the JDK.
 		 */
 		private String name;
 		private String friendlyName;
 
 		private Algorithm(String name, String friendlyName) {
 			this.name = name;
 			this.friendlyName = friendlyName;
 		}
 	}
 
 	private String requestMethod;
 	private String baseURI;
 	private List<String[]> paramList;
 
 	public OAuthSigner() {
 		// default constructor
 	}
 
 	public OAuthSigner(String requestMethod, String requestURL,
 			Map<String, String[]> paramMap, ParamFilter filter)
 			throws IllegalArgumentException, URISyntaxException {
 		requestMethod(requestMethod).baseURI(requestURL).params(paramMap,
 				filter);
 	}
 
 	public OAuthSigner(String requestMethod, String requestURL,
 			List<String[]> paramList, ParamFilter filter)
 			throws IllegalArgumentException, URISyntaxException {
 		requestMethod(requestMethod).baseURI(requestURL).params(paramList,
 				filter);
 	}
 
 	/**
 	 * Resets the state of the signer so it can be reused.
 	 */
 	public void reset() {
 		requestMethod = null;
 		baseURI = null;
 
 		if (paramList != null) {
 			paramList.clear();
 			paramList = null;
 		}
 	}
 
 	/**
 	 * Used to set the required "request method" as defined by <a
 	 * href="http://tools.ietf.org/html/rfc5849#section-3.4.1.1"> Section
 	 * 3.4.1.1</a> of the OAuth spec.
 	 * 
 	 * @param requestMethod
 	 *            The method name (e.g. GET, PUT, POST, DELETE, HEAD, OPTIONS,
 	 *            etc.) used to make the request.
 	 * 
 	 * @return a reference to this signer with the <code>requestMethod</code>
 	 *         property correctly set.
 	 * 
 	 * @throws IllegalArgumentException
 	 *             if <code>requestMethod</code> is <code>null</code>, empty or
 	 *             cannot be successfully URL encoded.
 	 */
 	public OAuthSigner requestMethod(String requestMethod)
 			throws IllegalArgumentException {
 		if (requestMethod == null || requestMethod.length() == 0)
 			throw new IllegalArgumentException(
 					"requestMethod cannot be null or empty");
 
 		try {
 			this.requestMethod = URLEncoder.encode(requestMethod.toUpperCase(),
 					UTF8);
 		} catch (Exception e) {
 			throw new IllegalArgumentException("requestMethod ["
 					+ requestMethod + "] could not be URL encoded.", e);
 		}
 
 		return this;
 	}
 
 	/**
 	 * Used to set the required "base string URI" as defined by <a
 	 * href="http://tools.ietf.org/html/rfc5849#section-3.4.1.2">section
 	 * 3.4.1.2</a> of the OAuth spec.
 	 * <p/>
 	 * This method parses the given request URL into a valid {@link URI} object
 	 * and then assembles the "base String URI" exactly as required by the OAuth
 	 * spec.
 	 * <p/>
 	 * Implementation logic for this method was copied from Matthias Kaeppler's
 	 * <a href=
 	 * "https://github.com/kaeppler/signpost/blob/master/signpost-core/src/main/java/oauth/signpost/signature/SignatureBaseString.java"
 	 * >signpost</a> OAuth implementation.
 	 * 
 	 * @param requestURL
 	 *            The request URL called by the client. This URL is intended to
 	 *            be from the Servlet API's
 	 *            <code>HttpServletRequest.getRequestURL()</code> method call
 	 *            and not include any of the query string.
 	 * 
 	 * @return a reference to this signer with the <code>baseURI</code> property
 	 *         correctly set.
 	 * 
 	 * @throws IllegalArgumentException
 	 *             if <code>requestURL</code> is <code>null</code>, empty or
 	 *             cannot be successfully URL encoded.
 	 * @throws URISyntaxException
 	 *             if an instance of {@link URI} cannot be cleanly created by
 	 *             parsing the given <code>requestURL</code> provided.
 	 */
 	public OAuthSigner baseURI(String requestURL)
 			throws IllegalArgumentException, URISyntaxException {
 		if (requestURL == null || requestURL.length() == 0)
 			throw new IllegalArgumentException(
 					"requestURL cannot be null or empty");
 
 		/*
 		 * Code originated from Matthias Kaeppler's signpost impl:
 		 * https://github.com
 		 * /kaeppler/signpost/blob/master/signpost-core/src/main
 		 * /java/oauth/signpost/signature/SignatureBaseString.java
 		 */
 		URI uri = new URI(requestURL);
 		String scheme = uri.getScheme();
 
 		if (scheme == null)
 			scheme = "";
 		else
 			scheme = scheme.toLowerCase();
 
 		String authority = uri.getAuthority().toLowerCase();
 		boolean dropPort = (scheme.equals("http") && uri.getPort() == 80)
 				|| (scheme.equals("https") && uri.getPort() == 443);
 
 		if (dropPort) {
 			// find the last : in the authority
 			int index = authority.lastIndexOf(":");
 			if (index >= 0) {
 				authority = authority.substring(0, index);
 			}
 		}
 
 		String path = uri.getRawPath();
 
 		if (path == null || path.length() <= 0) {
 			path = "/"; // conforms to RFC 2616 section 3.2.2
 		}
 
 		// we know that there is no query and no fragment here.
 		try {
 			this.baseURI = URLEncoder.encode(scheme + "://" + authority + path,
 					UTF8);
 		} catch (Exception e) {
 			throw new IllegalArgumentException("requestURL [" + requestURL
 					+ "] could not be successfully URL encoded.", e);
 		}
 
 		return this;
 	}
 
 	/**
 	 * Used to set (and normalize) the parameters found in the given {@link Map}
 	 * as outlined in <a
 	 * href="http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2">Section
 	 * 3.4.1.3.2</a> of the OAuth spec. This method eventually delegates to
 	 * {@link #params(List, ParamFilter)}.
 	 * <p/>
 	 * Signature generation automatically skips name/value pairs that either
 	 * have a null name or a null value.
 	 * <p>
 	 * Setting parameters for a signature generation is optional. If parameters
 	 * are excluded, then only the request method and base URI along with the
 	 * secret key will be used to calculate the signature.
 	 * 
 	 * @param paramMap
 	 *            A map of the parameter names and 1 or more values associated
 	 *            with each name. This can be retrieved easily from the Servlet
 	 *            API using the <code>ServletRequest.getParameterMap()</code>
 	 *            API call on the server side.
 	 * @param filter
 	 *            An optional filter used to filter out unwanted parameter names
 	 *            and values from the normalization and combination step used
 	 *            when generating the signature. For example, skipping the
 	 *            "oauth_signature" value on the server side when vetting a
 	 *            client call.
 	 * 
 	 * @return a reference to this signer with the parameters correct set.
 	 */
 	public OAuthSigner params(Map<String, String[]> paramMap, ParamFilter filter) {
 		if (paramMap == null || paramMap.isEmpty())
 			return this;
 
 		/*
 		 * We use an array to store the interim list of name/value pairings and
 		 * not a static array the same size of the map, because it is possible
 		 * that the map contains a single name with multiple values that will be
 		 * flattened out into n+1 values in the resulting paramList.
 		 */
 		this.paramList = new ArrayList<String[]>(paramMap.size());
 		Iterator<Entry<String, String[]>> entries = paramMap.entrySet()
 				.iterator();
 
 		// Iterate over all the parameters
 		while (entries.hasNext()) {
 			Entry<String, String[]> entry = entries.next();
 			String[] values = entry.getValue();
 
 			// Skip right over empty-valued params.
 			if (values == null || values.length == 0)
 				continue;
 
 			String name = entry.getKey();
 
 			// Process each value as a separate param.
 			for (int i = 0; i < values.length; i++) {
 				String value = values[i];
 
 				// Skip empty values
 				if (value == null || value.length() == 0)
 					continue;
 
 				// Filter name/value pair if filter provided.
 				if (filter != null && !filter.include(name, value))
 					continue;
 
 				// Add the name/value pair to our list.
 				paramList.add(new String[] { name, value });
 			}
 		}
 
 		// Pass a null filter because we already did the filter work above.
 		return params(paramList, null);
 	}
 
 	/**
 	 * Used to set (and normalize) the parameters found in the given
 	 * {@link List} as outlined in <a
 	 * href="http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2">Section
 	 * 3.4.1.3.2</a> of the OAuth spec.
 	 * <p/>
 	 * Each <code>String[]</code> is meant to be a single name/value pair where
 	 * the name is at index position 0 and the value is at index position 1.
 	 * <p/>
 	 * Names with duplicate values will simply have multiple
 	 * <code>String[]</code> values in the list, each with the same name but
 	 * different values.
 	 * <p/>
 	 * Signature generation automatically skips name/value pairs that either
 	 * have a null name or a null value.
 	 * <p>
 	 * Setting parameters for a signature generation is optional. If parameters
 	 * are excluded, then only the request method and base URI along with the
 	 * secret key will be used to calculate the signature.
 	 * 
 	 * @param paramList
 	 *            A list of name/value array pairs that are to be included in
 	 *            the signature calculation.
 	 * @param filter
 	 *            An optional filter used to filter out unwanted parameter names
 	 *            and values from the normalization and combination step used
 	 *            when generating the signature. For example, skipping the
 	 *            "oauth_signature" value on the server side when vetting a
 	 *            client call.
 	 * 
 	 * @return a reference to this signer with the parameters correct set.
 	 */
 	public OAuthSigner params(List<String[]> paramList, ParamFilter filter) {
 		if (paramList == null || paramList.isEmpty())
 			return this;
 
 		// Filter the param list if a filter was provided.
 		if (filter != null) {
			for (int i = 0, size = paramList.size(); i < size; i++) {
 				String[] pair = paramList.get(i);
 
 				if (pair != null
 						&& !filter.include(pair[NAME_INDEX], pair[VALUE_INDEX]))
 					paramList.remove(i);
 			}
 		}
 
 		/*
 		 * Normalize name/value pairs according to OAuth spec:
 		 * http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
 		 */
 		for (int i = 0, size = paramList.size(); i < size; i++) {
 			String[] pair = paramList.get(i);
 
 			/*
 			 * Only do the encode operation for the name OR value if neither is
 			 * null.
 			 */
 			if (pair[NAME_INDEX] != null && pair[VALUE_INDEX] != null) {
 				try {
 					pair[NAME_INDEX] = URLEncoder
 							.encode(pair[NAME_INDEX], UTF8);
 					pair[VALUE_INDEX] = URLEncoder.encode(pair[VALUE_INDEX],
 							UTF8);
 				} catch (Exception e) {
 					e.printStackTrace();
 					// no-op, continue to next pair.
 				}
 			}
 		}
 
 		/*
 		 * Sort the list of name/value pairs according to OAuth spec:
 		 * http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
 		 */
 		Collections.sort(paramList, COMPARATOR);
 		this.paramList = paramList;
 
 		return this;
 	}
 
 	/**
 	 * Used to generate an OAuth-compliant signature with all the properties set
 	 * on this signer and according to <a
 	 * href="http://tools.ietf.org/html/rfc5849#section-3.4.2">Section 3.4.2</a>
 	 * of the OAuth spec.
 	 * 
 	 * @param algorithm
 	 *            The hashing algorithm to use to generate the MAC.
 	 * @param secretKey
 	 *            The secret key or "client shared secret" used to sign the
 	 *            signature base string.
 	 * 
 	 * @return an OAuth-compliant signature for all the given properties set on
 	 *         this signer.
 	 * 
 	 * @throws IllegalStateException
 	 *             if the signer hasn't had the required properties set before
 	 *             this method is called.
 	 * @throws IllegalArgumentException
 	 *             if <code>algorithm</code> is <code>null</code> or
 	 *             <code>secretKey</code> is <code>null</code> or empty.
 	 * @throws RuntimeException
 	 *             if an exception occurs while trying to generate the MAC. The
 	 *             caller should be prepared to handle this failure scenario.
 	 */
 	public String sign(Algorithm algorithm, String secretKey)
 			throws IllegalStateException, IllegalArgumentException,
 			RuntimeException {
 		return sign(algorithm, secretKey, null);
 	}
 
 	/**
 	 * Used to generate an OAuth-compliant signature with all the properties set
 	 * on this signer and according to <a
 	 * href="http://tools.ietf.org/html/rfc5849#section-3.4.2">Section 3.4.2</a>
 	 * of the OAuth spec.
 	 * 
 	 * @param algorithm
 	 *            The hashing algorithm to use to generate the MAC.
 	 * @param secretKey
 	 *            The secret key or "client shared secret" used to sign the
 	 *            signature base string.
 	 * @param tokenKey
 	 *            An optionally token key or "token shared secret" to be applied
 	 *            to the MAC generation as well.
 	 * 
 	 * @return an OAuth-compliant signature for all the given properties set on
 	 *         this signer.
 	 * 
 	 * @throws IllegalStateException
 	 *             if the signer hasn't had the required properties set before
 	 *             this method is called.
 	 * @throws IllegalArgumentException
 	 *             if <code>algorithm</code> is <code>null</code> or
 	 *             <code>secretKey</code> is <code>null</code> or empty.
 	 * @throws RuntimeException
 	 *             if an exception occurs while trying to generate the MAC. The
 	 *             caller should be prepared to handle this failure scenario.
 	 */
 	public String sign(Algorithm algorithm, String secretKey, String tokenKey)
 			throws IllegalStateException, IllegalArgumentException,
 			RuntimeException {
 		if (requestMethod == null)
 			throw new IllegalStateException(
 					"Uninitialized Signer: Valid requestMethod has not been set.");
 		if (baseURI == null)
 			throw new IllegalStateException(
 					"Uninitialized Signer: Valid baseURI has not been set.");
 
 		if (algorithm == null)
 			throw new IllegalArgumentException("algorithm cannot be null");
 		if (secretKey == null || secretKey.length() == 0)
 			throw new IllegalArgumentException(
 					"secretKey cannot be null or empty");
 
 		StringBuilder buffer = new StringBuilder(256);
 
 		/*
 		 * Begin building the signature base string according to:
 		 * http://tools.ietf.org/html/rfc5849#section-3.4.1.1
 		 */
 		buffer.append(requestMethod).append('&');
 		buffer.append(baseURI).append('&');
 
 		// Process params if there are any set
 		if (paramList != null && !paramList.isEmpty()) {
 			/*
 			 * Concatenate all name/value pairs together in name=value pairings,
 			 * then append them all to each other using '&' separators as OAuth
 			 * requires: http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
 			 */
 			for (int i = 0, size = paramList.size(); i < size; i++) {
 				String[] pair = paramList.get(i);
 
 				// Skip pairs with any null values
 				if (pair[NAME_INDEX] != null && pair[VALUE_INDEX] != null)
 					buffer.append(pair[NAME_INDEX]).append('=')
 							.append(pair[VALUE_INDEX]).append('&');
 			}
 
 			// Trim the last spurious '&' that was appended
 			buffer.setLength(buffer.length() - 1);
 		}
 
 		byte[] hash = null;
 		StringBuilder keyBuffer = new StringBuilder(64);
 
 		try {
 			/*
 			 * Begin building the key signature according to:
 			 * http://tools.ietf.org/html/rfc5849#section-3.4.2
 			 */
 			keyBuffer.append(URLEncoder.encode(secretKey, UTF8)).append('&');
 
 			// Append tokenKey is included (3 legged OAuth)
 			if (tokenKey != null)
 				keyBuffer.append(URLEncoder.encode(tokenKey, UTF8));
 
 			char[] charBuffer = new char[keyBuffer.length()];
 			keyBuffer.getChars(0, charBuffer.length, charBuffer, 0);
 
 			// String.getBytes does ISO-8859-1 conversion, we want UTF8.
 			byte[] byteBuffer = EncodingUtils.encode(charBuffer);
 			SecretKey key = new SecretKeySpec(byteBuffer, algorithm.name);
 			Mac mac = Mac.getInstance(algorithm.name);
 
 			// Init with the secret key.
 			mac.init(key);
 
 			charBuffer = new char[buffer.length()];
 			buffer.getChars(0, charBuffer.length, charBuffer, 0);
 			byteBuffer = EncodingUtils.encode(charBuffer);
 
 			// Generate the actual HMAC signature.
 			hash = mac.doFinal(byteBuffer);
 		} catch (Exception e) {
 			throw new RuntimeException("Unable to generate an "
 					+ algorithm.name + " signature with the given values.", e);
 		}
 
 		String signature = null;
 
 		try {
 			/*
 			 * Per the OAuth spec
 			 * (http://tools.ietf.org/html/rfc5849#section-3.4.2) the hash must
 			 * be Base64-encoded using a URL-safe variant of Base64
 			 * (http://tools.ietf.org/html/rfc2045#section-6.8).
 			 */
 			signature = (hash == null ? null : Base64.encodeBytes(hash,
 					Base64.URL_SAFE));
 		} catch (Exception e) {
 			throw new RuntimeException(
 					"Unable to Base64 encode (URL safe) the given hash.", e);
 		}
 
 		return signature;
 	}
 
 	/**
 	 * An interface used to describe a simple parameter filter that can be
 	 * included along with a collection of parameters to include in the HMAC
 	 * generation.
 	 * <p/>
 	 * It is the filter's job to reject parameters that <strong>should
 	 * not</strong> be included in the generation, for example, if this code is
 	 * running on the server side, you would want to exclude the OAuth
 	 * <code>signature</code> that the client sent to you while recalculating
 	 * the HMAC. Additionally, you would want to exclude any null or empty
 	 * parameters that may have mistakeningly been set.
 	 * 
 	 * @author Riyad Kalla (software@thebuzzmedia.com)
 	 */
 	public interface ParamFilter {
 		public boolean include(String name, String value);
 	}
 
 	/**
 	 * Comparator used to sort the <code>String[]</code> of length 2 used by
 	 * this API to represent a name/value pair.
 	 * 
 	 * @author Riyad Kalla (software@thebuzzmedia.com)
 	 */
 	static class ParameterComparator implements Comparator<String[]> {
 		/**
 		 * Used internally by {@link OAuthSigner} to sort the params before
 		 * normalizing them according to the OAuth spec.
 		 * <p/>
 		 * Names are compared first and then values only if the names are equal.
 		 * 
 		 * @return <code>-1</code> if <code>param1</code> is &lt;
 		 *         <code>param2</code>, <code>0</code> if both params are
 		 *         considered equal or <code>1</code> if <code>param1</code> is
 		 *         &gt; <code>param2</code>.
 		 * 
 		 * @throws RuntimeException
 		 *             if any of the <code>String[]</code> processed have
 		 *             lengths that are not equal to 2.
 		 */
 		public int compare(String[] param1, String[] param2)
 				throws RuntimeException {
 			// Begin with the assumption they are equal.
 			int value = 0;
 
 			// Only continue checking if they ARE NOT equal.
 			if (param1 != param2) {
 				if (param1 == null && param2 != null)
 					value = -1;
 				else if (param1 != null && param2 == null)
 					value = 1;
 				else {
 					// Sanity-check
 					if (param1.length != 2 && param2.length != 2)
 						throw new RuntimeException(
 								"String[] parameter values included in the parameterList have mismatching lengths. All String[] must be of length 2, with param name at index 0 and param value at index 1.");
 
 					// First, compare the names.
 					value = param1[NAME_INDEX].compareTo(param2[NAME_INDEX]);
 
 					// Only if the names were the same, should we compare the
 					// values.
 					if (value == 0)
 						value = param1[VALUE_INDEX]
 								.compareTo(param2[VALUE_INDEX]);
 				}
 
 			}
 
 			return value;
 		}
 	}
 }
