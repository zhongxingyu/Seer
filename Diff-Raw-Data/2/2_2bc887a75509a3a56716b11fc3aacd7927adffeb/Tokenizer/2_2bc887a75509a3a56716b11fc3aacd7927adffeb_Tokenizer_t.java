 /* The following code was generated by JFlex 1.4.3 on 5/28/12 12:27 PM */
 
package haw.ci.lib;
 
 import static haw.ci.lib.Tokens.*;
 import static haw.ci.lib.Yytoken.*;
 import haw.ci.lib.Yytoken;
 import java.io.IOException;
 
 
 /**
  * This class is a scanner generated by 
  * <a href="http://www.jflex.de/">JFlex</a> 1.4.3
  * on 5/28/12 12:27 PM from the specification file
  * <tt>haw/ci/lib/Tokenizer.flex</tt>
  */
 public class Tokenizer implements ITokenStream {
 
   /** This character denotes the end of file */
   public static final int YYEOF = -1;
 
   /** initial size of the lookahead buffer */
   private static final int ZZ_BUFFERSIZE = 16384;
 
   /** lexical states */
   public static final int YYINITIAL = 0;
 
   /**
    * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
    * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
    *                  at the beginning of a line
    * l is of the form l = 2*k, k a non negative integer
    */
   private static final int ZZ_LEXSTATE[] = { 
      0, 0
   };
 
   /** 
    * Translates characters to character classes
    */
   private static final String ZZ_CMAP_PACKED = 
     "\11\0\1\1\1\1\25\0\1\1\7\0\1\5\1\25\1\26\1\27"+
     "\1\36\1\30\1\4\1\31\12\3\1\32\1\37\1\34\1\33\1\35"+
     "\2\0\1\42\1\45\1\52\1\56\1\46\1\60\1\47\1\64\1\50"+
     "\2\2\1\57\1\61\1\51\1\53\1\63\1\2\1\43\1\54\1\55"+
     "\1\62\1\65\1\66\1\2\1\44\1\2\1\40\1\0\1\41\1\0"+
     "\1\2\1\0\1\6\1\45\1\20\1\56\1\15\1\60\1\47\1\11"+
     "\1\17\2\2\1\7\1\14\1\12\1\53\1\10\1\2\1\16\1\24"+
     "\1\23\1\13\1\65\1\22\1\2\1\44\1\2\1\0\1\21\uff83\0";
 
   /** 
    * Translates characters to character classes
    */
   private static final char [] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);
 
   /** 
    * Translates DFA states to action switch labels.
    */
   private static final int [] ZZ_ACTION = zzUnpackAction();
 
   private static final String ZZ_ACTION_PACKED_0 =
     "\1\1\1\2\1\1\1\3\1\4\1\5\1\6\12\3"+
     "\1\7\1\10\1\11\1\12\1\13\1\14\1\15\1\16"+
     "\1\17\1\20\1\21\1\22\1\23\4\3\1\0\7\3"+
     "\1\24\4\3\1\25\1\26\1\27\1\3\1\30\1\31"+
     "\1\3\1\0\6\3\1\32\10\3\1\33\1\0\5\3"+
     "\1\34\1\3\1\35\4\3\1\36\1\37\1\3\1\0"+
     "\1\40\1\41\1\3\1\42\1\3\1\43\2\3\1\44"+
     "\1\45\1\46\1\0\1\3\1\47\1\50\1\51\1\0"+
     "\1\3\1\0\1\3\1\0\1\52\20\0\1\53";
 
   private static int [] zzUnpackAction() {
     int [] result = new int[127];
     int offset = 0;
     offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
     return result;
   }
 
   private static int zzUnpackAction(String packed, int offset, int [] result) {
     int i = 0;       /* index in packed string  */
     int j = offset;  /* index in unpacked array */
     int l = packed.length();
     while (i < l) {
       int count = packed.charAt(i++);
       int value = packed.charAt(i++);
       do result[j++] = value; while (--count > 0);
     }
     return j;
   }
 
 
   /** 
    * Translates a state to a row index in the transition table
    */
   private static final int [] ZZ_ROWMAP = zzUnpackRowMap();
 
   private static final String ZZ_ROWMAP_PACKED_0 =
     "\0\0\0\67\0\156\0\245\0\334\0\67\0\u0113\0\u014a"+
     "\0\u0181\0\u01b8\0\u01ef\0\u0226\0\u025d\0\u0294\0\u02cb\0\u0302"+
     "\0\u0339\0\67\0\67\0\67\0\67\0\67\0\u0370\0\67"+
     "\0\u03a7\0\u03de\0\67\0\67\0\67\0\67\0\u0415\0\u044c"+
     "\0\u0483\0\u04ba\0\u04f1\0\u0528\0\u055f\0\u0596\0\u05cd\0\u0604"+
     "\0\u063b\0\u0672\0\245\0\u06a9\0\u06e0\0\u0717\0\u074e\0\67"+
     "\0\67\0\67\0\u0785\0\245\0\245\0\u07bc\0\u07f3\0\u082a"+
     "\0\u0861\0\u0898\0\u08cf\0\u0906\0\u093d\0\245\0\u0974\0\u09ab"+
     "\0\u09e2\0\u0a19\0\u0a50\0\u0a87\0\u0abe\0\u0af5\0\245\0\u0b2c"+
     "\0\u0b63\0\u0b9a\0\u0bd1\0\u0c08\0\u0c3f\0\245\0\u0c76\0\245"+
     "\0\u0cad\0\u0ce4\0\u0d1b\0\u0d52\0\245\0\245\0\u0d89\0\u0dc0"+
     "\0\245\0\245\0\u0df7\0\245\0\u0e2e\0\245\0\u0e65\0\u0e9c"+
     "\0\245\0\245\0\245\0\u0ed3\0\u0f0a\0\245\0\245\0\245"+
     "\0\u0f41\0\u0f78\0\u0faf\0\u0fe6\0\u101d\0\245\0\u1054\0\u108b"+
     "\0\u10c2\0\u10f9\0\u1130\0\u1167\0\u119e\0\u11d5\0\u120c\0\u1243"+
     "\0\u127a\0\u12b1\0\u12e8\0\u131f\0\u1356\0\u138d\0\67";
 
   private static int [] zzUnpackRowMap() {
     int [] result = new int[127];
     int offset = 0;
     offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
     return result;
   }
 
   private static int zzUnpackRowMap(String packed, int offset, int [] result) {
     int i = 0;  /* index in packed string  */
     int j = offset;  /* index in unpacked array */
     int l = packed.length();
     while (i < l) {
       int high = packed.charAt(i++) << 16;
       result[j++] = high | packed.charAt(i++);
     }
     return j;
   }
 
   /** 
    * The transition table of the DFA
    */
   private static final int [] ZZ_TRANS = zzUnpackTrans();
 
   private static final String ZZ_TRANS_PACKED_0 =
     "\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\4"+
     "\1\11\2\4\1\12\1\13\1\14\1\15\1\16\1\17"+
     "\1\2\1\20\1\21\1\4\1\22\1\23\1\24\1\25"+
     "\1\26\1\27\1\30\1\31\1\32\1\33\1\34\1\35"+
     "\1\36\1\10\1\15\1\4\1\37\1\14\1\4\1\16"+
     "\1\4\1\17\1\40\1\4\1\21\1\41\2\4\1\13"+
     "\1\12\1\11\1\4\1\42\1\20\70\0\1\3\67\0"+
     "\2\4\2\0\13\4\1\0\3\4\15\0\25\4\2\0"+
     "\1\4\1\5\2\0\13\4\1\0\3\4\15\0\25\4"+
     "\6\0\1\43\62\0\2\4\2\0\10\4\1\44\2\4"+
     "\1\0\3\4\15\0\1\4\1\44\23\4\2\0\2\4"+
     "\2\0\10\4\1\45\2\4\1\0\3\4\15\0\1\4"+
     "\1\45\23\4\2\0\2\4\2\0\4\4\1\46\6\4"+
     "\1\0\3\4\15\0\7\4\1\46\15\4\2\0\2\4"+
     "\2\0\13\4\1\0\3\4\15\0\11\4\1\47\13\4"+
     "\2\0\2\4\2\0\1\4\1\50\2\4\1\51\6\4"+
     "\1\0\3\4\15\0\7\4\1\51\5\4\1\50\7\4"+
     "\2\0\2\4\2\0\7\4\1\52\3\4\1\0\3\4"+
     "\15\0\4\4\1\52\20\4\2\0\2\4\2\0\13\4"+
     "\1\0\3\4\15\0\16\4\1\53\6\4\2\0\2\4"+
     "\2\0\13\4\1\0\3\4\15\0\11\4\1\54\13\4"+
     "\2\0\2\4\2\0\3\4\1\55\7\4\1\0\3\4"+
     "\15\0\22\4\1\55\2\4\2\0\2\4\2\0\3\4"+
     "\1\56\7\4\1\0\3\4\15\0\2\4\1\57\17\4"+
     "\1\56\2\4\33\0\1\60\66\0\1\61\66\0\1\62"+
     "\35\0\2\4\2\0\7\4\1\63\3\4\1\0\3\4"+
     "\15\0\4\4\1\63\20\4\2\0\2\4\2\0\13\4"+
     "\1\0\3\4\15\0\16\4\1\64\6\4\2\0\2\4"+
     "\2\0\13\4\1\0\3\4\15\0\11\4\1\65\13\4"+
     "\2\0\2\4\2\0\1\66\12\4\1\0\3\4\15\0"+
     "\1\66\24\4\7\0\1\67\61\0\2\4\2\0\10\4"+
     "\1\70\2\4\1\0\3\4\15\0\1\4\1\70\23\4"+
     "\2\0\2\4\2\0\11\4\1\71\1\4\1\0\3\4"+
     "\15\0\6\4\1\71\2\4\1\72\13\4\2\0\2\4"+
     "\2\0\13\4\1\0\1\4\1\73\1\4\15\0\13\4"+
     "\1\73\11\4\2\0\2\4\2\0\13\4\1\0\3\4"+
     "\15\0\14\4\1\74\10\4\2\0\2\4\2\0\13\4"+
     "\1\0\2\4\1\75\15\0\12\4\1\75\12\4\2\0"+
     "\2\4\2\0\13\4\1\0\3\4\15\0\14\4\1\76"+
     "\10\4\2\0\2\4\2\0\1\77\1\4\1\100\7\4"+
     "\1\101\1\0\3\4\15\0\1\77\7\4\1\101\10\4"+
     "\1\100\3\4\2\0\2\4\2\0\4\4\1\102\6\4"+
     "\1\0\3\4\15\0\7\4\1\102\15\4\2\0\2\4"+
     "\2\0\11\4\1\103\1\4\1\0\3\4\15\0\6\4"+
     "\1\103\16\4\2\0\2\4\2\0\7\4\1\104\3\4"+
     "\1\0\3\4\15\0\4\4\1\104\20\4\2\0\2\4"+
     "\2\0\2\4\1\105\10\4\1\0\3\4\15\0\21\4"+
     "\1\105\3\4\2\0\2\4\2\0\13\4\1\0\3\4"+
     "\15\0\5\4\1\106\17\4\2\0\2\4\2\0\10\4"+
     "\1\107\2\4\1\0\3\4\15\0\1\4\1\107\23\4"+
     "\10\0\1\110\60\0\2\4\2\0\1\111\12\4\1\0"+
     "\3\4\15\0\1\111\24\4\2\0\2\4\2\0\4\4"+
     "\1\112\6\4\1\0\3\4\15\0\7\4\1\112\15\4"+
     "\2\0\2\4\2\0\12\4\1\113\1\0\3\4\15\0"+
     "\10\4\1\113\14\4\2\0\2\4\2\0\11\4\1\114"+
     "\1\4\1\0\3\4\15\0\6\4\1\114\16\4\2\0"+
     "\2\4\2\0\5\4\1\115\5\4\1\0\3\4\15\0"+
     "\20\4\1\115\4\4\2\0\2\4\2\0\7\4\1\116"+
     "\1\4\1\117\1\4\1\0\3\4\15\0\4\4\1\116"+
     "\1\4\1\117\16\4\2\0\2\4\2\0\13\4\1\0"+
     "\3\4\15\0\14\4\1\120\10\4\2\0\2\4\2\0"+
     "\7\4\1\121\3\4\1\0\3\4\15\0\4\4\1\121"+
     "\20\4\2\0\2\4\2\0\13\4\1\0\3\4\15\0"+
     "\11\4\1\122\13\4\2\0\2\4\2\0\13\4\1\0"+
     "\2\4\1\123\15\0\12\4\1\123\12\4\2\0\2\4"+
     "\2\0\1\4\1\124\11\4\1\0\3\4\15\0\15\4"+
     "\1\124\7\4\2\0\2\4\2\0\4\4\1\125\6\4"+
     "\1\0\3\4\15\0\7\4\1\125\15\4\2\0\2\4"+
     "\2\0\7\4\1\126\3\4\1\0\3\4\15\0\4\4"+
     "\1\126\20\4\2\0\2\4\2\0\11\4\1\127\1\4"+
     "\1\0\3\4\15\0\6\4\1\127\16\4\11\0\1\130"+
     "\57\0\2\4\2\0\13\4\1\0\3\4\15\0\2\4"+
     "\1\131\22\4\2\0\2\4\2\0\13\4\1\0\1\4"+
     "\1\132\1\4\15\0\13\4\1\132\11\4\2\0\2\4"+
     "\2\0\7\4\1\133\3\4\1\0\3\4\15\0\4\4"+
     "\1\133\20\4\2\0\2\4\2\0\1\4\1\134\11\4"+
     "\1\0\3\4\15\0\15\4\1\134\7\4\2\0\2\4"+
     "\2\0\1\4\1\135\11\4\1\0\3\4\15\0\15\4"+
     "\1\135\7\4\2\0\2\4\2\0\13\4\1\0\3\4"+
     "\15\0\16\4\1\136\6\4\2\0\2\4\2\0\1\137"+
     "\12\4\1\0\3\4\15\0\1\137\24\4\2\0\2\4"+
     "\2\0\10\4\1\140\2\4\1\0\3\4\15\0\1\4"+
     "\1\140\23\4\2\0\2\4\2\0\13\4\1\0\1\4"+
     "\1\141\1\4\15\0\13\4\1\141\11\4\2\0\2\4"+
     "\2\0\7\4\1\142\3\4\1\0\3\4\15\0\4\4"+
     "\1\142\20\4\2\0\2\4\2\0\4\4\1\143\6\4"+
     "\1\0\3\4\15\0\7\4\1\143\15\4\6\0\1\144"+
     "\62\0\2\4\2\0\13\4\1\0\3\4\15\0\14\4"+
     "\1\145\10\4\2\0\2\4\2\0\7\4\1\146\3\4"+
     "\1\0\3\4\15\0\4\4\1\146\20\4\2\0\2\4"+
     "\2\0\13\4\1\0\1\4\1\147\1\4\15\0\13\4"+
     "\1\147\11\4\2\0\2\4\2\0\13\4\1\0\3\4"+
     "\15\0\14\4\1\150\10\4\12\0\1\151\56\0\2\4"+
     "\2\0\5\4\1\152\5\4\1\0\3\4\15\0\20\4"+
     "\1\152\4\4\13\0\1\153\55\0\2\4\2\0\10\4"+
     "\1\154\2\4\1\0\3\4\15\0\1\4\1\154\23\4"+
     "\14\0\1\155\54\0\2\4\2\0\7\4\1\156\3\4"+
     "\1\0\3\4\15\0\4\4\1\156\20\4\15\0\1\157"+
     "\67\0\1\160\67\0\1\161\67\0\1\162\67\0\1\163"+
     "\67\0\1\164\55\0\1\165\74\0\1\166\72\0\1\167"+
     "\60\0\1\170\75\0\1\171\52\0\1\172\64\0\1\173"+
     "\100\0\1\174\63\0\1\175\76\0\1\176\67\0\1\177"+
     "\40\0";
 
   private static int [] zzUnpackTrans() {
     int [] result = new int[5060];
     int offset = 0;
     offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
     return result;
   }
 
   private static int zzUnpackTrans(String packed, int offset, int [] result) {
     int i = 0;       /* index in packed string  */
     int j = offset;  /* index in unpacked array */
     int l = packed.length();
     while (i < l) {
       int count = packed.charAt(i++);
       int value = packed.charAt(i++);
       value--;
       do result[j++] = value; while (--count > 0);
     }
     return j;
   }
 
 
   /* error codes */
   private static final int ZZ_UNKNOWN_ERROR = 0;
   private static final int ZZ_NO_MATCH = 1;
   private static final int ZZ_PUSHBACK_2BIG = 2;
 
   /* error messages for the codes above */
   private static final String ZZ_ERROR_MSG[] = {
     "Unkown internal scanner error",
     "Error: could not match input",
     "Error: pushback value was too large"
   };
 
   /**
    * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
    */
   private static final int [] ZZ_ATTRIBUTE = zzUnpackAttribute();
 
   private static final String ZZ_ATTRIBUTE_PACKED_0 =
     "\1\1\1\11\3\1\1\11\13\1\5\11\1\1\1\11"+
     "\2\1\4\11\4\1\1\0\14\1\3\11\4\1\1\0"+
     "\20\1\1\0\17\1\1\0\13\1\1\0\4\1\1\0"+
     "\1\1\1\0\1\1\1\0\1\1\20\0\1\11";
 
   private static int [] zzUnpackAttribute() {
     int [] result = new int[127];
     int offset = 0;
     offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
     return result;
   }
 
   private static int zzUnpackAttribute(String packed, int offset, int [] result) {
     int i = 0;       /* index in packed string  */
     int j = offset;  /* index in unpacked array */
     int l = packed.length();
     while (i < l) {
       int count = packed.charAt(i++);
       int value = packed.charAt(i++);
       do result[j++] = value; while (--count > 0);
     }
     return j;
   }
 
   /** the input device */
   private java.io.Reader zzReader;
 
   /** the current state of the DFA */
   private int zzState;
 
   /** the current lexical state */
   private int zzLexicalState = YYINITIAL;
 
   /** this buffer contains the current text to be matched and is
       the source of the yytext() string */
   private char zzBuffer[] = new char[ZZ_BUFFERSIZE];
 
   /** the textposition at the last accepting state */
   private int zzMarkedPos;
 
   /** the current text position in the buffer */
   private int zzCurrentPos;
 
   /** startRead marks the beginning of the yytext() string in the buffer */
   private int zzStartRead;
 
   /** endRead marks the last character in the buffer, that has been read
       from input */
   private int zzEndRead;
 
   /** number of newlines encountered up to the start of the matched text */
   private int yyline;
 
   /** the number of characters up to the start of the matched text */
   private int yychar;
 
   /**
    * the number of characters from the last newline up to the start of the 
    * matched text
    */
   private int yycolumn;
 
   /** 
    * zzAtBOL == true <=> the scanner is currently at the beginning of a line
    */
   private boolean zzAtBOL = true;
 
   /** zzAtEOF == true <=> the scanner is at the EOF */
   private boolean zzAtEOF;
 
   /** denotes if the user-EOF-code has already been executed */
   private boolean zzEOFDone;
 
   /* user code: */
 	public Yytoken nextToken() {
 		try {
 			return yylex();
 		} catch (IOException e) {
 			return null;
 		}
 	}
 
 
   /**
    * Creates a new scanner
    * There is also a java.io.InputStream version of this constructor.
    *
    * @param   in  the java.io.Reader to read input from.
    */
   public Tokenizer(java.io.Reader in) {
     this.zzReader = in;
   }
 
   /**
    * Creates a new scanner.
    * There is also java.io.Reader version of this constructor.
    *
    * @param   in  the java.io.Inputstream to read input from.
    */
   public Tokenizer(java.io.InputStream in) {
     this(new java.io.InputStreamReader(in));
   }
 
   /** 
    * Unpacks the compressed character translation table.
    *
    * @param packed   the packed character translation table
    * @return         the unpacked character translation table
    */
   private static char [] zzUnpackCMap(String packed) {
     char [] map = new char[0x10000];
     int i = 0;  /* index in packed string  */
     int j = 0;  /* index in unpacked array */
     while (i < 160) {
       int  count = packed.charAt(i++);
       char value = packed.charAt(i++);
       do map[j++] = value; while (--count > 0);
     }
     return map;
   }
 
 
   /**
    * Refills the input buffer.
    *
    * @return      <code>false</code>, iff there was new input.
    * 
    * @exception   java.io.IOException  if any I/O-Error occurs
    */
   private boolean zzRefill() throws java.io.IOException {
 
     /* first: make room (if you can) */
     if (zzStartRead > 0) {
       System.arraycopy(zzBuffer, zzStartRead,
                        zzBuffer, 0,
                        zzEndRead-zzStartRead);
 
       /* translate stored positions */
       zzEndRead-= zzStartRead;
       zzCurrentPos-= zzStartRead;
       zzMarkedPos-= zzStartRead;
       zzStartRead = 0;
     }
 
     /* is the buffer big enough? */
     if (zzCurrentPos >= zzBuffer.length) {
       /* if not: blow it up */
       char newBuffer[] = new char[zzCurrentPos*2];
       System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
       zzBuffer = newBuffer;
     }
 
     /* finally: fill the buffer with new input */
     int numRead = zzReader.read(zzBuffer, zzEndRead,
                                             zzBuffer.length-zzEndRead);
 
     if (numRead > 0) {
       zzEndRead+= numRead;
       return false;
     }
     // unlikely but not impossible: read 0 characters, but not at end of stream    
     if (numRead == 0) {
       int c = zzReader.read();
       if (c == -1) {
         return true;
       } else {
         zzBuffer[zzEndRead++] = (char) c;
         return false;
       }     
     }
 
 	// numRead < 0
     return true;
   }
 
     
   /**
    * Closes the input stream.
    */
   public final void yyclose() throws java.io.IOException {
     zzAtEOF = true;            /* indicate end of file */
     zzEndRead = zzStartRead;  /* invalidate buffer    */
 
     if (zzReader != null)
       zzReader.close();
   }
 
 
   /**
    * Resets the scanner to read from a new input stream.
    * Does not close the old reader.
    *
    * All internal variables are reset, the old input stream 
    * <b>cannot</b> be reused (internal buffer is discarded and lost).
    * Lexical state is set to <tt>ZZ_INITIAL</tt>.
    *
    * @param reader   the new input stream 
    */
   public final void yyreset(java.io.Reader reader) {
     zzReader = reader;
     zzAtBOL  = true;
     zzAtEOF  = false;
     zzEOFDone = false;
     zzEndRead = zzStartRead = 0;
     zzCurrentPos = zzMarkedPos = 0;
     yyline = yychar = yycolumn = 0;
     zzLexicalState = YYINITIAL;
   }
 
 
   /**
    * Returns the current lexical state.
    */
   public final int yystate() {
     return zzLexicalState;
   }
 
 
   /**
    * Enters a new lexical state
    *
    * @param newState the new lexical state
    */
   public final void yybegin(int newState) {
     zzLexicalState = newState;
   }
 
 
   /**
    * Returns the text matched by the current regular expression.
    */
   public final String yytext() {
     return new String( zzBuffer, zzStartRead, zzMarkedPos-zzStartRead );
   }
 
 
   /**
    * Returns the character at position <tt>pos</tt> from the 
    * matched text. 
    * 
    * It is equivalent to yytext().charAt(pos), but faster
    *
    * @param pos the position of the character to fetch. 
    *            A value from 0 to yylength()-1.
    *
    * @return the character at position pos
    */
   public final char yycharat(int pos) {
     return zzBuffer[zzStartRead+pos];
   }
 
 
   /**
    * Returns the length of the matched text region.
    */
   public final int yylength() {
     return zzMarkedPos-zzStartRead;
   }
 
 
   /**
    * Reports an error that occured while scanning.
    *
    * In a wellformed scanner (no or only correct usage of 
    * yypushback(int) and a match-all fallback rule) this method 
    * will only be called with things that "Can't Possibly Happen".
    * If this method is called, something is seriously wrong
    * (e.g. a JFlex bug producing a faulty scanner etc.).
    *
    * Usual syntax/scanner level error handling should be done
    * in error fallback rules.
    *
    * @param   errorCode  the code of the errormessage to display
    */
   private void zzScanError(int errorCode) {
     String message;
     try {
       message = ZZ_ERROR_MSG[errorCode];
     }
     catch (ArrayIndexOutOfBoundsException e) {
       message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
     }
 
     throw new Error(message);
   } 
 
 
   /**
    * Pushes the specified amount of characters back into the input stream.
    *
    * They will be read again by then next call of the scanning method
    *
    * @param number  the number of characters to be read again.
    *                This number must not be greater than yylength()!
    */
   public void yypushback(int number)  {
     if ( number > yylength() )
       zzScanError(ZZ_PUSHBACK_2BIG);
 
     zzMarkedPos -= number;
   }
 
 
   /**
    * Resumes scanning until the next regular expression is matched,
    * the end of input is encountered or an I/O-Error occurs.
    *
    * @return      the next token
    * @exception   java.io.IOException  if any I/O-Error occurs
    */
   public Yytoken yylex() throws java.io.IOException {
     int zzInput;
     int zzAction;
 
     // cached fields:
     int zzCurrentPosL;
     int zzMarkedPosL;
     int zzEndReadL = zzEndRead;
     char [] zzBufferL = zzBuffer;
     char [] zzCMapL = ZZ_CMAP;
 
     int [] zzTransL = ZZ_TRANS;
     int [] zzRowMapL = ZZ_ROWMAP;
     int [] zzAttrL = ZZ_ATTRIBUTE;
 
     while (true) {
       zzMarkedPosL = zzMarkedPos;
 
       yychar+= zzMarkedPosL-zzStartRead;
 
       boolean zzR = false;
       for (zzCurrentPosL = zzStartRead; zzCurrentPosL < zzMarkedPosL;
                                                              zzCurrentPosL++) {
         switch (zzBufferL[zzCurrentPosL]) {
         case '\u000B':
         case '\u000C':
         case '\u0085':
         case '\u2028':
         case '\u2029':
           yyline++;
           yycolumn = 0;
           zzR = false;
           break;
         case '\r':
           yyline++;
           yycolumn = 0;
           zzR = true;
           break;
         case '\n':
           if (zzR)
             zzR = false;
           else {
             yyline++;
             yycolumn = 0;
           }
           break;
         default:
           zzR = false;
           yycolumn++;
         }
       }
 
       if (zzR) {
         // peek one character ahead if it is \n (if we have counted one line too much)
         boolean zzPeek;
         if (zzMarkedPosL < zzEndReadL)
           zzPeek = zzBufferL[zzMarkedPosL] == '\n';
         else if (zzAtEOF)
           zzPeek = false;
         else {
           boolean eof = zzRefill();
           zzEndReadL = zzEndRead;
           zzMarkedPosL = zzMarkedPos;
           zzBufferL = zzBuffer;
           if (eof) 
             zzPeek = false;
           else 
             zzPeek = zzBufferL[zzMarkedPosL] == '\n';
         }
         if (zzPeek) yyline--;
       }
       zzAction = -1;
 
       zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;
   
       zzState = ZZ_LEXSTATE[zzLexicalState];
 
 
       zzForAction: {
         while (true) {
     
           if (zzCurrentPosL < zzEndReadL)
             zzInput = zzBufferL[zzCurrentPosL++];
           else if (zzAtEOF) {
             zzInput = YYEOF;
             break zzForAction;
           }
           else {
             // store back cached positions
             zzCurrentPos  = zzCurrentPosL;
             zzMarkedPos   = zzMarkedPosL;
             boolean eof = zzRefill();
             // get translated positions and possibly new buffer
             zzCurrentPosL  = zzCurrentPos;
             zzMarkedPosL   = zzMarkedPos;
             zzBufferL      = zzBuffer;
             zzEndReadL     = zzEndRead;
             if (eof) {
               zzInput = YYEOF;
               break zzForAction;
             }
             else {
               zzInput = zzBufferL[zzCurrentPosL++];
             }
           }
           int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];
           if (zzNext == -1) break zzForAction;
           zzState = zzNext;
 
           int zzAttributes = zzAttrL[zzState];
           if ( (zzAttributes & 1) == 1 ) {
             zzAction = zzState;
             zzMarkedPosL = zzCurrentPosL;
             if ( (zzAttributes & 8) == 8 ) break zzForAction;
           }
 
         }
       }
 
       // store back cached position
       zzMarkedPos = zzMarkedPosL;
 
       switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
         case 39: 
           { return token(MODULE, yyline, yycolumn);
           }
         case 44: break;
         case 18: 
           { return token(BRACE_SQUARE_OPEN, yyline, yycolumn);
           }
         case 45: break;
         case 40: 
           { return token(REPEAT, yyline, yycolumn);
           }
         case 46: break;
         case 34: 
           { return token(UNTIL, yyline, yycolumn);
           }
         case 47: break;
         case 3: 
           { return token(IDENTIFER, yyline, yycolumn, yytext());
           }
         case 48: break;
         case 32: 
           { return token(ARRAY, yyline, yycolumn);
           }
         case 49: break;
         case 14: 
           { return token(LESS, yyline, yycolumn);
           }
         case 50: break;
         case 12: 
           { return token(COLON, yyline, yycolumn);
           }
         case 51: break;
         case 29: 
           { return token(READ, yyline, yycolumn);
           }
         case 52: break;
         case 8: 
           { return token(MATH_MUL, yyline, yycolumn);
           }
         case 53: break;
         case 23: 
           { return token(MORE_EQUAL, yyline, yycolumn);
           }
         case 54: break;
         case 33: 
           { return token(PRINT, yyline, yycolumn);
           }
         case 55: break;
         case 20: 
           { return token(IF, yyline, yycolumn);
           }
         case 56: break;
         case 41: 
           { return token(RECORD, yyline, yycolumn);
           }
         case 57: break;
         case 5: 
           { return token(DOT, yyline, yycolumn);
           }
         case 58: break;
         case 42: 
           { return token(PROCEDURE, yyline, yycolumn);
           }
         case 59: break;
         case 31: 
           { return token(TYPE, yyline, yycolumn);
           }
         case 60: break;
         case 21: 
           { return token(ASSIGN, yyline, yycolumn);
           }
         case 61: break;
         case 27: 
           { return token(VAR, yyline, yycolumn);
           }
         case 62: break;
         case 30: 
           { return token(THEN, yyline, yycolumn);
           }
         case 63: break;
         case 26: 
           { return token(END, yyline, yycolumn);
           }
         case 64: break;
         case 19: 
           { return token(BRACE_SQUARE_CLOSE, yyline, yycolumn);
           }
         case 65: break;
         case 4: 
           { return token(INTEGER, yyline, yycolumn, yytext());
           }
         case 66: break;
         case 17: 
           { return token(SEMICOLON, yyline, yycolumn);
           }
         case 67: break;
         case 6: 
           { return token(BRACE_ROUND_OPEN, yyline, yycolumn);
           }
         case 68: break;
         case 9: 
           { return token(MATH_ADD, yyline, yycolumn);
           }
         case 69: break;
         case 35: 
           { return token(ELSIF, yyline, yycolumn);
           }
         case 70: break;
         case 24: 
           { return token(OF, yyline, yycolumn);
           }
         case 71: break;
         case 13: 
           { return token(EQUAL, yyline, yycolumn);
           }
         case 72: break;
         case 2: 
           { System.out.println("Illegal char, '" + yytext() + "' line: " + yyline + ", column: " + yycolumn);
           }
         case 73: break;
         case 15: 
           { return token(MORE, yyline, yycolumn);
           }
         case 74: break;
         case 36: 
           { return token(CONST, yyline, yycolumn);
           }
         case 75: break;
         case 10: 
           { return token(MATH_SUB, yyline, yycolumn);
           }
         case 76: break;
         case 37: 
           { return token(WHILE, yyline, yycolumn);
           }
         case 77: break;
         case 22: 
           { return token(LESS_EQUAL, yyline, yycolumn);
           }
         case 78: break;
         case 28: 
           { return token(ELSE, yyline, yycolumn);
           }
         case 79: break;
         case 38: 
           { return token(BEGIN, yyline, yycolumn);
           }
         case 80: break;
         case 43: 
           { return token(STRING, yyline, yycolumn, yytext());
           }
         case 81: break;
         case 7: 
           { return token(BRACE_ROUND_CLOSE, yyline, yycolumn);
           }
         case 82: break;
         case 11: 
           { return token(MATH_DIV, yyline, yycolumn);
           }
         case 83: break;
         case 16: 
           { return token(COMMA, yyline, yycolumn);
           }
         case 84: break;
         case 25: 
           { return token(DO, yyline, yycolumn);
           }
         case 85: break;
         case 1: 
           { 
           }
         case 86: break;
         default: 
           if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
             zzAtEOF = true;
             return null;
           } 
           else {
             zzScanError(ZZ_NO_MATCH);
           }
       }
     }
   }
 
 
 }
