 /**
  * IdemixService.java
  * 
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  * 
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  * 
  * You should have received a copy of the GNU General Public License
  * along with this program. If not, see <http://www.gnu.org/licenses/>.
  * 
  * Copyright (C) Pim Vullers, Radboud University Nijmegen, June 2011.
  */
 
 package service;
 
 import java.math.BigInteger;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.TreeMap;
 import java.util.Vector;
 
 import javax.smartcardio.CommandAPDU;
 import javax.smartcardio.ResponseAPDU;
 
 import net.sourceforge.scuba.smartcards.CardService;
 import net.sourceforge.scuba.smartcards.CardServiceException;
 import net.sourceforge.scuba.smartcards.ISO7816;
 import net.sourceforge.scuba.util.Hex;
 
 import com.ibm.zurich.idmx.api.ProverInterface;
 import com.ibm.zurich.idmx.api.RecipientInterface;
 import com.ibm.zurich.idmx.dm.Credential;
 import com.ibm.zurich.idmx.dm.MasterSecret;
 import com.ibm.zurich.idmx.dm.Values;
 import com.ibm.zurich.idmx.dm.structure.AttributeStructure;
 import com.ibm.zurich.idmx.dm.structure.CredentialStructure;
 import com.ibm.zurich.idmx.issuance.IssuanceSpec;
 import com.ibm.zurich.idmx.issuance.Message;
 import com.ibm.zurich.idmx.issuance.Message.IssuanceProtocolValues;
 import com.ibm.zurich.idmx.key.IssuerPublicKey;
 import com.ibm.zurich.idmx.showproof.Identifier;
 import com.ibm.zurich.idmx.showproof.Proof;
 import com.ibm.zurich.idmx.showproof.ProofSpec;
 import com.ibm.zurich.idmx.showproof.predicates.CLPredicate;
 import com.ibm.zurich.idmx.showproof.predicates.Predicate;
 import com.ibm.zurich.idmx.showproof.predicates.Predicate.PredicateType;
 import com.ibm.zurich.idmx.showproof.sval.SValue;
 import com.ibm.zurich.idmx.showproof.sval.SValuesProveCL;
 import com.ibm.zurich.idmx.utils.StructureStore;
 
 /**
  * Idemix Smart Card Interface based on a SCUBA Card Service.
  *  
  * @author Pim Vullers
  * @version $Revision: 554 $ by $Author: pim $
  *          $LastChangedDate: 2011-04-28 16:31:47 +0200 (Thu, 28 Apr 2011) $
  */
 public class IdemixService extends CardService implements ProverInterface, RecipientInterface {
     /**
      * Control the amount of output generated by this class.
      */
     private static final boolean VERBOSE = true;
 
     /**
      * Universal version identifier to match versions during deserialisation.
      */
     private static final long serialVersionUID = -6317383635196413L;
 
     /**
      * AID of the Idemix applet: ASCII encoding of "idemix".
      */
     private static final byte[] AID = {0x69, 0x64, 0x65, 0x6D, 0x69, 0x78};
 
     /**
      * CLAss to be used for Idemix APDUs.
      */
     private static final byte CLA_IDEMIX = 0x00;
 
     /**
      * INStruction to select an applet.
      */
     private static final byte INS_SELECT = (byte) 0xA4;
 
     /**
      * INStruction to set the various test modes of the card (on, off, reset).
      */
     private static final byte INS_TESTMODE = (byte) 0xFF;
 
     /**
      * INStruction to perform precomputation of inputs.
      */
     private static final byte INS_PRECOMPUTE_INPUTS = 0x0D;
 
     /**
      * INStruction to send the first nonce (n_1) and compute/receive the 
      * combined hidden attributes (U).
      * 
      * @protocol token issuance.
      */
     private static final byte INS_NONCE1 = 0x10;
 
     /**
      * INStruction to receive the zero-knowledge proof for correct construction 
      * of U (c, v^', s_A). 
      * 
      * @protocol token issuance.
      */
     private static final byte INS_PROOF_U = 0x11;
 
     /**
      * INStruction to receive the second nonce (n_2). 
      * 
      * @protocol token issuance.
      */
     private static final byte INS_NONCE2 = 0x12;
 
     /**
      * INStruction to send the blind signature (A, e, v''). 
      * 
      * @protocol token issuance.
      */
     private static final byte INS_SIGNATURE = 0x13;
 
     /**
      * INStruction to send the zero-knowledge proof for correct construction of 
      * the signature (s_e, c'). 
      * 
      * @protocol token issuance.
      */
     private static final byte INS_PROOF_A = 0x14;
 
     /**
      * INStruction to send the list of attributes to be disclosed (D).
      * 
      * @protocol attribute disclosure / presentation proof generation. 
      */
     private static final byte INS_ATTRIBUTE_DISCLOSURE = 0x20;
 
     /**
      * INStruction to send the challenge (m) to be signed in the proof and 
      * receive the commitment for the proof (a). 
      * 
      * @protocol attribute disclosure / presentation proof generation. 
      */
     private static final byte INS_CHALLENGE = 0x21;
 
     /**
      * INStruction to receive the values A', e^ and v^. 
      * 
      * @protocol attribute disclosure / proof generation. 
      */
     private static final byte INS_RANDOM_SIGNATURE = 0x22;
 
     /**
      * INStruction to receive the disclosed attributes (A_i).
      * 
      * @protocol attribute disclosure / proof generation. 
      */
     private static final byte INS_DISCLOSED_ATTRIBUTES = 0x23;
 
     /**
      * INStruction to receive the values for the undisclosed attributes (r_i). 
      * 
      * @protocol attribute disclosure / proof generation. 
      */
     private static final byte INS_UNDISCLOSED_ATTRIBUTES = 0x24;
 
     /**
      * Initialisation instructions (getters)
      */
     private static final byte INS_SET_PUBLIC_KEY_N = 0x00;
     private static final byte INS_SET_PUBLIC_KEY_Z = 0x01;
     private static final byte INS_SET_PUBLIC_KEY_S = 0x02;
     private static final byte INS_SET_PUBLIC_KEY_R = 0x03;
     private static final byte INS_SET_CONTEXT = 0x04;
     private static final byte INS_SET_MASTER_SECRET = 0x05;
     private static final byte INS_SET_ATTRIBUTES = 0x06;
 
     /**
      * Retrieval instructions (getters)
      */
     private static final byte INS_GET_PUBLIC_KEY_N = 0x30;
     private static final byte INS_GET_PUBLIC_KEY_Z = 0x31;
     private static final byte INS_GET_PUBLIC_KEY_S = 0x32;
     private static final byte INS_GET_PUBLIC_KEY_R = 0x33;
     private static final byte INS_GET_CONTEXT = 0x34;
     private static final byte INS_GET_MASTER_SECRET = 0x35;
     private static final byte INS_GET_ATTRIBUTES = 0x36;
     private static final byte INS_GET_NUMBER_OF_ATTRIBUTES = 0x3C;
 
     /**
      * SCUBA service to communicate with the card.
      */
     protected CardService service;
 
     /**************************************************************************/
     /* SCUBA / Smart Card Setup                                               */
     /**************************************************************************/
 
     /**
      * Construct a new Idemix service based on some CardService, which will be
      * used for the actual communication with an Idemix applet.
      * 
      * @param service the service to use for communication with the applet.
      */
     public IdemixService(CardService service) {
         this.service = service;
     }
 
     /**
      * Open a communication channel to an Idemix applet.
      */
     public void open() 
     throws CardServiceException {
         if (!isOpen()) {
             service.open();
         }
         selectApplet();
     }
 
     /**
      * Check whether a communication channel with a smart card exists.
      * 
      * @return whether the channel is open or not.
      */
     public boolean isOpen() {
         return service.isOpen();
     }
 
     /**
      * Send an APDU over the communication channel to the smart card.
      * 
      * @param apdu the APDU to be send to the smart card.
      * @return ResponseAPDU the response from the smart card.
      * @throws CardServiceException if some error occurred while transmitting.
      */
     public ResponseAPDU transmit(CommandAPDU capdu) 
     throws CardServiceException { 
 
         if (VERBOSE) {
             System.out.println();
             System.out.println("C: " + Hex.bytesToHexString(capdu.getBytes()));    		
         }
 
         long start = System.nanoTime();
         ResponseAPDU rapdu = service.transmit(capdu);
         long duration = (System.nanoTime() - start)/1000000;
 
         if (VERBOSE) {
             System.out.println(" duration: " + duration + " ms");
             System.out.println("R: " + Hex.bytesToHexString(rapdu.getBytes()));
         }
 
         return rapdu;
     }
 
     /**
      * Close the communication channel with the Idemix applet.
      */
     public void close() {
         if (service != null) {
             service.close();
         }
     }
 
     /**
      * Select the Idemix applet on the smart card.
      * 
      * @throws CardServiceException if an error occurred.
      */
     public void selectApplet() 
     throws CardServiceException {
         CommandAPDU select = new CommandAPDU(ISO7816.CLA_ISO7816,  
                 INS_SELECT, 0x04, 0x00, AID, 256); // LE == 0 is required.
         ResponseAPDU response = transmit(select);
         if (response.getSW() != 0x00009000) {
             throw new CardServiceException("Could not select the Idemix " +
                     "applet.", response.getSW());
         }
     }
 
 
     /**
      * Configure the test mode of the smart card.
      * 
      * @param mode the test mode (0x00 is off, 0x01 is on, 0x02 is clear).
      * @throws CardServiceException if an error occurred.
      */
     public void testMode(byte mode)
     throws CardServiceException {
         CommandAPDU command = new CommandAPDU(CLA_IDEMIX, 
                 INS_TESTMODE, mode, 0x00);
         ResponseAPDU response = transmit(command);
         if (response.getSW() != 0x00009000) {
             throw new CardServiceException("Could not set test mode.", 
                     response.getSW());
         }       
     }
 
     /**
      * Report about commands not supported by the smart card. 
      */
     protected void notSupported(String message) {
         System.err.println();
         System.err.println(message);
         System.err.println("This command is NOT supported by the smart card.");
         System.err.println();
     }
 
     /**
      * Produces an unsigned byte-array representation of a BigInteger.
      *
      * <p>BigInteger adds an extra sign bit to the beginning of its byte
      * array representation.  In some cases this will cause the size
      * of the byte array to increase, which may be unacceptable for some
      * applications. This function returns a minimal byte array representing
      * the BigInteger without extra sign bits.
      *
      * <p>This method is taken from the Network Security Services for Java (JSS)
      * currently maintained by the Mozilla Foundation and originally developed 
      * by the Netscape Communications Corporation.
      * 
      * @return unsigned big-endian byte array representation of a BigInteger.
      */
     public static byte[] BigIntegerToUnsignedByteArray(BigInteger big) {
         byte[] ret;
 
         // big must not be negative
         assert(big.signum() != -1);
 
         // bitLength is the size of the data without the sign bit.  If
         // it exactly fills an integral number of bytes, that means a whole
         // new byte will have to be added to accommodate the sign bit. In
         // this case we need to remove the first byte.
         if(big.bitLength() % 8 == 0) {
             byte[] array = big.toByteArray();
             // The first byte should just be sign bits
             assert( array[0] == 0 );
             ret = new byte[array.length-1];
             System.arraycopy(array, 1, ret, 0, ret.length);
         } else {
             ret = big.toByteArray();
         }
         return ret;
     }
     
     /**
      * Fix the length of arrays put into the APDUs.
      * 
      * @param array of which the length needs to be fixed.
      * @return an array with a fixed length.
      */
     public static byte[] fixLength(byte[] array) {        
         if (array.length % 4 == 0) {
             return array;
         } else {
             int padding = 4 - array.length % 4;
             byte[] fixed = new byte[array.length + padding];
             Arrays.fill(fixed, (byte) 0x00);
             System.arraycopy(array, 0, fixed, padding, array.length);
             return fixed;
         }
     }
     
     /**
      * Fix the length of array representation of BigIntegers put into the APDUs.
      * 
      * @param integer of which the length needs to be fixed.
      * @return an array with a fixed length.
      */
     public static byte[] fixLength(BigInteger integer) {
         return fixLength(BigIntegerToUnsignedByteArray(integer));
     }
     
     /**
      * Fix the length of array representation of BigIntegers put into the APDUs.
      * 
      * @param integer of which the length needs to be fixed.
      * @return an array with a fixed length.
      */
     public static byte[] fixLength(BigInteger integer, int length) {
         byte[] array = BigIntegerToUnsignedByteArray(integer);
         if (array.length <= length) {
             int padding = length - array.length;
             byte[] fixed = new byte[length];
             Arrays.fill(fixed, (byte) 0x00);
             System.arraycopy(array, 0, fixed, padding, array.length);
             return fixed;
         } else {
             return fixLength(array);
         }
     }
 
     /**************************************************************************/
     /* Idemix Smart Card Interface                                           */
     /**************************************************************************/
 
     
     /**
      * Set the specification of a certificate issuance: 
      * 
      * <ul>
      *   <li> issuer public key, and 
      *   <li> context. 
      * </ul>
      * 
      * @param spec the specification to be set.
      * @throws CardServiceException if an error occurred.
      */
     public void setIssuanceSpecification(IssuanceSpec spec) 
     throws CardServiceException {
         // issuer parameters
         setPublicKey(spec.getPublicKey(), 
         		spec.getCredentialStructure().getAttributeStructs().size() + 1);
 
         // context
         setContext(spec.getContext());
     }
     
     /**
      * Set the Issuer's public key:
      * 
      * <pre>
      *   n, Z, S, R_0, ..., R_l
      * </pre>
      * 
      * @param pubKey the public key to be set.
      * @throws CardServiceException if an error occurred.
      */
     void setPublicKey(IssuerPublicKey pubKey, int pubKeyElements) 
     throws CardServiceException {
         CommandAPDU command_n = new CommandAPDU(CLA_IDEMIX, 
                 INS_SET_PUBLIC_KEY_N, 0x00, 0x00, fixLength(pubKey.getN()));
         ResponseAPDU response_n = transmit(command_n);
         if (response_n.getSW() != 0x00009000) {
             if (response_n.getSW() == 0x00006D00) {
                 notSupported("Could not set public key.");
             } else {
                 throw new CardServiceException("Could not set public key " +
                         "modulus (n).", response_n.getSW());
             }
         }
         
         CommandAPDU command_z = new CommandAPDU(CLA_IDEMIX, 
                 INS_SET_PUBLIC_KEY_Z, 0x00, 0x00, fixLength(pubKey.getCapZ()));
         ResponseAPDU response_z = transmit(command_z);
         if (response_z.getSW() != 0x00009000) {
             if (response_z.getSW() == 0x00006D00) {
                 notSupported("Could not set public key.");
             } else {
                 throw new CardServiceException("Could not set public key " +
                         "element (Z).", response_z.getSW());
             }
         }
         
         CommandAPDU command_s = new CommandAPDU(CLA_IDEMIX, 
                 INS_SET_PUBLIC_KEY_S, 0x00, 0x00, fixLength(pubKey.getCapS()));
         ResponseAPDU response_s = transmit(command_s);
         if (response_s.getSW() != 0x00009000) {
             if (response_s.getSW() == 0x00006D00) {
                 notSupported("Could not set public key.");
             } else {
                 throw new CardServiceException("Could not set public key " +
                         "modulus (n).", response_s.getSW());
             }
         }
         
         BigInteger[] pubKeyElement = pubKey.getCapR();
         for (int i = 0; i < pubKeyElements; i++) {
             CommandAPDU command = new CommandAPDU(CLA_IDEMIX, 
                     INS_SET_PUBLIC_KEY_R, i, pubKeyElement.length, 
                     fixLength(pubKeyElement[i]));
             ResponseAPDU response = transmit(command);
             if (response.getSW() != 0x00009000) {
                 if (response.getSW() == 0x00006D00) {
                     notSupported("Could not set public key elements.");
                 } else {
                     throw new CardServiceException("Could not set public key " +
                             "element (R@index " + i + ").", response.getSW());
                 }
             }
         }
     }
 
     /**
      * Get the Issuer's public key: 
      * 
      * <pre>
      *   n, Z, S, R_0, ..., R_l
      * </pre>
      * 
      * @return the public key, or null if not supported.
      * @throws CardServiceException if an error occurred.
      */
     IssuerPublicKey getPublicKey() 
     throws CardServiceException {
         CommandAPDU command_n = new CommandAPDU(CLA_IDEMIX, 
                 INS_GET_PUBLIC_KEY_N, 0x00, 0x00);
         ResponseAPDU response_n = transmit(command_n);
         if (response_n.getSW() != 0x00009000) {
             if (response_n.getSW() == 0x00006D00) {
                 notSupported("Could not get public key.");
                 return null;
             } else {
                 throw new CardServiceException("Could not get public key " +
                         "modulus (n).", response_n.getSW());
             }
         }
         BigInteger n = new BigInteger(response_n.getData());
         
         CommandAPDU command_z = new CommandAPDU(CLA_IDEMIX, 
                 INS_GET_PUBLIC_KEY_Z, 0x00, 0x00);
         ResponseAPDU response_z = transmit(command_z);
         if (response_z.getSW() != 0x00009000) {
             if (response_z.getSW() == 0x00006D00) {
                 notSupported("Could not get public key.");
                 return null;
             } else {
                 throw new CardServiceException("Could not get public key " +
                         "element (Z).", response_z.getSW());
             }
         }
         BigInteger Z = new BigInteger(response_z.getData());
         
         CommandAPDU command_s = new CommandAPDU(CLA_IDEMIX, 
                 INS_GET_PUBLIC_KEY_S, 0x00, 0x00);
         ResponseAPDU response_s = transmit(command_s);
         if (response_s.getSW() != 0x00009000) {
             if (response_s.getSW() == 0x00006D00) {
                 notSupported("Could not get public key.");
                 return null;
             } else {
                 throw new CardServiceException("Could not get public key " +
                         "element (S).", response_s.getSW());
             }
         }
         BigInteger S = new BigInteger(response_s.getData());
         
         
         BigInteger[] R = new BigInteger[getNumberOfAttributes() + 1];
         for (int i = 0; i < R.length; i++) {
             CommandAPDU command_r = new CommandAPDU(CLA_IDEMIX, 
                     INS_GET_PUBLIC_KEY_R, i, R.length);
             ResponseAPDU response_r = transmit(command_r);
             if (response_r.getSW() != 0x00009000) {
                 if (response_r.getSW() == 0x00006D00) {
                     notSupported("Could not get public key elements.");
                     return null;
                 } else {
                     throw new CardServiceException("Could not get public key " +
                             "element (R@index " + i + ").", response_r.getSW());
                 }
             }
             R[i] = new BigInteger(response_r.getData());
         }
 
         return new IssuerPublicKey(null, S, Z, R, n, 0);
     }  
     
     /**
      * Set the context: 
      * 
      * <pre>
      *   context
      * </pre>
      * 
      * @param context the context to be set.
      * @throws CardServiceException if an error occurred.
      */
     void setContext(BigInteger context) 
     throws CardServiceException {
         CommandAPDU command = new CommandAPDU(CLA_IDEMIX, 
                 INS_SET_CONTEXT, 0x00, 0x00, fixLength(context));
         ResponseAPDU response = transmit(command);
         if (response.getSW() != 0x00009000) {
             if (response.getSW() == 0x00006D00) {
                 notSupported("Could not set context.");
             } else {
                 throw new CardServiceException("Could not set context.", 
                         response.getSW());
             }
         }
     }
 
     /**
      * Get the context: 
      * 
      * <pre>
      *   context
      * </pre>
      * 
      * @return the context, or null if not supported.
      * @throws CardServiceException if an error occurred.
      */
     BigInteger getContext() 
     throws CardServiceException {
         CommandAPDU command = new CommandAPDU(CLA_IDEMIX, 
                 INS_GET_CONTEXT, 0x00, 0x00);
         ResponseAPDU response = transmit(command);
         if (response.getSW() != 0x00009000) {
             if (response.getSW() == 0x00006D00) {
                 notSupported("Could not get context.");
                 return null;
             } else {
                 throw new CardServiceException("Could not get context.", 
                         response.getSW());
             }
         }
 
         return new BigInteger(response.getData());
     }
 
     /**
      * Set or generate the master secret: 
      * 
      * <pre>
      *   m_0
      * </pre>
      * 
      * @param masterSecret the master secret to be set or null to generate one.
      * @throws CardServiceException if an error occurred.
      */
     public void setMasterSecret(MasterSecret masterSecret) 
     throws CardServiceException {
         CommandAPDU command = new CommandAPDU(CLA_IDEMIX, 
                 INS_SET_MASTER_SECRET, 0x00, 0x00, 
                 fixLength(masterSecret.getValue()));
         ResponseAPDU response = transmit(command);
         if (response.getSW() != 0x00009000) {
             if (response.getSW() == 0x00006D00) {
                 notSupported("Could not set master secret.");
             } else {
                 throw new CardServiceException("Could not set master secret.", 
                         response.getSW());
             }
         }
     }
 
     /**
      * Get the master secret: 
      * 
      * <pre>
      *   m_0
      * </pre>
      * 
      * @return the master secret, or null if not supported.
      * @throws CardServiceException if an error occurred.
      */
     BigInteger getMasterSecret() 
     throws CardServiceException {
         CommandAPDU command = new CommandAPDU(CLA_IDEMIX, 
                 INS_GET_MASTER_SECRET, 0x00, 0x00);
         ResponseAPDU response = transmit(command);
         if (response.getSW() != 0x00009000) {
             if (response.getSW() == 0x00006D00) {
                 notSupported("Could not get master secret.");
                 return null;
             } else {
                 throw new CardServiceException("Could not get master secret.", 
                         response.getSW());
             }
         }
 
         return new BigInteger(response.getData());
     }
 
     /**
      * Set the attributes: 
      * 
      * <pre>
      *   m_1, ..., m_l
      * </pre>
      * 
      * @param spec the issuance specification for the ordering of the values.
      * @param values the attributes to be set.
      * @throws CardServiceException if an error occurred.
      */
     public void setAttributes(IssuanceSpec spec, Values values) 
     throws CardServiceException {
         Vector<AttributeStructure> structs = spec.getCredentialStructure().getAttributeStructs();
         int i = 1, l_m = spec.getPublicKey().getGroupParams().getSystemParams().getL_m()/8;
         for (AttributeStructure struct : structs) {
             BigInteger attr = (BigInteger) values.get(struct.getName()).getContent();
             CommandAPDU command = new CommandAPDU(CLA_IDEMIX, 
                     INS_SET_ATTRIBUTES, i++, structs.size(), fixLength(attr, l_m));
             ResponseAPDU response = transmit(command);
             if (response.getSW() != 0x00009000) {
                 if (response.getSW() == 0x00006D00) {
                     notSupported("Could not set attributes.");
                 } else {                
                     throw new CardServiceException("Could not set attribute " +
                     		"(m@index " + (i + 1) + ").", response.getSW());
                 }
             }
         }
     }
     
     /**
      * Get the number of attributes available.
      * 
      * @return the number of attributes.
      * @throws CardServiceException if an error occurred.
      */
     public int getNumberOfAttributes() 
     throws CardServiceException {
         CommandAPDU command = new CommandAPDU(CLA_IDEMIX, 
                 INS_GET_NUMBER_OF_ATTRIBUTES, 0x00, 0x00);
         ResponseAPDU response = transmit(command);
         if (response.getSW() != 0x00009000) {
             throw new CardServiceException("Could not get number of " +
                     "attributes.", response.getSW());
         }
 
         return response.getData()[0];
     }
     
     /**
      * Get the attributes: 
      * 
      * <pre>
      *   A_1, ..., A_n
      * </pre>
      * 
      * @return the token attributes, or null if not supported.
      * @throws CardServiceException if an error occurred.
      */
     Values getAttributes(IssuanceSpec spec) 
     throws CardServiceException {
         Values values = new Values(null);
         Vector<AttributeStructure> structs = spec.getCredentialStructure().getAttributeStructs();
         int i = 1;
         for (AttributeStructure struct : structs) {
             CommandAPDU command = new CommandAPDU(CLA_IDEMIX, 
                     INS_GET_ATTRIBUTES, i + 1, structs.size());
             ResponseAPDU response = transmit(command);
             if (response.getSW() != 0x00009000) {
                 if (response.getSW() == 0x00006D00) {
                     notSupported("Could not get token attributes.");
                     return null;
                 } else {
                     throw new CardServiceException("Could not get token " +
                             "attribute (@index " + (i + 1) + ").", 
                             response.getSW());
                 }
             }
             values.add(struct.getName(), new BigInteger(response.getData()));
         }
 
         return values;
     }
     
     /**
      * Perform issuance precomputation. 
      * 
      * <pre>
      *   compute R = R_1^(m_1) ... R_l^(m_l) 
      * </pre>
      * 
      * This is the first operation that takes place in the protocol. This method
      * may be invoked to perform precomputation independently from generation of
      * the first issuance protocol message.
      * 
      * @implements Prover.precomputation()
      */
     public void precomputation() 
     throws CardServiceException {
         CommandAPDU command = new CommandAPDU(CLA_IDEMIX, 
                 INS_PRECOMPUTE_INPUTS, 0x00, 0x00);
         ResponseAPDU response = transmit(command);
         if (response.getSW() != 0x00009000) {
             if (response.getSW() == 0x00006D00) {
                 notSupported("Could not perform precomputation.");
             } else { 
                 throw new CardServiceException("Could not perform " +
                 		"precomputation.", response.getSW());
             }
         }       
     }
     
     /**
      * @param theNonce1
      *            Nonce provided by the verifier.
      * @return Message containing the proof about the hidden and committed
      *         attributes sent to the Issuer.
      */
     public Message round1(final Message msg) {
         HashMap<IssuanceProtocolValues, BigInteger> issuanceProtocolValues = 
             new HashMap<IssuanceProtocolValues, BigInteger>();
         HashMap<String, SValue> sValues = new HashMap<String, SValue>();
         TreeMap<String, BigInteger> additionalValues = 
             new TreeMap<String, BigInteger>();
         BigInteger theNonce1 = msg.getIssuanceElement(
                 IssuanceProtocolValues.nonce_recipient);
 
         // Hide CardServiceExceptions, instead return null on failure
         try {
             // send Nonce and receive U 
             CommandAPDU nonce_n1 = new CommandAPDU(CLA_IDEMIX, 
                     INS_NONCE1, 0x00, 0x00, BigIntegerToUnsignedByteArray(theNonce1));
             ResponseAPDU response_n1 = transmit(nonce_n1);
             if (response_n1.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not issue nonce n1.", 
                         response_n1.getSW());
             }
             issuanceProtocolValues.put(IssuanceProtocolValues.capU, 
                     new BigInteger(1, response_n1.getData()));        
 
             // receive Proof
             CommandAPDU proof_c = new CommandAPDU(CLA_IDEMIX, 
                     INS_PROOF_U, 0x00, 0x00);
             ResponseAPDU response_c = transmit(proof_c);
             if (response_c.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not issue proof c.", 
                         response_c.getSW());
             }
             BigInteger challenge = new BigInteger(1, response_c.getData());
 
             CommandAPDU proof_vHatPrime = new CommandAPDU(CLA_IDEMIX, 
                     INS_PROOF_U, 0x01, 0x00);
             ResponseAPDU response_vHatPrime = transmit(proof_vHatPrime);
             if (response_vHatPrime.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not issue proof v^'.", 
                         response_vHatPrime.getSW());
             }
             additionalValues.put(IssuanceSpec.vHatPrime, 
                     new BigInteger(1, response_vHatPrime.getData()));
 
             CommandAPDU proof_s_A = new CommandAPDU(CLA_IDEMIX, 
                     INS_PROOF_U, 0x02, 0x00);
             ResponseAPDU response_s_A = transmit(proof_s_A);
             if (response_s_A.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not issue proof s_A.", 
                         response_s_A.getSW());
             }
             sValues.put(IssuanceSpec.MASTER_SECRET_NAME,
                     new SValue(new BigInteger(1, response_s_A.getData())));
 
             // receive Nonce
             CommandAPDU nonce_n2 = new CommandAPDU(CLA_IDEMIX, 
                     INS_NONCE2, 0x00, 0x00);
             ResponseAPDU response_n2 = transmit(nonce_n2);
             if (response_n2.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not issue nonce n2.", 
                         response_n2.getSW());
             }
             issuanceProtocolValues.put(IssuanceProtocolValues.nonce_recipient, 
                     new BigInteger(1, response_n2.getData()));
 
             // Return the next protocol message
             return new Message(issuanceProtocolValues, 
                     new Proof(challenge, sValues, additionalValues));
             
         // Report caught exceptions
         } catch (CardServiceException e) {
             System.err.println(e.getMessage() + "\n");
             e.printStackTrace();
             return null;
         }
     }
 
     /**
      * Called with the second protocol flow as input, outputs the Credential.
      * This is the last step of the issuance protocol, where the Recipient
      * verifies that the signature is valid and outputs it.
      * 
      * @param msg
      *            the second flow of the protocol, a message from the Issuer
      * @return the Credential, if it's valid, null otherwise.
      */
     public Credential round3(final Message msg) {
         // Hide CardServiceExceptions, instead return null on failure
         try {
             // send Signature
             BigInteger capA = msg.getIssuanceElement(IssuanceProtocolValues.capA);
             CommandAPDU signature_capA = new CommandAPDU(CLA_IDEMIX, 
                     INS_SIGNATURE, 0x00, 0x00, BigIntegerToUnsignedByteArray(capA));
             ResponseAPDU response_capA = transmit(signature_capA);
             if (response_capA.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not issue signature A.", 
                         response_capA.getSW());
             }
 
             BigInteger e = msg.getIssuanceElement(IssuanceProtocolValues.e);
             CommandAPDU signature_e = new CommandAPDU(CLA_IDEMIX, 
                     INS_SIGNATURE, 0x01, 0x00, BigIntegerToUnsignedByteArray(e));
             ResponseAPDU response_e = transmit(signature_e);
             if (response_e.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not issue signature e.", 
                         response_e.getSW());
             }
 
             BigInteger vPrimePrime = 
                 msg.getIssuanceElement(IssuanceProtocolValues.vPrimePrime);
             CommandAPDU signature_vPrimePrime = new CommandAPDU(CLA_IDEMIX, 
                     INS_SIGNATURE, 0x02, 0x00, BigIntegerToUnsignedByteArray(vPrimePrime));
             ResponseAPDU response_vPrimePrime = transmit(signature_vPrimePrime);
             if (response_vPrimePrime.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not issue signature v''.", 
                         response_vPrimePrime.getSW());
             }
 
             CommandAPDU signature_verify = new CommandAPDU(CLA_IDEMIX, 
                     INS_SIGNATURE, 0x03, 0x00);
             ResponseAPDU response_verify = transmit(signature_verify);
             if (response_verify.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not verify issued signature.", 
                         response_verify.getSW());
             }
             
             // send Proof 
             BigInteger cPrime = msg.getProof().getChallenge();
             CommandAPDU proof_cPrime = new CommandAPDU(CLA_IDEMIX, 
                     INS_PROOF_A, 0x00, 0x00, BigIntegerToUnsignedByteArray(cPrime));
             ResponseAPDU response_cPrime = transmit(proof_cPrime);
             if (response_cPrime.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not issue proof c'.", 
                         response_cPrime.getSW());
             }
         
             BigInteger s_e = 
                 (BigInteger) msg.getProof().getSValue(IssuanceSpec.s_e).getValue();
             CommandAPDU proof_s_e = new CommandAPDU(CLA_IDEMIX, 
                    INS_PROOF_A, 0x01, 0x00, fixLength(s_e));
             ResponseAPDU response_s_e = transmit(proof_s_e);
             if (response_s_e.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not issue proof s_e.", 
                         response_s_e.getSW());
             }
 
             CommandAPDU proof_verify = new CommandAPDU(CLA_IDEMIX, 
                     INS_PROOF_A, 0x02, 0x00);
             ResponseAPDU response_proof = transmit(proof_verify);
             if (response_proof.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not verify proof.", 
                         response_verify.getSW());
             }
             
             // Do NOT return the generated Idemix credential
             return null;
             
         // Report caught exceptions
         } catch (CardServiceException e) {
             System.err.println(e.getMessage() + "\n");
             e.printStackTrace();
             return null;
         }
     }
 
     /**
      * Builds an Identity mixer show-proof data structure, which can be passed
      * to the verifier for verification.
      * 
      * @return Identity mixer show-proof data structure.
      */
     public Proof buildProof(final BigInteger nonce, final ProofSpec spec) {
         HashMap<String, SValue> sValues = new HashMap<String, SValue>();
         TreeMap<String, BigInteger> commonList = 
             new TreeMap<String, BigInteger>();
 
         List<String> disclosed = new Vector<String>();        
         Predicate predicate = spec.getPredicates().firstElement();
         if (predicate.getPredicateType() != PredicateType.CL) {
             throw new RuntimeException("Unimplemented predicate.");
         }
         CLPredicate pred = ((CLPredicate) predicate);
         StructureStore store = StructureStore.getInstance();
         CredentialStructure cred = (CredentialStructure) store.get(
                pred.getCredStructLocation());
 
         for (AttributeStructure attribute : cred.getAttributeStructs()) {
             String attName = attribute.getName();
             Identifier identifier = pred.getIdentifier(attName);
             if (identifier.isRevealed()) {
                 disclosed.add(attName);
             }
         }
 
         // Hide CardServiceExceptions, instead return null on failure
         try {
             // translate the List to a byte[] 
             Collections.sort(disclosed);
             byte[] D = new byte[disclosed.size()];
             for (int i = 0; i < disclosed.size(); i++) {
                 D[i] = (byte) Integer.parseInt(disclosed.get(i).replaceAll("[^0-9]", ""));
             }
             
             // Set the context for this proof
             setContext(spec.getContext());
 
             // send the attribute disclosure selection
             CommandAPDU disclosure_d = new CommandAPDU(CLA_IDEMIX, 
                     INS_ATTRIBUTE_DISCLOSURE, 0x00, 0x00, D);
             ResponseAPDU response_d = transmit(disclosure_d);
             if (response_d.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not set attribute " +
                         "disclosure selection.", response_d.getSW());
             }
 
             // send and receive the challenge
             CommandAPDU challenge_c = new CommandAPDU(CLA_IDEMIX, 
                     INS_CHALLENGE, 0x00, 0x00, BigIntegerToUnsignedByteArray(nonce));
             ResponseAPDU response_c = transmit(challenge_c);
             if (response_c.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not set the challenge " +
                 		"n1.", response_c.getSW());
             }
             BigInteger challenge = new BigInteger(1, response_c.getData());
 
             // receive the randomised signature
             CommandAPDU signature_capAPrime = new CommandAPDU(CLA_IDEMIX, 
                     INS_RANDOM_SIGNATURE, 0x00, 0x00);
             ResponseAPDU response_capAPrime = transmit(signature_capAPrime);
             if (response_capAPrime.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not get the random " +
                 		"signature A'.", response_capAPrime.getSW());
             }
             commonList.put(pred.getTempCredName(), 
                     new BigInteger(1, response_capAPrime.getData()));
 
             CommandAPDU signature_eHat = new CommandAPDU(CLA_IDEMIX, 
                     INS_RANDOM_SIGNATURE, 0x01, 0x00);
             ResponseAPDU response_eHat = transmit(signature_eHat);
             if (response_eHat.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not get the random " +
                 		"signature e^.", response_eHat.getSW());
             }
             BigInteger eHat = new BigInteger(1, response_eHat.getData());
 
             CommandAPDU signature_vHatPrime = new CommandAPDU(CLA_IDEMIX, 
                     INS_RANDOM_SIGNATURE, 0x02, 0x00);
             ResponseAPDU response_vHatPrime = transmit(signature_vHatPrime);
             if (response_vHatPrime.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not get the random " +
                 		"signature v^'.", response_vHatPrime.getSW());
             }
             BigInteger vHatPrime = new BigInteger(1, 
                     response_vHatPrime.getData());
 
             sValues.put(pred.getTempCredName(), 
                     new SValue(new SValuesProveCL(eHat, vHatPrime)));
 
             // receive the randomised master secret
             CommandAPDU command = new CommandAPDU(CLA_IDEMIX, 
                     INS_UNDISCLOSED_ATTRIBUTES, 0, 0);
             ResponseAPDU response = transmit(command);
             if (response.getSW() != 0x00009000) {
                 throw new CardServiceException("Could not get random " +
                         "value (@index 0).", response.getSW());
             }
             BigInteger s = new BigInteger(1, response.getData());
             sValues.put(IssuanceSpec.MASTER_SECRET_NAME, new SValue(s));
 
             // iterate over all the identifiers
             for (AttributeStructure attribute : cred.getAttributeStructs()) {
                 String attName = attribute.getName();
                 Identifier identifier = pred.getIdentifier(attName);
                 int i = Integer.parseInt(attName.replaceAll("[^0-9]", ""));
                 if (identifier.isRevealed()) {
                     command = new CommandAPDU(CLA_IDEMIX,
                     		INS_DISCLOSED_ATTRIBUTES, i, 0);
                     response = transmit(command);
                     if (response.getSW() != 0x00009000) {
                         throw new CardServiceException("Could not get disclosed " +
                                 "attribute (@index " + i + ").", response.getSW());
                     }
                     s = new BigInteger(1, response.getData());
                 } else {
                     command = new CommandAPDU(CLA_IDEMIX, 
                             INS_UNDISCLOSED_ATTRIBUTES, i, 0);
                     response = transmit(command);
                     if (response.getSW() != 0x00009000) {
                         throw new CardServiceException("Could not get random " +
                                 "value (@index " + i + ").", response.getSW());
                     }
                     s = new BigInteger(1, response.getData());
                 }
                 // note that identifier names must be unique
                 sValues.put(identifier.getName(), new SValue(s));
             }
 
             // Return the generated proof, based on the proof specification
             return new Proof(challenge, sValues, commonList);
         
         // Report caught exceptions
         } catch (CardServiceException e) {
             System.err.println(e.getMessage() + "\n");
             e.printStackTrace();
             return null;
         }
     }
 }
