 package minsolver;
 
 /* 
  * Kodkod -- Copyright (c) 2005-2007, Emina Torlak
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
  * in the Software without restriction, including without limitation the rights
  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the Software is
  * furnished to do so, subject to the following conditions:
  *
  * The above copyright notice and this permission notice shall be included in
  * all copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  * THE SOFTWARE.
  */
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 import javax.swing.JOptionPane;
 
 import org.sat4j.specs.ContradictionException;
 import org.sat4j.specs.IConstr;
 import org.sat4j.specs.TimeoutException;
 import kodkod.ast.Formula;
 import kodkod.ast.Relation;
 import kodkod.engine.config.Options;
 import minsolver.fol2sat.MinHigherOrderDeclException;
 import minsolver.fol2sat.MinTranslation;
 import minsolver.fol2sat.MinTranslationLog;
 import minsolver.fol2sat.MinTranslator;
 import minsolver.fol2sat.MinTrivialFormulaException;
 import minsolver.fol2sat.MinUnboundLeafException;
 import kodkod.engine.satlab.SATAbortedException;
 import kodkod.engine.satlab.SATProver;
 import kodkod.engine.satlab.SATSolver;
 import kodkod.instance.Bounds;
 import kodkod.instance.Instance;
 import kodkod.instance.Tuple;
 import kodkod.instance.TupleFactory;
 import kodkod.instance.TupleSet;
 import kodkod.util.ints.IntIterator;
 import kodkod.util.ints.IntSet;
 
 
 /** 
  * A computational engine for solving relational formulae.
  * A {@link kodkod.ast.Formula formula} is solved with respect to given 
  * {@link kodkod.instance.Bounds bounds} and {@link kodkod.engine.config.Options options}.
  * 
  * @specfield options: Options 
  * @author Emina Torlak 
  */
 public final class MinSolver {
 	private final Options options;
 	
 	//The iterator that acquires the SAT solver.
 	private MinSolutionIterator activeIterator;
 
 	/**
 	 * Constructs a new Solver with the default options.
 	 * @effects this.options' = new Options()
 	 */
 	public MinSolver() {
 		this.options = new Options();
 	}
 
 	/**
 	 * Constructs a new Solver with the given options.
 	 * @effects this.options' = options
 	 * @throws NullPointerException - options = null
 	 */
 	public MinSolver(Options options) {
 		if (options == null)
 			throw new NullPointerException();
 		this.options = options;
 	}
 
 	/**
 	 * Returns the Options object used by this Solver
 	 * to guide translation of formulas from first-order
 	 * logic to cnf.
 	 * @return this.options
 	 */
 	public Options options() {
 		return options;
 	}
 	
 	/**
 	 * Attempts to satisfy the given formula with respect to the specified bounds, while
 	 * minimizing the specified cost function.
 	 * If the operation is successful, the method returns a Solution that contains either a minimal-cost
 	 * instance of the formula or a proof of unsatisfiability.  The latter is generated iff 
 	 * the SAT solver generated by this.options.solver() is a {@link SATProver SATProver} in  addition
 	 * to being a {@link kodkod.engine.satlab.SATMinSolver SATMinSolver}.
 	 * 
 	 * @requires this.options.logTranslation==0 && this.options.solver.minimizer
 	 * @return Solution to the formula with respect to the given bounds and cost
 	 * @throws NullPointerException - formula = null || bounds = null || cost = null
 	 * @throws kodkod.engine.fol2sat.UnboundLeafException - the formula contains an undeclared variable or
 	 * a relation not mapped by the given bounds
 	 * @throws kodkod.engine.fol2sat.HigherOrderDeclException - the formula contains a higher order declaration that cannot
 	 * be skolemized, or it can be skolemized but this.options.skolemize is false.
 	 * @throws AbortedException - this solving task was interrupted with a call to Thread.interrupt on this thread
 	 * @throws IllegalArgumentException -  some  (formula.^children & Relation) - cost.relations
 	 * @throws IllegalStateException - !this.options.solver.minimizer || this.options.logTranslation
 	 * @see Solution
 	 * @see Options
 	 * @see Cost
 	 */
 /*	public MinSolution solve(Formula formula, Bounds bounds, Cost cost)
 			throws MinHigherOrderDeclException, MinUnboundLeafException, MinAbortedException {
 		if (options.logTranslation()>0 || !options.solver().minimizer())
 			throw new IllegalStateException();
 		
 		final long startTransl = System.currentTimeMillis();
 		try {
 			
 			final MinTranslation translation = MinTranslator.translate(formula, bounds, options);
 			final long endTransl = System.currentTimeMillis();
 
 			final SATMinSolver cnf = (SATMinSolver)translation.cnf();
 			for(Relation r : bounds.relations()) {
 				IntSet vars = translation.primaryVariables(r);
 				if (vars != null) {
 					int rcost = cost.edgeCost(r);
 					for(IntIterator iter = vars.iterator();  iter.hasNext(); ) {
 						cnf.setCost(iter.next(), rcost);
 					}
 				}
 			}
 			
 			options.reporter().solvingCNF(0, cnf.numberOfVariables(), cnf.numberOfClauses());
 			final long startSolve = System.currentTimeMillis();
 			final boolean isSat = cnf.solve();
 			final long endSolve = System.currentTimeMillis();
 
 			final MinStatistics stats = new MinStatistics(translation, endTransl - startTransl, endSolve - startSolve);
 			
 			return isSat ? sat(bounds, translation, stats) : unsat(translation, stats);
 		} catch (MinTrivialFormulaException trivial) {
 			final long endTransl = System.currentTimeMillis();
 			return trivial(bounds, trivial, endTransl - startTransl);
 		} catch (SATAbortedException sae) {
 			throw new MinAbortedException(sae);
 		}
 	}*/
 
 	/**
 	 * Attempts to satisfy the given formula with respect to the specified bounds or
 	 * prove the formula's unsatisfiability.
 	 * If the operation is successful, the method returns a Solution that contains either
 	 * an instance of the formula or an unsatisfiability proof.  Note that an unsatisfiability
 	 * proof will be constructed iff this.options specifies the use of a core extracting SATSolver.
 	 * Additionally, the CNF variables in the proof can be related back to the nodes in the given formula 
 	 * iff this.options has translation logging enabled.  Translation logging also requires that 
 	 * there are no subnodes in the given formula that are both syntactically shared and contain free variables.  
 	 * 
 	 * @return Solution to the formula with respect to the given bounds
 	 * @throws NullPointerException - formula = null || bounds = null
 	 * @throws kodkod.engine.fol2sat.UnboundLeafException - the formula contains an undeclared variable or
 	 * a relation not mapped by the given bounds
 	 * @throws kodkod.engine.fol2sat.HigherOrderDeclException - the formula contains a higher order declaration that cannot
 	 * be skolemized, or it can be skolemized but this.options.skolemize is false.
 	 * @throws AbortedException - this solving task was interrupted with a call to Thread.interrupt on this thread
 	 * @see Solution
 	 * @see Options
 	 * @see Proof
 	 */
 	public MinSolution solve(Formula formula, Bounds origBounds)
 			throws MinHigherOrderDeclException, MinUnboundLeafException, MinAbortedException {
 		final long startTransl = System.currentTimeMillis();
 		
 		try {		
 		
 			final MinTranslation translation = MinTranslator.translate(formula, origBounds, options);
 			final long endTransl = System.currentTimeMillis();
 
 			final SATSolver cnf = translation.cnf();
 			
 			options.reporter().solvingCNF(translation.numPrimaryVariables(), cnf.numberOfVariables(), cnf.numberOfClauses());
 			final long startSolve = System.currentTimeMillis();
 			final boolean isSat = cnf.solve();
 			final long endSolve = System.currentTimeMillis();
 
 			final MinStatistics stats = new MinStatistics(translation, endTransl - startTransl, endSolve - startSolve);
 			return isSat ? sat(origBounds, translation, stats) : unsat(translation, stats);
 			
 		} catch (MinTrivialFormulaException trivial) {
 			final long endTransl = System.currentTimeMillis();
 			return trivial(origBounds, trivial, endTransl - startTransl);
 		} catch (SATAbortedException sae) {
 			throw new MinAbortedException(sae);
 		}
 	}
 	
 	/**
 	 * Attempts to find all solutions to the given formula with respect to the specified bounds or
 	 * to prove the formula's unsatisfiability.
 	 * If the operation is successful, the method returns an iterator over n Solution objects. The outcome
 	 * of the first n-1 solutions is SAT or trivially SAT, and the outcome of the nth solution is UNSAT
 	 * or tirivally  UNSAT.  Note that an unsatisfiability
 	 * proof will be constructed for the last solution iff this.options specifies the use of a core extracting SATSolver.
 	 * Additionally, the CNF variables in the proof can be related back to the nodes in the given formula 
 	 * iff this.options has variable tracking enabled.  Translation logging also requires that 
 	 * there are no subnodes in the given formula that are both syntactically shared and contain free variables.  
 	 * 
 	 * @return an iterator over all the Solutions to the formula with respect to the given bounds
 	 * @throws NullPointerException - formula = null || bounds = null
 	 * @throws kodkod.engine.fol2sat.UnboundLeafException - the formula contains an undeclared variable or
 	 * a relation not mapped by the given bounds
 	 * @throws kodkod.engine.fol2sat.HigherOrderDeclException - the formula contains a higher order declaration that cannot
 	 * be skolemized, or it can be skolemized but this.options.skolemize is false.
 	 * @throws AbortedException - this solving task was interrupted with a call to Thread.interrupt on this thread
 	 * @throws IllegalStateException - !this.options.solver().incremental()
 	 * @see Solution
 	 * @see Options
 	 * @see Proof
 	 */
 	public Iterator<MinSolution> solveAll(final Formula formula, final Bounds origBounds) 
 		throws MinHigherOrderDeclException, MinUnboundLeafException, MinAbortedException {
 		if (!options.solver().incremental())
 			throw new IllegalArgumentException("cannot enumerate solutions without an incremental solver.");
 						
 		MinSolutionIterator iterator = new MinSolutionIterator(this, formula, origBounds, options);
 		
 		return iterator;
 	}
 	
 	/**
 	 * Augments a model from an iterator with a set of facts aka lifters.
 	 * @param formula the original FOL formula.
 	 * @param origBounds the bounds.
 	 * @param iterator the previous iterator.
 	 * @param solution the current solution of the previous iterator being lifted.
 	 * @param lifters the facts to augment.
 	 * @return a new iterator over the augmented models.
 	 * @throws MinHigherOrderDeclException
 	 * @throws UnboundLeafException
 	 * @throws MinAbortedException
 	 */
 	//TODO in a refined implementation, we don't need the formula and bound since we have the translation 
 	//via previous iterator.
 	public Iterator<MinSolution> lift(final Formula formula, Iterator<MinSolution> prevIterator, 
 			Instance lifters)
 			throws MinHigherOrderDeclException, MinUnboundLeafException, MinAbortedException, ExplorationException {
 		
 		if (!options.solver().incremental())
 			throw new IllegalArgumentException("cannot enumerate solutions without an incremental solver.");
 		
 		MinSolutionIterator msiterator = (MinSolutionIterator)prevIterator;
 		
 		if(msiterator.trivial)
 		{
 			// Disable augmentation and redirect them to the set of consist. facts (for now):
 			JOptionPane.showMessageDialog(null, "The spec given was trivially satisfiable, and so it had only one minimal model (shown),\n"+
 			"to which any relational fact in the set of consistent facts may be added without consequence.\n\n"+
 					"Explicit exploration is unavailable.");
 			return prevIterator;
 		}
 		
 		//Lifting is always performed on skolemBounds.
 		Bounds skBounds = ((MyReporter)options.reporter()).skolemBounds;
 		
 		ArrayList<Integer> allLifters = new ArrayList<Integer>();
 		Map<Relation, TupleSet> solutionTuples = msiterator.getLastSolution().instance().relationTuples();
 		Map<Relation, TupleSet> lifterTuples = lifters.relationTuples();
 
 		//This can be a method!
 		for(Relation r : solutionTuples.keySet()){
 			TupleSet tuples = solutionTuples.get(r);
 			for(Tuple t: tuples){
 				int index = MinTwoWayTranslator.getPropVariableForTuple(skBounds, msiterator.getTranslation(), r, t);
 				//if there is no primary variables assigned to this relation, continue.
 				if(index == -1)
 					continue;
 				allLifters.add(index);
 			}
 		}
 		
 		for(Relation r : lifterTuples.keySet()){
 			TupleSet tuples = lifterTuples.get(r);
 			if(tuples != null)
 				for(Tuple t: tuples){
 					if(solutionTuples.get(r).contains(t))
 						throw new ExplorationException("The fact " + t + " is already true in the solution.");
 
 					int index = MinTwoWayTranslator.getPropVariableForTuple(skBounds, msiterator.getTranslation(), r, t);					
 					//if there is no primary variables assigned to this relation, continue.
 					if(index == -1)
 						continue;
 					
 					allLifters.add(index);
 				}
 		}
 		
 		MinSolutionIterator iterator = new MinSolutionIterator(this, formula, skBounds, options, allLifters, msiterator);
 		
 		return iterator;
 	}	
 	
 	/**
 	 * Returns the lifters for the current model loaded in the given iterator.
 	 * @param iterator the iterator.
 	 * @return the lifters tuple relations of an instance.
 	 * @throws TimeoutException
 	 * @throws ContradictionException
 	 */
 	public Instance getLifters(Iterator<MinSolution> iterator) throws TimeoutException, ContradictionException{
 		MinSolutionIterator theIterator = (MinSolutionIterator)iterator;
 				
 		if(theIterator.trivial)
 		{
 			// No translation available to lift. Get the upper bounds - the lower bounds:
 			Bounds skBounds = ((MyReporter)options.reporter()).skolemBounds;			
 			Instance results = new Instance(skBounds.universe());			
 			for(Relation r : skBounds.relations())
 			{				
 				TupleSet tuples = skBounds.upperBound(r).clone();			
 				tuples.removeAll(skBounds.lowerBound(r));							
 				results.add(r, tuples);							
 			}
 			
 			//JOptionPane.showMessageDialog(null, "getLifters: "+results);			
 			return results;
 		}
 
 		// If not trivial, go through the propositional translation
 		return MinTwoWayTranslator.translatePropositions(
 				theIterator.translation, ((MyReporter)theIterator.options.reporter()).skolemBounds,
 				theIterator.mapVarToRelation,
 				theIterator.getLifters());
 		
 	}
 	
 	/**
 	 * Returns a list of lifters for the current model loaded in the given iterator as 
 	 * a line separated string.
 	 * @param iterator the iterator.
 	 * @return returns a list of line separated strings of lifters. If an exception occurs,
 	 * it returns an empty string.
 	 */    
 	public String getLiftersList(Iterator<MinSolution> iterator){
 		return getLiftersList(iterator, null);
 	}	
 	
 	/**
 	 * Returns a list of lifters for the current model loaded in the given iterator as 
 	 * a line separated string.
 	 * @param iterator the iterator.
 	 * @param dictionary a renaming will be applied on the atoms according to the dictionary.
 	 * @return returns a list of line separated strings of lifters. If an exception occurs,
 	 * it returns an empty string.
 	 */    
 	public String getLiftersList(Iterator<MinSolution> iterator, Map<String, String> dictionary){
 		String retVal = "";
 		MinSolutionIterator miniterator = ((MinSolutionIterator)iterator);
 		MinTranslation translation = miniterator.translation;
 		
 		Bounds bounds = ((MyReporter)options.reporter()).skolemBounds;
 		
 		//Keeps the pattern of the output when a NEW-INSTANCE is involved. The outputs that have
 		//repetitive patterns will be discarded.
 		Set<String> uniqeOutputPattern = new LinkedHashSet<String>();
 		
 		Instance lifters = null;
 		
 		try{
 			lifters = getLifters(iterator);
 		}
 		catch(Exception e){
 			return "";
 		}
 		
 		Map<Relation, TupleSet> lifterTuples = lifters.relationTuples();
 		
 		//This can be a method!
 		for(Relation r : lifterTuples.keySet()){
 			TupleSet tuples = lifterTuples.get(r);
 			for(Tuple t: tuples){
 				if(!miniterator.trivial)
 				{
 					int index = MinTwoWayTranslator.getPropVariableForTuple(bounds, translation, r, t);
 					//if there is no primary variables assigned to this relation, continue.
 					if(index == -1)
 						continue;
 				}
 
 				if(dictionary != null){
 			        final StringBuilder ret = new StringBuilder("["); //This section of the code produces t.toString manually:
 			        StringBuilder pattern = new StringBuilder("["); //keeps the pattern of the next output.
 			        
 			        String label = dictionary.get(t.atom(0));
 			        if(label != null){
 			        	ret.append(label);
 				        pattern.append(label);
 			        }
 			        else{
 			        	ret.append("NEW-INSTANCE(" + t.atom(0) + ")");
 			        	pattern.append("NEW-INSTANCE"); //For new instances, do not keep the name of the atom
 			        }
 			        for (int i = 1; i < t.arity(); i++) {
 			            ret.append(", ");
 			            pattern.append(",");
 			            label = dictionary.get(t.atom(i));
 			            if(label != null){
 			            	ret.append(label);
 			            	pattern.append(label);
 			            }
 			            else{
 			            	ret.append("NEW-INSTANCE(" + t.atom(i) + ")");
 			            	pattern.append("NEW=INSTANCE");
 			            }
 			        }
 			        ret.append("]");
 			        pattern.append("]");
 			        if(uniqeOutputPattern.add(r.toString()+ pattern.toString())) //if the pattern is not repetitive
 			        	retVal += r.toString() + ret.toString() + "\n";
 				} else{
 					retVal += r.toString() + t.toString() + "\n";
 				}
 			}
 		}
 		
 		return retVal;
 	}
 
 	/**
 	 * Builds a consistent fact that can be used for lifting a model.
 	 * @param inputStr the input string
 	 * @param iterator the iterator to be lifted by this fact.
 	 * @return an object of type Instance containing the lifting fact.
 	 */	
 	public Instance parseString(String inputStr, Iterator<MinSolution> iterator){
 		return parseString(inputStr, iterator, null);
 	}	
 	
 	/**
 	 * Builds a consistent fact that can be used for lifting a model.
 	 * @param inputStr the input string
 	 * @param iterator the iterator to be lifted by this fact.
 	 * @param dictionary is used to translate the atoms to their names in Kodkod.
 	 * @return an object of type Instance containing the lifting fact.
 	 */
 	public Instance parseString(String inputStr, Iterator<MinSolution> iterator, Map<String, String> dictionary){
 		inputStr = inputStr.trim();
 		inputStr = inputStr.replaceAll(" ", "");
 		
 		String relationName = null;
 		int index1 = inputStr.indexOf('[');
 		if(index1 == -1)
 			return null;
 		
 		relationName = inputStr.substring(0, index1);
 
 		int index2 = inputStr.indexOf(']');
 		if(index2 == -1)
 			return null;
 		
 		StringTokenizer tokenizer = new StringTokenizer(inputStr.substring(index1 + 1, index2), ",");
 		
 		ArrayList<String> constants = new ArrayList<String>();
 		
 		while(tokenizer.hasMoreTokens()){
 			constants.add(tokenizer.nextToken());
 		}
 
 		Bounds bounds = ((MyReporter)options.reporter()).skolemBounds;
 		
 		Set<Relation> relations = bounds.relations();
 		Relation relation = null;
 		for(Relation r: relations){
 			if(r.name().equals(relationName)){
 				relation = r;
 				break;
 			}
 		}
 		
 		if(relation == null) //Relation does not exist.
 			return null;
 		
 		TupleSet tuples = bounds.upperBound(relation);
 		if(tuples == null)
 			return null;
 
 		Tuple tuple = null;
 		for(Tuple t: tuples){
 			boolean found = true;
 			for(int i = 0; i < t.arity(); i++){
 				if(dictionary != null){
 					String label = dictionary.get(constants.get(i));
 					if(label != null){ //if the name is in the dictionary
 						if(!t.atom(i).toString().equals(label)){
 							found = false;
 							break;
 						}
 					}else{
 						if(!("NEW-INSTANCE(" + t.atom(i) + ")").toString().equals(constants.get(i))){
 								//|| !t.atom(i).toString().equals(constants.get(i))){
 							found = false;
 							break;
 						}
 					}
 				}
 				else {
 					if(!t.atom(i).toString().equals(constants.get(i))){
 						found = false;
 						break;
 					}
 				}
 			}
 			if(found == true){
 				tuple = t;
 				break;
 			}
 		}
 		
 		if(tuple == null) //There is no such tuple
 			return null;
 
 		Instance retVal = new Instance(bounds.universe());
 		retVal.add(relation, bounds.universe().factory().setOf(tuple));
 		
 		return retVal;
 	}
 	
 	/**
 	 * Returns the bounds after skolemization.
 	 */
 	public Bounds getSkolemBounds(){
 		return ((MyReporter)options.reporter()).skolemBounds;
 	}
 	
 	/**
 	 * {@inheritDoc}
 	 * @see java.lang.Object#toString()
 	 */
 	public String toString() {
 		return options.toString();
 	}
 	
 	/**
 	 * Returns the result of solving a sat formula.
 	 * @param bounds Bounds with which  solve() was called
 	 * @param translation the translation
 	 * @param stats translation / solving stats
 	 * @return the result of solving a sat formula.
 	 */
 	private static MinSolution sat(Bounds bounds, MinTranslation translation, MinStatistics stats) {
 		final MinSolution sol = MinSolution.satisfiable(stats, padInstance(translation.interpret(), bounds), 0, null);
 		translation.cnf().free();
 		return sol;
 	}
 
 	/**
 	 * Returns the result of solving an unsat formula.
 	 * @param translation the translation 
 	 * @param stats translation / solving stats
 	 * @return the result of solving an unsat formula.
 	 */
 	private static MinSolution unsat(MinTranslation translation, MinStatistics stats) {
 		final SATSolver cnf = translation.cnf();
 		final MinTranslationLog log = translation.log();
 		if (cnf instanceof SATProver && log != null) {
 			return MinSolution.unsatisfiable(stats, new MinResolutionBasedProof((SATProver) cnf, log), 0, null);
 		} else { // can free memory
 			final MinSolution sol = MinSolution.unsatisfiable(stats, null, 0, null);
 			cnf.free();
 			return sol;
 		}
 	}
 	
 	/**
 	 * @return the number of primary variables needed to encode the unknown tuples in the given bounds.
 	 */
 	private static int trivialPrimaries(Bounds bounds) { 
 		int prim = 0;
 		for(Relation r : bounds.relations()) { 
 			prim += bounds.upperBound(r).size() - bounds.lowerBound(r).size();
 		}
 		return prim;
 	}
 	
 	/**
 	 * Returns the result of solving a trivially (un)sat formula.
 	 * @param bounds Bounds with which solve()  was called
 	 * @param desc TrivialFormulaException thrown as the result of the formula simplifying to a constant
 	 * @param translTime translation time
 	 * @return the result of solving a trivially (un)sat formula.
 	 */
 	private static MinSolution trivial(Bounds bounds, MinTrivialFormulaException desc, long translTime) {
 		final MinStatistics stats = new MinStatistics(trivialPrimaries(desc.bounds()), 0, 0, translTime, 0);
 		if (desc.value().booleanValue()) {
 			return MinSolution.triviallySatisfiable(stats, padInstance(toInstance(desc.bounds()), bounds), 0, null);
 		} else {
 			return MinSolution.triviallyUnsatisfiable(stats, trivialProof(desc.log()), 0, null);
 		}
 	}
 	
 	/**
 	 * Returns a proof for the trivially unsatisfiable log.formula,
 	 * provided that log is non-null.  Otherwise returns null.
 	 * @requires log != null => log.formula is trivially unsatisfiable
 	 * @return a proof for the trivially unsatisfiable log.formula,
 	 * provided that log is non-null.  Otherwise returns null.
 	 */
 	private static MinProof trivialProof(MinTranslationLog log) {
 		return log==null ? null : new MinTrivialProof(log);
 	}
 	
 	/**
 	 * "Pads" the argument instance with the mappings that occur in bounds.lowerBound
 	 * but not in the instance. 
 	 * @requires instance.relations in bounds.relations
 	 * @effects instance.relations' = bounds.relations' &&
 	 *          instance.tuples' = bounds.lowerBound ++ instance.tuples
 	 * @return instance
 	 */
 	private static Instance padInstance(Instance instance, Bounds bounds) {
 		for (Relation r : bounds.relations()) {
 			if (!instance.contains(r)) {
 				instance.add(r, bounds.lowerBound(r));
 			}
 		}
 		for (IntIterator iter = bounds.ints().iterator(); iter.hasNext();) {
 			int i = iter.next();
 			instance.add(i, bounds.exactBound(i));
 		}
 		return instance;
 	}
 
 	/**
 	 * Creates an instance from the given Bounds.  The instance
 	 * is simply the mapping bounds.lowerBound.
 	 * @return the instance corresponding to bounds.lowerBound
 	 */
 	private static Instance toInstance(Bounds bounds) {
 		final Instance instance = new Instance(bounds.universe());
 		for (Relation r : bounds.relations()) {
 			instance.add(r, bounds.lowerBound(r));
 		}
 		for (IntIterator iter = bounds.ints().iterator(); iter.hasNext();) {
 			int i = iter.next();
 			instance.add(i, bounds.exactBound(i));
 		}
 		return instance;
 	}
 	
 	/**
 	 * An iterator over all solutions of a model.
 	 * @author Emina Torlak
 	 */
 	static final class MinSolutionIterator implements Iterator<MinSolution> {
 		private final Options options;
 		private Formula formula;
 		
 		/**
 		 * The original, pre-Skolem bounds passed to Kodkod.
 		 * Access the post-Skolem bounds via MyReporter.
 		 */
 		private Bounds origBounds;
 		
 		private boolean trivial = false;
 		
 		private MinTranslation translation;
 		private Map<Integer, Relation> mapVarToRelation;
 		private long translTime;
 		private MinSolution lastSolution;
 		//private long internalMinimalCandidatesFoundCounter = 0;
 		
 		//the MinSolver instance that creates the iterator.
 		private final MinSolver minSolver;
 		
 		//Modifications for minimal models
 		private Boolean sat = null;
 		private MinSolution unsatSolution = null;
 		
 		/**
 		 * Keeps cone restriction clauses such that the next model from the SATsolver
 		 * is not in any of the previous cones.
 		 */
 		private Set<List<Integer>> coneRestrictionClauses = new HashSet<List<Integer>>();
 		/**
 		 * Keeps a list of all the constraints that are being taken into account.
 		 * Some operations such as getLifters() has to eliminate all the constraints.
 		 * Also, when another iterator is using the solver, the constraints from
 		 * the current iterator should be removed.
 		 */
 		private Set<IConstr> coneRestrictionConstraints = new HashSet<IConstr>();
 
 		/**
 		 * Keeps a list of all the unit constraints due to a bug in SAT4J that does not
 		 * return a handle to remove unit constraints.
 		 */
 		private Set<Integer> coneRestrictionUnits = new HashSet<Integer>();
 		
 		/**
 		 * The lifters for this iteration.
 		 */
 		private final int[] lifters;
 		
 		/**
 		 * Constructs a solution iterator for the given formula, bounds, and options.
 		 */
 		MinSolutionIterator(MinSolver minSolver, Formula formula, Bounds origBounds, Options options) {			
 			this(minSolver, formula, origBounds, options, null, null);			
 		}
 
 		/**
 		 * Constructs a solution iterator for the given formula, bounds, options and lifters.
 		 * @param formula
 		 * @param origBounds
 		 * @param options
 		 * @param lifters
 		 * @param prevIterator
 		 */
 		
 		MinSolutionIterator(MinSolver minSolver, Formula formula, Bounds origBounds, Options options, ArrayList<Integer> lifters, MinSolutionIterator prevIterator) {
 			this.minSolver = minSolver;
 			this.formula = formula;
 			this.origBounds = origBounds;
 			this.options = options;
 			this.translation = null;
 			this.lifters = (lifters == null) ? null : toIntCollection(lifters);
 			
 			if(prevIterator != null){  //if lifting on a previous iterator
 				this.translation = prevIterator.getTranslation();
 				this.mapVarToRelation = prevIterator.mapVarToRelation;		
 			}
 		}
 		
 		/**
 		 * Returns true if there is another solution.
 		 * @see java.util.Iterator#hasNext()
 		 */
 		public boolean hasNext() {
 			// This works because nonTrivialSolution() sets formula = null when
 			// the solver returns unsat.
 			return (formula != null);
 		}
 		
 		/**
 		 * Solves translation.cnf and adds the negation of the
 		 * found model to the set of clauses.
 		 * @requires this.translation != null
 		 * @effects this.translation.cnf is modified to eliminate
 		 * the  current solution from the set of possible solutions
 		 * @return current solution
 		 */
 		private MinSolution nonTrivialSolution() {						
 			try {
 				final MinSATSolver internalSolver = translation.cnf();
 				
 				try{
 					// If all the previous constraints have been removed by another operation,
 					// add them again.
 					if(coneRestrictionConstraints.isEmpty()){
 						addAllClauses();
 					}
 				}
 				catch(ContradictionException e){
 					JOptionPane.showMessageDialog(null, "CONTRADICTION exception in nonTrivialSolution()");
 				}
 				
 				options.reporter().solvingCNF(translation.numPrimaryVariables(), internalSolver.numberOfVariables(), internalSolver.numberOfClauses());				
 				final long startSolve = System.currentTimeMillis();				
 				boolean isSat = false;
 				boolean gotNonMinimal;
 				do
 				{
 					gotNonMinimal = false;					
 					//try
 					//{
 						isSat = solve();
 					//} catch(NotMinimalModelException e)
 					//{
 					//	isSat = true; // Must have gotten SOME model; need to cone restrict.
 					//	gotNonMinimal = true;
 					//}
 					
 					//JOptionPane.showMessageDialog(null, "Solve() got:"+isSat+";"+gotNonMinimal);
 					
 					// If a model found, add constraints to forbid its cone.
 					if(isSat)
 					{												
 						final int primary = translation.numPrimaryVariables();					
 						final ArrayList<Integer> notModel = new ArrayList<Integer>();		
 						
 						// Negate this model's positive diagram. 
 						// We will use this disjunctively for "cone-restriction": preventing models 
 						// (or any of their supermodels) from occuring again.
 						for(int i = 1; i <= primary; i++){
 							if(internalSolver.valueOf(i)){
 								notModel.add(-i);
 							}
 						}
 																		
 						//JOptionPane.showMessageDialog(null, "Syms: "+translation.symmetries+
 						//		"\nPerms: "+translation.permutations+
 						//		"\nnotModel="+notModel);
 						
 						try{	
 							//JOptionPane.showMessageDialog(null, translation.permutations);
 							// Add the cone restriction for this model:
 							addConeRestriction(notModel, internalSolver);
 							// Add the cone restriction for all (safe) adjacent transpositions: 
							addPermConeRestrictions(notModel, internalSolver);
 						}
 						catch(ContradictionException e) {
 							// This iterator is now out of models. Either we just gave the empty model,
 							// or a cone restriction clause has resulted in a contradiction. So make sure
 							// that this iterator never yields a model again:
 							JOptionPane.showMessageDialog(null, "Contradiction; out of models. Augmentation will be disabled.");
 							final long endSolveU = System.currentTimeMillis();				
 							final MinStatistics statsU = new MinStatistics(translation, translTime, endSolveU - startSolve);
 							unsatSolution = unsat(translation, statsU);
 							
 							// Cannot free bounds yet, because we have one more model to process below.
 							//formula = null; bounds = null;
 						}
 					} // end constraints to forbid current cone									
 					
 				} while(gotNonMinimal && isSat);
 				
 				
 				/////////////////////////////////////////////
 				// Found a minimal model (or unsat)
 				
 				final long endSolve = System.currentTimeMillis();				
 				final MinStatistics stats = new MinStatistics(translation, translTime, endSolve - startSolve);
 				if (isSat) {
 					int[] propositionalModel = translation.cnf().getLastModel().clone();
 					// extract the current solution; can't use the sat(..) method because it frees the sat solver
 					final MinSolution sol = MinSolution.satisfiable(stats, padInstance(translation.interpret(), origBounds), 
 							((MyReporter)options.reporter()).getIterations(), propositionalModel);
 					if(unsatSolution != null)
 					{
 						formula = null; origBounds = null;
 					}
 					return sol;
 				} else {
 					unsatSolution = unsat(translation, stats); 
 					formula = null; origBounds = null; // unsat, no more solutions, free up some space
 					return unsatSolution;
 				}
 			} catch (SATAbortedException sae) {
 				throw new MinAbortedException(sae);
 			}
 		}
 		
 		/**
 		 * Add a clause for this negated positive-diagram.
 		 * 
 		 * @param notModel
 		 * @param internalSolver
 		 * @throws ContradictionException
 		 */
 		private void addConeRestriction(List<Integer> notModel, MinSATSolver internalSolver)
 				throws ContradictionException
 		{						
 			if(notModel.size() == 1)
 			{
 				// No risk of adding duplicates; it's just a set.
 				coneRestrictionUnits.add(notModel.get(0));
 			}
 			else
 			{				
 				// Avoid adding duplicate clauses to the *SAT SOLVER*. Adding duplicate 
 				// clauses ought to be idempotent, but it is not: the same IConstr
 				// is returned, and removeConstraint will only end up removing the 
 				// *FIRST* such clause, not all of them. So never add duplicates!
 				if(coneRestrictionClauses.contains(notModel))
 					return;								
 				
 				// (This will be called if notModel.size() ==0, triggering the exception.)							
 				coneRestrictionConstraints.add(internalSolver.addConstraint(toIntCollection(notModel)));
 				coneRestrictionClauses.add(notModel);
 								
 			}			
 		}
 		
 		/**
 		 * Add cone-restriction clauses for the broken symmetries (i.e., the symmetries for which
 		 * Kodkod produces a symmetry-breaking predicate) of this negated positive-diagram.
 		 * 
 		 * @param notModel
 		 * @param internalSolver
 		 * @throws ContradictionException
 		 */
 		@SuppressWarnings("unused")
 		private void addPermConeRestrictions(ArrayList<Integer> notModel, MinSATSolver internalSolver) 
 				throws ContradictionException
 		{			
 			// the CALLER is responsible for adding the original restriction clause:
 			//addConeRestriction(notModel, internalSolver);
 			
 			int permCounter = 0;
 			for(Map<Integer, Integer> aPerm : translation.permutations)
 			{
 				// For safety. Note that this is a *completely different use*
 				// of the symmetry-breaking option. Here it means the number of
 				// permuted cone-restriction clauses. In the SBP, it limits
 				// the *length* of each sub-formula.
 				if(permCounter >= options.symmetryBreaking())
 					break;				
 				
 				// Apply this permutation and add the permuted C.R. clause. The permutation
 				// is assumed to be complete. I.e., if 2->3, then 3->x for some x. In our
 				// case, the permutations are actually length 2 (2->3 then 3->2). 
 				List<Integer> permNotModel = permuteNegatedPositiveDiagram(notModel, aPerm);				
 				addConeRestriction(permNotModel, internalSolver);								
 				permCounter++;
 
 				//JOptionPane.showMessageDialog(null, permCounter+" Added restriction. notModel="+notModel+"\naPerm="+aPerm+"\npermNotModel="+permNotModel);				
 			}			
 		}
 
 		/**
 		 * Given a negated positive diagram, apply a permutation to it.
 		 * 
 		 * @param notModel
 		 * @param aPerm
 		 * @return
 		 */
 		private List<Integer> permuteNegatedPositiveDiagram(ArrayList<Integer> notModel,
 				Map<Integer, Integer> aPerm) 
 		{
 			List<Integer> result = new ArrayList<Integer>(notModel.size());
 			for(Integer aLiteral : notModel)
 			{
 				if(aLiteral > 0 && aPerm.containsKey(aLiteral))
 					result.add(aPerm.get(aLiteral));
 				else if(aLiteral < 0 && aPerm.containsKey(aLiteral*-1))
 					result.add(aPerm.get(aLiteral*-1)*-1);
 				else
 					result.add(aLiteral);					
 			}
 			
 			return result;
 		}
 
 		/**
 		 * Packages the information from the given trivial formula exception
 		 * into a solution and returns it.  If the formula is satisfiable, 
 		 * this.formula and this.bounds are modified to eliminate the current
 		 * trivial solution from the set of possible solutions.
 		 * @requires this.translation = null
 		 * @effects this.formula and this.bounds are modified to eliminate the current
 		 * trivial solution from the set of possible solutions.
 		 * @return current solution
 		 */
 		private MinSolution trivialSolution(MinTrivialFormulaException tfe) {
 			final MinStatistics stats = new MinStatistics(0, 0, 0, translTime, 0);
 			
 			// Heavily modified from original. When presenting only minimal models,
 			// only the first trivial solution needs to be presented: the lower-bounds
 			// give a unique (up to isomorphism) minimal model. So return it, but do
 			// not prepare other solutions.
 			
 			trivial = true;
 			
 			if (tfe.value().booleanValue()) {				
 				final Bounds translBounds = tfe.bounds();
 				final Instance trivialInstance = padInstance(toInstance(translBounds), origBounds);
 				final MinSolution sol = MinSolution.triviallySatisfiable(stats, trivialInstance, 0, null);
 				
 				// Disallow future solving via this iterator.
 				formula = null; origBounds = null;
 				unsatSolution = MinSolution.triviallyUnsatisfiable(stats, null, 0, null);
 				return sol;
 			} else {
 				formula = null; origBounds = null;
 				unsatSolution = MinSolution.triviallyUnsatisfiable(stats, trivialProof(tfe.log()), 0, null);
 				return unsatSolution;
 			}
 		}
 		/**
 		 * Returns the next solution if any.
 		 * @see java.util.Iterator#next()
 		 */
 		public MinSolution next() {
 			if (!hasNext()) return unsatSolution;
 			
 			claimSATSolver();
 
 			if (translation==null) {
 				try {
 					translTime = System.currentTimeMillis();
 					translation = MinTranslator.translate(formula, origBounds, options);
 					translTime = System.currentTimeMillis() - translTime;
 					//We use this data structure for translation:
 					//mapVarToRelation = MinTwoWayTranslator.buildVarToRelationMap(translation, bounds);
 					mapVarToRelation = MinTwoWayTranslator.buildVarToRelationMap(translation, 
 							((MyReporter)options.reporter()).skolemBounds);
 					
 					// Print the translation (DEBUG ONLY!)
 					//String transStr = MinTwoWayTranslator.printTranslation(translation, 
 					//		((MyReporter)options.reporter()).skolemBounds,
 					//		mapVarToRelation);
 					//JOptionPane.showMessageDialog(null, transStr);
 					
 					lastSolution = nonTrivialSolution();
 				} catch (MinTrivialFormulaException tfe) {
 					translTime = System.currentTimeMillis() - translTime;
 					lastSolution = trivialSolution(tfe);
 				} 
 			} else {
 				lastSolution = nonTrivialSolution();
 			}						
 			
 			return lastSolution;
 		}
 
 		/**
 		 * Prepares the solver to be used by the current iterator.
 		 */
 		private void claimSATSolver() {
 			if(minSolver.activeIterator != null && minSolver.activeIterator != this){
 				//Remove all the constraints of the previous active iterator.
 				minSolver.activeIterator.removeAllConstraints();
 				//Add the constraints of the current iterator.
 				try{
 					if(coneRestrictionConstraints.isEmpty())
 						addAllClauses();
 				}
 				catch(ContradictionException e){
 					JOptionPane.showMessageDialog(null, "CONTRADICTION exception in claimSATSolver()");
 				}
 			}
 			//Set the activeIterator
 			minSolver.activeIterator = this;
 			
 			//Deactivate SBP if the iterator is augmented by some fact.
 			if(translation != null){
 				if(isAugmented()) //if the iterator is an augmentation
 					((MinSATSolver)translation.cnf()).deactivateSBP();
 				else
 					((MinSATSolver)translation.cnf()).activateSBP();
 			}
 		}		
 		
 		/**
 		 * @see java.util.Iterator#remove()
 		 */
 		public void remove() {
 			throw new UnsupportedOperationException();
 		}
 		
 		/**
 		 * Prepares a minimal model.
 		 * @return true if there is a next solution; otherwise, false.
 		 * @throws NotMinimalModelException 
 		 */
 		private boolean solve() {
 			// In case this iterator should never return a model again:
 			if(!hasNext()) return false;
 			
 			try{
 				Set<Integer> allUnits = new HashSet<Integer>();
 				allUnits.addAll(toSet(lifters));
 				allUnits.addAll(coneRestrictionUnits);
 				
 				if(allUnits.size() == 0)
 					sat = Boolean.valueOf(translation.cnf().solve());
 				else
 					sat = Boolean.valueOf(translation.cnf().solve(toIntCollection(allUnits)));
 		
 				//JOptionPane.showMessageDialog(null, sat+" "+allUnits.size());
 				
 				if(sat)
 				{	
 					try{
 						minimize();
 					}
 					catch(ContradictionException e)
 					{
 						JOptionPane.showMessageDialog(null, "CONTRADICTION exception in minimize() call");
 					}
 				}								
 				
 				return sat;
 			} catch (org.sat4j.specs.TimeoutException e) {
 				throw new RuntimeException("timed out");
 			}
 		}
 
 		/**
 		 * Minimizes the model in the SAT solver.
 		 * @throws TimeoutException
 		 * @throws ContradictionException
 		 * @throws NotMinimalModelException 
 		 */
 		private void minimize() throws TimeoutException, ContradictionException
 		{
 			
 			// Assumption: Have already found a model at this point!							
 			
 			// This keeps constraints to be removed from the solver
 			// after finding the next model.
 			Set<IConstr> constraints = new HashSet<IConstr>();
 			
 			// All the unit clauses being passed to the solver as assumptions.
 			Set<Integer> unitClauses = toSet(lifters);						
 			
 			// Add all coneRestrictionUnits
 			for(Integer value: coneRestrictionUnits)
 				unitClauses.add(value);
 			
 			MinSATSolver theSolver = ((MinSATSolver)translation.cnf());						
 			
 			theSolver.deactivateSBP();
 			
 			int iterationCounter = 1;						
 			
 			do
 			{
 				// Given that candidate for minimal-model, try to make something smaller.
 				// add: disjunction of negations of all positive literals in M (constraint)
 				// add: all negative literals as unit clauses
 				
 				// An array of the next constraint being added.
 				List<Integer> loseSomethingPositive = new ArrayList<Integer>();
 				
 				int numPrimaryVariables = translation.numPrimaryVariables();
 					
 				for(int i = 1; i <= numPrimaryVariables; i++){
 					if(theSolver.valueOf(i) == true)
 						loseSomethingPositive.add(-i);
 					else // don't set anything curr. negative to positive.
 						unitClauses.add(-i);
 				}
 				
 				if(loseSomethingPositive.size() == 0)
 				{
 					// We have minimized down to the empty model. 
 					// Avoid calling the final SAT (would be adding the empty clause)
 					break;
 				}
 				if(loseSomethingPositive.size() == 1)
 				{
 					// We have only one relational fact that can possibly be removed.
 					unitClauses.add(loseSomethingPositive.get(0));
 				}
 				else
 				{
 					constraints.add(theSolver.addConstraint(toIntCollection(loseSomethingPositive)));
 				}
 				
 				iterationCounter++;
 			}
 			while(Boolean.valueOf(theSolver.solve(toIntCollection(unitClauses))));
 							
 			((MyReporter)options.reporter()).setIterations(iterationCounter);
 						
 			if(!isAugmented()) //if the iterator is NOT an augmentation, activate SBP.
 				theSolver.activateSBP();
 			
 //			JOptionPane.showMessageDialog(null, Arrays.toString(Arrays.copyOf(theSolver.getLastModel(), translation.numPrimaryVariables())));
 					
 			// Remove all the (non-unit) loseSomethingPositive constraints we just added from the solver:
 			Iterator<IConstr> it = constraints.iterator();
 			while(it.hasNext()){
 				theSolver.removeConstraint(it.next());		
 			}
 			
 			// Do NOT add a constraint here to force the solver out of this cone. 
 			// Do that in the next solve() call. We want to leave open the possibility
 			// of landing in this cone again to support lifting/exporation!		
 		}
 
 		
 		/**
 		 * Minimizes the model in the SAT solver.
 		 * @throws TimeoutException
 		 * @throws ContradictionException
 		 * @throws NotMinimalModelException 
 		 */
 /*		private void minimizeWithDiscard() throws TimeoutException, ContradictionException, NotMinimalModelException{
 			
 			// Assumption: Have already found a model at this point!
 					
 			
 			// This keeps constraints to be removed from the solver
 			// after finding the next model.
 			Set<IConstr> constraints = new HashSet<IConstr>();
 			
 			// All the unit clauses being passed to the solver as assumptions.
 			Set<Integer> unitClauses = toSet(lifters);
 			
 			// Add all coneRestrictionUnits
 			for(Integer value: coneRestrictionUnits)
 				unitClauses.add(value);
 			
 			MinSATSolver theSolver = ((MinSATSolver)translation.cnf());
 			
 			boolean needToCheck = true;
 			
 			//COMMENT: With the current configuration (SB = OFF) for the augmented iterators, we don't need to
 			//check for minimality.
 			if(isAugmented()) //if the iterator is an augmentation
 				needToCheck = false;
 			
 			
 			int iterationCounter = 1;						
 			
 			do
 			{
 				// Given that candidate for minimal-model, try to make something smaller.
 				// add: disjunction of negations of all positive literals in M (constraint)
 				// add: all negative literals as unit clauses
 				
 				// An array of the next constraint being added.
 				List<Integer> loseSomethingPositive = new ArrayList<Integer>();
 				
 				int numPrimaryVariables = translation.numPrimaryVariables();
 					
 				for(int i = 1; i <= numPrimaryVariables; i++){
 					if(theSolver.valueOf(i) == true)
 						loseSomethingPositive.add(-i);
 					else // don't set anything curr. negative to positive.
 						unitClauses.add(-i);
 				}
 				
 				if(loseSomethingPositive.size() == 0)
 				{
 					// We have minimized down to the empty model. No need to
 					// check to see if it is minimal in the original category!
 					// Also: avoid calling the final SAT (would be a Contradiction).
 					needToCheck = false;
 					break;
 				}
 				if(loseSomethingPositive.size() == 1)
 				{
 					// We have only one relational fact that can possibly be removed.
 					unitClauses.add(loseSomethingPositive.get(0));
 				}
 				else
 				{
 					constraints.add(theSolver.addConstraint(toIntCollection(loseSomethingPositive)));
 				}
 				
 				iterationCounter++;
 			}
 			while(Boolean.valueOf(theSolver.solve(toIntCollection(unitClauses))));
 					
 			boolean badSolution = false;
 			// Don't check for true minimality if we already have the empty model.
 			if(needToCheck)
 			{
 				//////////////////////////////////
 				// Deactivate SBP. We need to see if this minimal candidate
 				// is truly minimal in the original category (NOT the category
 				// that includes the SBP.)			
 				//JOptionPane.showMessageDialog(null, theSolver.internalNumConstraints());
 				theSolver.deactivateSBP();
 				// Unsatisfiable w/ SBP active (or we wouldn't be here). Try without:
 				badSolution = theSolver.solve(toIntCollection(unitClauses), false);							
 				// Re-activate SBP 
 				//JOptionPane.showMessageDialog(null, theSolver.internalNumConstraints());
 				theSolver.activateSBP();
 				//JOptionPane.showMessageDialog(null, theSolver.internalNumConstraints());
 				//////////////////////////////////
 			}
 			
 			((MyReporter)options.reporter()).setIterations(iterationCounter);
 			
 			//internalMinimalCandidatesFoundCounter++;
 			
 //			JOptionPane.showMessageDialog(null, Arrays.toString(Arrays.copyOf(theSolver.getLastModel(), translation.numPrimaryVariables())));
 					
 			// Remove all the (non-unit) loseSomethingPositive constraints we just added from the solver:
 			Iterator<IConstr> it = constraints.iterator();
 			while(it.hasNext()){
 				theSolver.removeConstraint(it.next());		
 			}
 			
 			// Do NOT add a constraint here to force the solver out of this cone. 
 			// Do that in the next solve() call. We want to leave open the possibility
 			// of landing in this cone again to support lifting/exporation!		
 			
 			// Finally, if this isn't a real solution, throw an exception to warn the caller.
 			if(badSolution)
 				throw new NotMinimalModelException();
 		}*/
 
 		
 		/*class NotMinimalModelException extends Exception
 		{			
 			private static final long serialVersionUID = 1L;
 
 			NotMinimalModelException()
 			{
 				
 			}
 		}*/
 		
 		
 		/**
 		 * Computes all the lifters for the current model loaded in the solver.
 		 * @return
 		 * @throws TimeoutException
 		 * @throws ContradictionException
 		 */
 		public int[] getLifters() throws TimeoutException, ContradictionException
 		{
 			assert(!trivial);
 			
 			MinSATSolver solver = (MinSATSolver)translation.cnf();								
 			Set<Integer> wantToAdd = new HashSet<Integer>();
 			ArrayList<Integer> retVal = new ArrayList<Integer>();
 			List<Integer> preservedFacts = new ArrayList<Integer>();
 			
 			//TODO claimSATSolver does not have to fill all the clauses in here.
 			claimSATSolver();
 			removeAllConstraints();
 			
 			// Always deactivate SBP before searching for augmentations
 			solver.deactivateSBP();
 			
 			// preservedFacts are the positive literals that define the "cone" we are in.
 			// wantToAdd are the negative (turned positive) literals we want to check for in the cone.
 			
 			int numPrimaryVariables = translation.numPrimaryVariables();
 			int[] propositionalModel = lastSolution.getPropositionalModel();
 			
 			for(int i = 1; i <= numPrimaryVariables; i++){
 				if(propositionalModel[i - 1] > 0)
 					preservedFacts.add(i);
 				else
 					wantToAdd.add(i);
 			}
 			
 			
 			boolean wasSatisfiable = false;
 			List<Integer> unitClauses = new ArrayList<Integer>(preservedFacts);
 			// Loop while (a) there are facts left to find and (b) still satisfiable.
 			do
 			{
 				// Add a disjunction for the current set of literals we want to find:
 				IConstr removeWTA = null;
 				//System.out.println("Adding WTA: "+wantToAdd);
 				if(wantToAdd.size() > 1)
 				{
 					removeWTA = solver.addConstraint(toIntCollection(wantToAdd));
 				}
 				else
 				{
 					for(Integer onlyOne : wantToAdd)
 						unitClauses.add(onlyOne);
 				}
 				
 				wasSatisfiable = solver.solve(toIntCollection(unitClauses));		
 				
 				if(wasSatisfiable)
 				{
 					
 					//System.out.println("Model found was: "+Arrays.toString(tempModel));
 					Set<Integer> foundLifters = new HashSet<Integer>(); // avoid concurrentmodificationexception
 					for(Integer toAdd : wantToAdd)
 					{
 						// The -1 is because the model is an array (start = 0) 
 						// yet our variables start=1
 						if(solver.valueOf(toAdd))
 						{
 							foundLifters.add(toAdd);
 							retVal.add(toAdd);
 						}
 					}
 
 					wantToAdd.removeAll(foundLifters);
 				}	
 				
 				// Remove the targets for this iteration (may not be needed?)
 				if(removeWTA != null)
 					solver.removeConstraint(removeWTA);
 				
 			}
 			while(wantToAdd.size() > 0 && wasSatisfiable);
 			
 			// If this is an un-augmented iterator, re-activate symmetry-breaking
 			// (Or else the next models would not benefit from SB.)
 			if(!isAugmented())
 				solver.activateSBP();
 			
 			return toIntCollection(retVal);
 		}
 		
 		/**
 		 * Returns the translation for this iterator.
 		 * @return the translation.
 		 */
 		public MinTranslation getTranslation(){
 			return translation;
 		}
 		
 		/**
 		 * Returns the last solution of the iterator.
 		 * @return the last solution.
 		 */
 		private MinSolution getLastSolution(){
 			return lastSolution;
 		}
 		
 		/**
 		 * Returns true if the iterator is an augmentation and returns false otherwise.
 		 */
 		private boolean isAugmented(){
 			return lifters != null && lifters.length > 0;
 		}
 		
 		//Helpers:
 		/**
 		 * Considers all the constraints.
 		 * @throws ContradictionException
 		 */
 		private void addAllClauses() throws ContradictionException{
 			for(List<Integer> list: coneRestrictionClauses){
 				coneRestrictionConstraints.add(((MinSATSolver)translation.cnf()).addConstraint(toIntCollection(list)));					
 			}
 		}
 		
 		/**
 		 * Removes all the cone restriction constraints of this iterator.
 		 */
 		private void removeAllConstraints(){
 			Iterator<IConstr> it = coneRestrictionConstraints.iterator();
 			while(it.hasNext()){
 				IConstr temp = it.next();
 				translation.cnf().removeConstraint(temp);
 				it.remove();
 			}
 		}		
 		
 		static int[] toIntCollection(Collection<Integer> integers)
 		{
 		    int[] ret = new int[integers.size()];
 		    int iIndex = 0;
 		    for(Integer anInt : integers)
 		    {
 		        ret[iIndex] = anInt;
 		    	iIndex++;	    	
 		    }
 		    return ret;
 		}
 		
 		/**
 		 * Converts a list of integers to an ArrayList.
 		 * @param list the list.
 		 * @return the ArrayList containing the elements of list.
 		 */
 		private Set<Integer> toSet(int[] list){
 			Set<Integer> retVal = new HashSet<Integer>();
 			if(list != null){
 				for(int i = 0; i < list.length; i++){
 					retVal.add(list[i]);
 				}
 			}
 			
 			return retVal;
 		}
 	}
 	
 	/**
 	 * Handles the translation of propositional elements to relational facts and vice versa.
 	 * Caution: Pass the skolem bounds here.
 	 * @author Salman
 	 *
 	 */
 	public static class MinTwoWayTranslator{
 		
 		private static Map<Integer, Relation> buildVarToRelationMap(
 				MinTranslation translation, Bounds aBounds){
 			Map<Integer, Relation> mapVarToRelation = new HashMap<Integer, Relation>(); 
 			for(Relation r : aBounds.relations())
 			{
 				IntSet varsForThisRelation = translation.primaryVariables(r);
 				
 				//if there is no primary variable for this relation, continue:
 				if(varsForThisRelation == null)
 					continue;
 				
 				IntIterator itVarsForThis = varsForThisRelation.iterator();
 				while(itVarsForThis.hasNext())
 				{
 					mapVarToRelation.put(itVarsForThis.next(), r);
 				}
 					
 			}
 			
 			return mapVarToRelation;
 		}
 		
 		/**
 		 * Used for debugging purposes. Print the bijection between propositional
 		 * variables and relational facts as a string.
 		 * @param translation
 		 * @param aBounds
 		 * @param mapVarToRelation
 		 * @return
 		 */
 		@SuppressWarnings("unused")
 		private static String printTranslation(MinTranslation translation, Bounds aBounds,
 				Map<Integer, Relation> mapVarToRelation)
 		{
 			String outs="";
 			
 			// Now that we have the mapping from var --> its relation, we can find the tuple:		
 			for(int theVar = 1; theVar <= translation.numPrimaryVariables(); theVar++)
 			{					
 				Relation myRelation = mapVarToRelation.get(theVar);
 				
 				IntSet s = translation.primaryVariables(myRelation);
 				
 				Tuple myTuple = getTupleForPropVariable(
 							aBounds, translation, s, myRelation, theVar);
 									
 				outs += (theVar+": "+myTuple+" "+myRelation+" | ");
 				if(theVar % 4 == 0)
 					outs += "\n";
 			}
 			
 			return outs;				
 		}
 
 		
 		/**
 		 * Converts a set of primary propositional variables into set of relational expressions.
 		 * @param translation the translation.
 		 * @param aBounds the bounds.
 		 * @param theVars a VectInt of the variables to convert.
 		 * @return
 		 */
 		private static Instance translatePropositions(MinTranslation translation, Bounds aBounds,
 				Map<Integer, Relation> mapVarToRelation, int[] theVars)
 		{
 			// Populate an empty instance over the universe we're using:
 			Instance result = new Instance(aBounds.universe());
 
 			// Now that we have the mapping from var --> its relation, we can find the tuple:		
 			for(int i = 0; i < theVars.length; i++)
 			{	
 				int theVar = theVars[i];
 				Relation myRelation = mapVarToRelation.get(theVar);
 				
 				IntSet s = translation.primaryVariables(myRelation);
 				
 				Tuple myTuple = getTupleForPropVariable(
 							aBounds, translation, s, myRelation, theVar);
 					
 				// .add here is actually .set -- it overwrites what is already in the relation.
 				// So we CANNOT just do:			
 				//result.add(myRelation, bounds.universe().factory().setOf(myTuple));
 				
 				TupleSet currentContents = result.tuples(myRelation);
 				TupleSet theContents = aBounds.universe().factory().setOf(myTuple);
 				if(currentContents != null) // returns null instead of empty set!!
 					theContents.addAll(currentContents); 
 				
 				result.add(myRelation, theContents);
 			}
 			
 			// Set<RelationalFact> would be better than Instance. But for now use Instance
 			
 			// Return an instance (should not be interpreted as a model of the qry!!) that contains
 			// only those relational facts indicated by theVars
 			return result;				
 		}
 
 		
 		private static Tuple getTupleForPropVariable(Bounds aBounds, MinTranslation theTranslation, IntSet s, Relation r, int theVar)
 		//throws MInternalNoBoundsException
 		{
 			// The relation's upper bound has a list of tuple indices. The "index" variable below is an index
 			// into that list of indices. (If our upper bound was _everything_, would be no need to de-reference.)
 	        int minVarForR = s.min();
 			
 			// Compute index: (variable - minvariable) of this relation's variables 
 	        int index = theVar - minVarForR;
 	        
 	        // OPT: How slow is this? May want to cache...
 	        int[] arr = aBounds.upperBound(r).indexView().toArray();
 	        
 	        TupleFactory factory = aBounds.universe().factory();   
 	        Tuple tup = factory.tuple(r.arity(), arr[index]);  
 
 	        //MCommunicator.writeToLog("\ngetTupleForPropVariable: thisTuple="+tup+" for "+theVar+". Relation had vars: "+s+" and the offset was "+minVarForR+
 	        //		"leaving index="+index+". Upper bound indexview: "+Arrays.toString(arr)+
 	        //		"\nThe de-referenced tuple index is: "+arr[index]);
 
 	        return tup;
 		}
 		
 		private static int getPropVariableForTuple(Bounds aBounds, MinTranslation translation, Relation r, Tuple tuple){
 			IntSet s = translation.primaryVariables(r);
 
 			//if there is no primary variable for this relation, return -1
 			if(s == null)
 				return -1;
 			
 			TupleSet upperBound = aBounds.upperBound(r);
 			
 			if(upperBound == null)
 				return -1;
 			
 			int[] arr = upperBound.indexView().toArray();
 
 			
 	        TupleFactory factory = aBounds.universe().factory();
 	        
 	        int index = -1;
 	        //Not the best way of doing this!
 	        for(int i = 0; i < arr.length; i++){
 	        	if(tuple.equals(factory.tuple(r.arity(), arr[i])))
 	        		index = i;
 	        }
 	        
 	        if(index == -1)
 	        	return -1;
 	        
 			return s.min() + index;//s.min() + tuple.index();
 		}
 	}
 	
 }
